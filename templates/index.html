<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LockIN - AI Task Scheduler</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Mulish:wght@200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://apis.google.com/js/api.js"
      onload="window.gapiLoaded = true; if (window.domReady) init();"
      async
      defer
    ></script>
    <script>
      window.__gapiLoadCount = 0;
      const gapiCheck = setInterval(() => {
        window.__gapiLoadCount++;
        if (typeof gapi !== "undefined") {
          clearInterval(gapiCheck);
          console.log("gapi loaded after", window.__gapiLoadCount * 100, "ms");
        } else if (window.__gapiLoadCount > 50) {
          clearInterval(gapiCheck);
          console.error("gapi failed to load after 5s");
        }
      }, 100);
    </script>

    <meta
      http-equiv="Content-Security-Policy"
      content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://apis.google.com https://accounts.google.com https://www.gstatic.com https://ssl.gstatic.com https://content.googleapis.com https://*.gstatic.com;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://accounts.google.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://www.googleapis.com https://accounts.google.com https://content.googleapis.com https://www.gstatic.com https://oauth2.googleapis.com;
  frame-src 'self' https://accounts.google.com https://content.googleapis.com https://www.google.com https://www.gstatic.com;
  img-src 'self' data: https: blob:;
  worker-src 'self' blob:;
"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Mulish", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        position: relative;
        padding-top: 40px;
      }

      .header-actions {
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .header-actions .header-google-btn {
        padding: 8px 16px;
        font-size: 0.9em;
        border-width: 1px;
        min-width: 180px;
        justify-content: center;
      }

      .header-button {
        background: #f7fafc;
        border: 2px solid #e2e8f0;
        color: #2d3748;
        padding: 8px 16px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .header-button:hover {
        background: #e2e8f0;
      }

      .header-button.notification-active {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        border-color: #2f855a;
        color: #ffffff;
      }

      .header-button.notification-blocked {
        background: #fed7d7;
        border-color: #fc8181;
        color: #c53030;
      }

      .header .logo {
        max-width: 200px;
        width: 100%;
        height: auto;
        display: block;
        margin: 0 auto 10px;
      }

      .header p {
        opacity: 0.9;
        font-size: 1.1em;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .sidebar {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        max-height: 120vh;
        overflow-y: auto;
      }

      .calendar-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .add-task-form {
        margin-bottom: 30px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        color: #4a5568;
        font-weight: 500;
      }

      input,
      select {
        width: 100%;
        padding: 10px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #4a5568;
      }

      .task-list {
        margin-top: 30px;
      }

      .task-item {
        background: #f7fafc;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
        border-left: 4px solid #667eea;
      }

      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .task-name {
        font-weight: 600;
        color: #2d3748;
      }

      .task-deadline {
        font-size: 12px;
        color: #718096;
      }

      .task-progress {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }

      .progress-bar {
        flex: 1;
        height: 8px;
        background: #e2e8f0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
        transition: width 0.3s;
      }

      .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .calendar-nav {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .nav-btn {
        background: #edf2f7;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        color: #4a5568;
        transition: background 0.2s, transform 0.2s;
      }

      .nav-btn:hover {
        background: #cbd5f5;
        transform: translateY(-1px);
      }

      .nav-btn:active {
        transform: scale(0.95);
      }

      .week-view {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .calendar-scroll {
        max-height: 720px;
        overflow-y: auto;
        padding-right: 6px;
        scroll-behavior: smooth;
      }

      .calendar-scroll::-webkit-scrollbar {
        width: 8px;
      }

      .calendar-scroll::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.35);
        border-radius: 4px;
      }

      .week-view-header,
      .week-view-grid {
        display: grid;
        grid-template-columns: 80px repeat(7, 1fr);
        gap: 10px;
      }

      .time-slot-label {
        color: #718096;
        font-size: 12px;
        text-align: right;
        padding-right: 10px;
        height: 60px;
        display: flex;
        align-items: flex-start;
        justify-content: flex-end;
      }

      .time-column {
        display: flex;
        flex-direction: column;
      }

      .day-header {
        font-weight: 600;
        color: #2d3748;
        text-align: center;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .day-column-body {
        position: relative;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #ffffff;
        overflow: visible;
        padding: 0 6px;
      }

      .hour-divider {
        position: absolute;
        left: 0;
        right: 0;
        height: 0;
        border-top: 1px solid #f0f0f0;
      }

      .scheduled-task {
        position: absolute;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 6px;
        border-radius: 6px;
        font-size: 11px;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow: hidden;
        line-height: 1.2;
      }

      .scheduled-task:hover {
        transform: scale(1.02);
      }

      .scheduled-task[data-draggable="true"] {
        cursor: grab;
      }

      .scheduled-task.dragging {
        opacity: 0.85;
        cursor: grabbing;
      }

      .scheduled-task.in-progress {
        background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
      }

      .scheduled-task.completed {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }

      .scheduled-task.external-event {
        background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
      }

      .scheduled-task .event-title {
        font-weight: 600;
        font-size: 12px;
      }

      .scheduled-task .event-time {
        font-size: 11px;
        opacity: 0.85;
      }

      .day-column-body.drag-over {
        outline: 2px dashed #0bc5ea;
        outline-offset: -4px;
      }

      .deadline-flag {
        position: absolute;
        right: 12px;
        background: #e53e3e;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        box-shadow: 0 2px 4px rgba(229, 62, 62, 0.2);
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        min-width: 300px;
        animation: slideIn 0.3s ease;
        display: none;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      .notification.show {
        display: block;
      }

      .notification-header {
        font-weight: 600;
        margin-bottom: 10px;
        color: #2d3748;
      }

      .notification-body {
        color: #4a5568;
        margin-bottom: 15px;
      }

      .notification-actions {
        display: flex;
        gap: 10px;
      }

      .notification-btn {
        flex: 1;
        padding: 8px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
      }

      .notification-btn.accept {
        background: #48bb78;
        color: white;
      }

      .notification-btn.decline {
        background: #fc8181;
        color: white;
      }

      .notification-btn.reschedule {
        background: #f6d365;
        color: #2d3748;
      }

      .stats-panel {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        margin-top: 15px;
      }

      .stat-card {
        text-align: center;
        padding: 15px;
        background: #f7fafc;
        border-radius: 8px;
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        color: #667eea;
      }

      .stat-label {
        color: #718096;
        font-size: 0.9em;
        margin-top: 5px;
      }

      .ai-suggestions {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
      }

      .ai-suggestions h3 {
        color: #92400e;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .suggestion-item {
        background: white;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .suggestion-item:hover {
        transform: translateX(5px);
      }

      .pomodoro-timer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 15px;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 100;
      }

      .timer-display {
        font-size: 2.2em;
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 10px;
      }

      .timer-label {
        font-size: 0.9em;
        color: #718096;
        margin-bottom: 15px;
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }

      .timer-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: transform 0.2s;
      }

      .timer-btn:hover {
        transform: scale(1.05);
      }

      .timer-btn.pause {
        background: #f6d365;
        color: #2d3748;
      }

      .timer-btn.resume {
        background: #48bb78;
        color: white;
      }

      .timer-btn.stop {
        background: #fc8181;
        color: white;
      }

      .deadline-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #e53e3e;
        pointer-events: none;
        z-index: 20;
      }

      .deadline-label {
        position: absolute;
        top: -20px;
        background: #e53e3e;
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        transform: translateX(-50%);
      }

      .google-cal-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .google-section-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 10px;
        padding: 12px 16px;
        color: #2d3748;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .google-section-toggle:hover {
        background: #edf2f7;
      }

      .google-section-toggle.collapsed .toggle-icon,
      .google-section-toggle .toggle-icon {
        font-size: 0.9em;
        transform: rotate(0deg);
        transition: transform 0.2s ease;
      }

      .google-section-toggle.expanded .toggle-icon {
        transform: rotate(90deg);
      }

      .google-cal-content {
        margin-top: 16px;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        transition: max-height 0.25s ease, opacity 0.25s ease;
        max-height: 600px;
        overflow: hidden;
        opacity: 1;
      }

      .google-cal-content.collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border-width: 0;
      }

      .google-cal-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9em;
        color: #4a5568;
        margin-bottom: 12px;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid #e2e8f0;
        font-size: 0.85em;
      }

      .status-pill.success {
        background: #c6f6d5;
        border-color: #48bb78;
        color: #22543d;
      }

      .status-pill.warning {
        background: #fed7d7;
        border-color: #fc8181;
        color: #9b2c2c;
      }

      .google-btn {
        background: white;
        border: 2px solid #4285f4;
        color: #4285f4;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.3s;
      }

      .google-btn:hover {
        background: #4285f4;
        color: white;
      }

      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(45, 55, 72, 0.45);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1200;
        padding: 20px;
      }

      .modal-overlay.show {
        display: flex;
      }

      .modal-content {
        background: #ffffff;
        border-radius: 16px;
        max-width: 420px;
        width: 100%;
        padding: 24px;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: transparent;
        border: none;
        font-size: 20px;
        color: #4a5568;
        cursor: pointer;
      }

      .modal-time {
        color: #4a5568;
        margin-top: 8px;
        font-size: 0.95em;
      }

      .modal-meta {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
        margin-top: 16px;
      }

      .modal-meta div {
        background: #f7fafc;
        border-radius: 8px;
        padding: 10px;
        font-size: 0.85em;
        color: #2d3748;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .meta-label {
        font-size: 0.75em;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #718096;
      }

      .modal-description {
        margin-top: 18px;
        color: #4a5568;
        font-size: 0.95em;
        line-height: 1.5;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
        margin-top: 24px;
        flex-wrap: wrap;
      }

      .modal-actions button {
        flex: 1;
        min-width: 140px;
        padding: 10px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .modal-actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.18);
      }

      .modal-actions .primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
      }

      .modal-actions .danger {
        background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);
        color: #ffffff;
      }

      .modal-actions .secondary {
        background: #edf2f7;
        color: #2d3748;
      }

      @media (max-width: 768px) {
        .main-grid {
          grid-template-columns: 1fr;
        }

        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
        .logo {
          height: 100px;
        }

        .header-actions {
          position: static;
          justify-content: flex-end;
          margin-bottom: 10px;
        }

        .modal-meta {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body
    data-user-id="{{ user_id }}"
    data-user-email="{{ user_profile.get('email', '') if user_profile else '' }}"
  >
    <div class="container">
      <div class="header">
        <div class="header-actions">
          <button class="google-btn header-google-btn" id="googleAuthButton">
            Connect Google Calendar
          </button>
          <button
            type="button"
            class="header-button"
            id="notificationPermissionButton"
            onclick="requestNotificationPermission()"
          >
            Enable Notifications
          </button>
        </div>
        <img
          src="{{ url_for('static', filename='images/LockIN-logo-noBG.png') }}"
          class="logo"
          alt="LockIN logo"
        />
        <p>Find your flow, stay locked in.</p>
      </div>

      <div class="main-grid">
        <div class="sidebar">
          <div class="add-task-form">
            <h2 style="color: #2d3748; margin-bottom: 20px">Add New Task</h2>
            <div class="form-group">
              <label for="taskName">Task Name</label>
              <input
                type="text"
                id="taskName"
                placeholder="e.g., Complete project proposal"
              />
            </div>
            <div class="form-group">
              <label for="deadline">Deadline</label>
              <input type="datetime-local" id="deadline" />
            </div>
            <div class="form-group">
              <label for="daysRequired">Days Required</label>
              <input type="number" id="daysRequired" min="1" value="1" />
            </div>
            <div class="form-group">
              <label for="dailyHours">Daily Hours</label>
              <input
                type="number"
                id="dailyHours"
                min="0.5"
                step="0.5"
                value="2"
              />
            </div>
            <button class="btn" onclick="addTask()">Add Task</button>
          </div>

          <div class="ai-suggestions" id="aiSuggestions">
            <h3>ü§ñ AI Suggestions</h3>
            <div id="suggestionsList"></div>
          </div>

          <div class="task-list">
            <h3 style="color: #2d3748; margin-bottom: 15px">Active Tasks</h3>
            <div id="taskList"></div>
          </div>
        </div>

        <div class="calendar-section">
          <div class="calendar-header">
            <h2 style="color: #2d3748">Week View</h2>
            <div class="calendar-nav">
              <button
                class="nav-btn"
                id="prevWeekBtn"
                aria-label="Previous week"
              >
                &lsaquo;
              </button>
              <span id="currentWeek" style="color: #718096"></span>
              <button class="nav-btn" id="nextWeekBtn" aria-label="Next week">
                &rsaquo;
              </button>
            </div>
          </div>
          <div class="week-view" id="weekView">
            <!-- Calendar will be generated here -->
          </div>
        </div>
      </div>

      <div class="stats-panel">
        <h3 style="color: #2d3748">Productivity Stats</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="tasksCompleted">0</div>
            <div class="stat-label">Tasks Completed</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="focusTime">0h</div>
            <div class="stat-label">Focus Time Today</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="streakDays">0</div>
            <div class="stat-label">Day Streak</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="completionRate">0%</div>
            <div class="stat-label">Completion Rate</div>
          </div>
        </div>
      </div>
    </div>

    <div class="notification" id="notification">
      <div class="notification-header" id="notificationHeader">
        Task Reminder
      </div>
      <div class="notification-body" id="notificationBody">
        It's time for your scheduled task
      </div>
      <div class="notification-actions">
        <button
          class="notification-btn accept"
          onclick="handleNotification('accept')"
        >
          Start
        </button>
        <button
          class="notification-btn reschedule"
          onclick="handleNotification('reschedule')"
        >
          Reschedule
        </button>
        <button
          class="notification-btn decline"
          onclick="handleNotification('decline')"
        >
          Skip
        </button>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="eventModal"
      onclick="handleModalOverlayClick(event)"
    >
      <div class="modal-content">
        <button class="modal-close" onclick="closeEventModal()">&times;</button>
        <h3 id="modalTitle" style="color: #2d3748; font-size: 1.4em">
          Scheduled Block
        </h3>
        <p class="modal-time" id="modalTime"></p>
        <div class="modal-meta">
          <div>
            <span class="meta-label">Source</span>
            <span id="modalSource"></span>
          </div>
          <div>
            <span class="meta-label">Status</span>
            <span id="modalStatus"></span>
          </div>
          <div>
            <span class="meta-label">Duration</span>
            <span id="modalDuration"></span>
          </div>
          <div id="modalLocationRow" style="display: none">
            <span class="meta-label">Location</span>
            <span id="modalLocation"></span>
          </div>
        </div>
        <p class="modal-description" id="modalDescription"></p>
        <div class="modal-actions">
          <button
            class="secondary"
            id="modalCloseBtn"
            onclick="closeEventModal()"
          >
            Close
          </button>
          <button
            class="primary"
            id="modalStartBtn"
            onclick="startFocusFromModal()"
          >
            Start Focus Session
          </button>
          <button
            class="danger"
            id="modalDeleteBtn"
            onclick="deleteScheduleItem()"
          >
            Delete Block
          </button>
        </div>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="errorModal"
      onclick="handleErrorModalOverlayClick(event)"
    >
      <div class="modal-content">
        <button class="modal-close" onclick="closeErrorModal()">&times;</button>
        <h3 style="color: #2d3748; font-size: 1.3em; margin-bottom: 12px">
          Placement Blocked
        </h3>
        <p
          id="errorModalMessage"
          style="color: #4a5568; line-height: 1.4; margin-bottom: 20px"
        ></p>
        <div class="modal-actions">
          <button class="primary" onclick="closeErrorModal()">Got it</button>
        </div>
      </div>
    </div>

    <div class="pomodoro-timer" id="pomodoroTimer" style="display: none">
      <div class="timer-display" id="timerDisplay">25:00</div>
      <div class="timer-label" id="timerLabel">Focus Time</div>
      <div class="timer-controls">
        <button
          class="timer-btn pause"
          id="pauseBtn"
          onclick="togglePauseResume()"
        >
          ‚è∏ Pause
        </button>
        <button class="timer-btn stop" onclick="stopPomodoro()">‚èπ Stop</button>
      </div>
    </div>

    <div class="google-cal-section" id="googleCalSection" style="display: none">
      <button type="button" class="google-section-toggle" id="googleCalToggle">
        <span>Google Calendar Integration</span>
        <span class="toggle-icon" aria-hidden="true">‚ñ∏</span>
      </button>
      <div class="google-cal-content collapsed" id="googleCalContent">
        <div class="google-cal-status">
          <span>Status:</span>
          <span id="authStatus" class="status-pill">Not Connected</span>
        </div>
        <button
          class="google-btn"
          id="refreshEventsBtn"
          style="display: none"
          onclick="refreshGoogleEvents()"
        >
          Refresh Google Events
        </button>
        <div id="calendarEvents" style="margin-top: 15px">
          <p style="color: #718096">
            Connect from the top-right button to sync your Google Calendar.
          </p>
        </div>
      </div>
    </div>

    <script>
      const DISCOVERY_DOCS = [
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest",
      ];
      const USER_ID = document.body.dataset.userId || "guest";
      const storageKey = (base) => `${base}_${USER_ID}`;
      const DEFAULT_STATS = {
        completed: 0,
        focusTime: 0,
        streak: 0,
        totalTasks: 0,
      };

      const deepClone = (value) => JSON.parse(JSON.stringify(value));
      function loadStorage(base, defaultValue) {
        try {
          const raw = localStorage.getItem(storageKey(base));
          if (!raw) {
            return deepClone(defaultValue);
          }
          return JSON.parse(raw);
        } catch (error) {
          console.warn(`Failed to load ${base} from storage`, error);
          return deepClone(defaultValue);
        }
      }

      function saveStorage(base, value) {
        try {
          localStorage.setItem(storageKey(base), JSON.stringify(value));
        } catch (error) {
          console.warn(`Failed to persist ${base} in storage`, error);
        }
      }

      const GOOGLE_CAL_STATE_KEY = storageKey("googleCalExpanded");

      // State Management
      let tasks = loadStorage("tasks", []);
      let schedule = loadStorage("schedule", []);
      let dismissedGoogleEvents = new Set(
        loadStorage("dismissedGoogleEvents", []).map(String)
      );
      let notifiedSlots = new Set(loadStorage("notifiedSlots", []).map(String));
      let notifiedDeadlines = new Set(
        loadStorage("notifiedDeadlines", []).map(String)
      );
      let lastMissedNotificationDate = localStorage.getItem(
        storageKey("lastMissedNotificationDate")
      );
      let lastAiNotification = Number(
        localStorage.getItem(storageKey("lastAiNotification")) || "0"
      );
      let activeScheduleId = null;
      let currentTask = null;
      let pomodoroInterval = null;
      let pomodoroTimeLeft = 25 * 60;
      let pomodoroPaused = false;
      let stats = loadStorage("stats", DEFAULT_STATS);

      const FOCUS_SLOT_MINUTES = 30;
      const FOCUS_SLOT_MS = FOCUS_SLOT_MINUTES * 60 * 1000;
      const PREFERRED_TIME_WINDOWS = [
        { startHour: 9, endHour: 11, productivity: 1.2 },
        { startHour: 14, endHour: 16, productivity: 1.0 },
        { startHour: 19, endHour: 21, productivity: 0.8 },
      ];

      // Google Calendar API configuration
      const GOOGLE_CLIENT_ID = "{{ google_client_id or '' }}";
      const GOOGLE_API_KEY = "{{ calendar_api_key or '' }}";
      const SCOPES = "{{ google_scopes or '' }}";

      let domReady = false;
      window.gapiLoaded = window.gapiLoaded || false;
      let calendarApiLoaded = false;
      let googleAccountAuthenticated = false;
      let currentWeekStart = getStartOfWeek(new Date());
      let calendarScrollInitialized = false;
      let userAdjustedCalendarScroll = false;
      let draggedScheduleId = null;

      function setGoogleCalendarExpanded(expand, persist = true) {
        const toggle = document.getElementById("googleCalToggle");
        const content = document.getElementById("googleCalContent");
        if (!toggle || !content) return;

        if (expand) {
          content.classList.remove("collapsed");
          toggle.classList.add("expanded");
          toggle.setAttribute("aria-expanded", "true");
        } else {
          content.classList.add("collapsed");
          toggle.classList.remove("expanded");
          toggle.setAttribute("aria-expanded", "false");
        }

        if (persist) {
          localStorage.setItem(GOOGLE_CAL_STATE_KEY, expand ? "1" : "0");
        }
      }

      function setupGoogleCalendarToggle() {
        const toggle = document.getElementById("googleCalToggle");
        const content = document.getElementById("googleCalContent");
        if (!toggle || !content) return;

        const storedState = localStorage.getItem(GOOGLE_CAL_STATE_KEY);
        if (storedState === "1") {
          setGoogleCalendarExpanded(true, false);
        } else {
          setGoogleCalendarExpanded(false, false);
        }

        toggle.addEventListener("click", () => {
          const shouldExpand = content.classList.contains("collapsed");
          setGoogleCalendarExpanded(shouldExpand);
        });
      }

      function applyCalendarScrollFocus() {
        const scrollContainer = document.getElementById("calendarScroll");
        if (!scrollContainer) {
          return;
        }

        if (!calendarScrollInitialized) {
          scrollContainer.addEventListener("scroll", () => {
            if (scrollContainer.dataset.lockScroll === "1") {
              return;
            }
            userAdjustedCalendarScroll = true;
            scrollContainer.dataset.userAdjusted = "true";
          });
        }

        if (!userAdjustedCalendarScroll) {
          scrollContainer.dataset.lockScroll = "1";
          const offset = Math.max(
            0,
            (DEFAULT_CALENDAR_VIEW_START - CALENDAR_DAY_START) *
              CALENDAR_SLOT_HEIGHT
          );
          scrollContainer.scrollTop = offset;
          requestAnimationFrame(() => {
            scrollContainer.dataset.lockScroll = "0";
          });
        }

        calendarScrollInitialized = true;
      }

      // Initialize the app
      function init() {
        setDefaultDeadline();
        setupGoogleCalendarToggle();
        const prevWeekBtn = document.getElementById("prevWeekBtn");
        const nextWeekBtn = document.getElementById("nextWeekBtn");
        if (prevWeekBtn && nextWeekBtn) {
          prevWeekBtn.addEventListener("click", () => changeWeek(-1));
          nextWeekBtn.addEventListener("click", () => changeWeek(1));
        }
        updateGoogleAuthUI();
        renderTasks();
        renderCalendar();
        updateStats();
        startNotificationChecker();
        generateAISuggestions();
        syncNotificationButton();

        fetch("/check_auth")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("googleCalSection").style.display = "block";
            googleAccountAuthenticated = !!data.authenticated;
            updateGoogleAuthUI();
            if (googleAccountAuthenticated) {
              loadGoogleAPI();
              setTimeout(authenticateGapiWithFlaskToken, 1000);
            }
          });
      }
      // function authenticateGapiWithFlaskToken() {
      //   if (!gapi.auth2 || !gapi.auth2.getAuthInstance()) {
      //     setTimeout(authenticateGapiWithFlaskToken, 500);
      //     return;
      //   }
      //   fetch("/get_gapi_token")
      //     .then((r) => r.json())
      //     .then((tokenData) => {
      //       const authInstance = gapi.auth2.getAuthInstance();
      //       const user = authInstance.currentUser.get();
      //       user.reloadAuthResponse().then(() => {
      //         user.setAuthResponse({
      //           access_token: tokenData.access_token,
      //           expires_in: tokenData.expires_in,
      //           scope: tokenData.scope,
      //         });
      //         updateSigninStatus(true);
      //       });
      //     });
      // }
      function getStartOfWeek(date) {
        const d = new Date(date);
        const day = d.getDay();
        d.setDate(d.getDate() - day);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      // Set default deadline to tomorrow
      function setDefaultDeadline() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 7);
        document.getElementById("deadline").value = tomorrow
          .toISOString()
          .slice(0, 16);
      }

      // Add a new task
      function addTask() {
        const name = document.getElementById("taskName").value;
        const deadline = document.getElementById("deadline").value;
        const daysRequired = parseInt(
          document.getElementById("daysRequired").value
        );
        const dailyHours = parseFloat(
          document.getElementById("dailyHours").value
        );

        if (!name || !deadline) {
          alert("Please fill in task name and deadline");
          return;
        }

        const task = {
          id: Date.now(),
          name,
          deadline: new Date(deadline),
          daysRequired,
          dailyHours,
          totalHours: daysRequired * dailyHours,
          completedHours: 0,
          status: "pending",
          priority: calculatePriority(
            new Date(deadline),
            daysRequired * dailyHours
          ),
          createdAt: new Date(),
        };

        tasks.push(task);
        saveTasks();

        // AI Schedule Generation
        generateSchedule(task);

        // Clear form
        document.getElementById("taskName").value = "";
        document.getElementById("daysRequired").value = "1";
        document.getElementById("dailyHours").value = "2";
        setDefaultDeadline();

        renderTasks();
        renderCalendar();
        generateAISuggestions();

        updateStats();
      }

      // Calculate task priority based on deadline and time required
      function calculatePriority(deadline, totalHours) {
        const now = new Date();
        const hoursUntilDeadline = (deadline - now) / (1000 * 60 * 60);
        const urgency = totalHours / hoursUntilDeadline;
        return Math.min(10, Math.max(1, Math.round(urgency * 10)));
      }

      function roundToNextSlot(date) {
        const next = new Date(date);
        next.setSeconds(0, 0);
        const minutes = next.getMinutes();
        const remainder = minutes % FOCUS_SLOT_MINUTES;
        if (remainder !== 0) {
          next.setMinutes(minutes + (FOCUS_SLOT_MINUTES - remainder));
        }
        return next;
      }

      function isWeekend(date) {
        const day = date.getDay();
        return day === 0 || day === 6;
      }

      function moveToNextWeekdayMorning(date) {
        const next = new Date(date);
        next.setDate(next.getDate() + 1);
        next.setHours(PREFERRED_TIME_WINDOWS[0].startHour, 0, 0, 0);
        while (isWeekend(next)) {
          next.setDate(next.getDate() + 1);
        }
        return next;
      }

      function getPreferredWindow(date) {
        const hour = date.getHours();
        return PREFERRED_TIME_WINDOWS.find(
          (window) => hour >= window.startHour && hour < window.endHour
        );
      }

      function advanceToNextPreferredStart(date) {
        let candidate = new Date(date);
        candidate.setSeconds(0, 0);
        const hour = candidate.getHours();
        const upcoming = PREFERRED_TIME_WINDOWS.find(
          (window) => window.startHour > hour
        );
        if (upcoming) {
          candidate.setHours(upcoming.startHour, 0, 0, 0);
        } else {
          candidate = moveToNextWeekdayMorning(candidate);
        }
        return candidate;
      }

      function sortScheduleEntries() {
        schedule.sort(
          (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
        );
      }

      function findScheduleConflict(startDate, endDate, ignoreId = null) {
        const startMs = startDate.getTime();
        const endMs = endDate.getTime();
        return schedule.find((entry) => {
          if (!entry || entry.type === "deadline") {
            return false;
          }
          if (ignoreId && String(entry.id) === String(ignoreId)) {
            return false;
          }
          const entryStart = entry.start ? new Date(entry.start) : null;
          const entryEnd = entry.end
            ? new Date(entry.end)
            : entryStart
            ? new Date(entryStart.getTime() + FOCUS_SLOT_MS)
            : null;
          if (!entryStart || !entryEnd) {
            return false;
          }
          return entryEnd.getTime() > startMs && entryStart.getTime() < endMs;
        });
      }

      function hasScheduleConflict(startDate, endDate, ignoreId = null) {
        return Boolean(findScheduleConflict(startDate, endDate, ignoreId));
      }

      function resolveFocusConflicts({ save = false } = {}) {
        let changed = false;
        const movableEntries = schedule
          .filter(
            (item) =>
              item &&
              item.type !== "deadline" &&
              item.source !== "google" &&
              item.type !== "external"
          )
          .sort(
            (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
          );

        movableEntries.forEach((item) => {
          if (!item.start) {
            return;
          }

          let startDate = new Date(item.start);
          if (Number.isNaN(startDate.getTime())) {
            return;
          }
          let endDate = item.end
            ? new Date(item.end)
            : new Date(startDate.getTime() + FOCUS_SLOT_MS);

          let conflict = findScheduleConflict(startDate, endDate, item.id);
          if (!conflict) {
            return;
          }

          const associatedTask = tasks.find(
            (task) => String(task.id) === String(item.taskId)
          );

          let searchLimit = null;
          if (associatedTask && associatedTask.deadline) {
            const deadlineCandidate = new Date(associatedTask.deadline);
            if (!Number.isNaN(deadlineCandidate.getTime())) {
              searchLimit = new Date(deadlineCandidate);
              searchLimit.setHours(23, 59, 59, 999);
            }
          }

          let candidate = roundToNextSlot(
            conflict.end ? new Date(conflict.end) : new Date(endDate)
          );

          let attempts = 0;
          const maxAttempts = 4000;
          const globalLimit = new Date(startDate);
          globalLimit.setDate(globalLimit.getDate() + 60);

          while (attempts < maxAttempts && candidate < globalLimit) {
            attempts++;

            if (isWeekend(candidate)) {
              candidate = moveToNextWeekdayMorning(candidate);
              continue;
            }

            const window = getPreferredWindow(candidate);
            if (!window) {
              candidate = advanceToNextPreferredStart(candidate);
              continue;
            }

            const candidateEnd = new Date(candidate.getTime() + FOCUS_SLOT_MS);

            if (searchLimit && candidateEnd.getTime() > searchLimit.getTime()) {
              candidate = moveToNextWeekdayMorning(candidate);
              searchLimit = null;
              continue;
            }

            const blocker = findScheduleConflict(
              candidate,
              candidateEnd,
              item.id
            );

            if (!blocker) {
              item.start = candidate.toISOString();
              item.end = candidateEnd.toISOString();
              if (window.productivity) {
                item.productivity = window.productivity;
              }
              changed = true;
              break;
            }

            const nextBase = blocker.end ? new Date(blocker.end) : candidateEnd;
            candidate = roundToNextSlot(nextBase);
          }
        });

        if (changed) {
          sortScheduleEntries();
        }

        if (changed && save) {
          saveSchedule({ enforce: false });
          renderCalendar();
        }

        return changed;
      }

      // AI-powered schedule generation
      function generateSchedule(task) {
        const now = new Date();
        const deadline = new Date(task.deadline);
        if (Number.isNaN(deadline.getTime())) {
          console.warn("Invalid deadline provided for task", task);
          return;
        }
        const sessions = Math.ceil(task.totalHours * 2); // 30-min sessions

        schedule = schedule.filter((item) => {
          if (String(item.taskId) !== String(task.id)) {
            return true;
          }
          if (item.source === "google" || item.type === "external") {
            return true;
          }
          return false;
        });

        let currentDate = new Date(now.getTime() + 60 * 60 * 1000);
        currentDate = roundToNextSlot(currentDate);

        let sessionsScheduled = 0;
        let safetyCounter = 0;
        const maxIterations = 4000;

        while (
          sessionsScheduled < sessions &&
          currentDate < deadline &&
          safetyCounter < maxIterations
        ) {
          safetyCounter++;

          if (isWeekend(currentDate)) {
            currentDate = moveToNextWeekdayMorning(currentDate);
            continue;
          }

          const window = getPreferredWindow(currentDate);
          if (!window) {
            currentDate = advanceToNextPreferredStart(currentDate);
            continue;
          }

          const proposedStart = new Date(currentDate);
          const proposedEnd = new Date(proposedStart.getTime() + FOCUS_SLOT_MS);

          if (proposedEnd > deadline) {
            break;
          }

          const duplicate = schedule.some(
            (entry) =>
              String(entry.taskId) === String(task.id) &&
              entry.start === proposedStart.toISOString() &&
              entry.end === proposedEnd.toISOString()
          );

          const conflict = findScheduleConflict(proposedStart, proposedEnd);

          if (!duplicate && !conflict) {
            schedule.push({
              id: `${Date.now()}_${sessionsScheduled}_${Math.floor(
                Math.random() * 100000
              )}`,
              taskId: task.id,
              taskName: task.name,
              start: proposedStart.toISOString(),
              end: proposedEnd.toISOString(),
              type: "pomodoro",
              status: "scheduled",
              productivity: window.productivity,
              source: "focusflow",
            });
            sessionsScheduled++;
            currentDate = new Date(proposedEnd);
            continue;
          }

          if (conflict) {
            const conflictEnd = conflict.end
              ? new Date(conflict.end)
              : new Date(proposedEnd);
            currentDate = roundToNextSlot(conflictEnd);
          } else {
            currentDate = new Date(proposedEnd);
          }
        }

        schedule.push({
          id: `${Date.now()}_${Math.floor(Math.random() * 100000)}_deadline`,
          taskId: task.id,
          taskName: task.name + " (DEADLINE)",
          start: deadline.toISOString(),
          end: deadline.toISOString(),
          type: "deadline",
          status: "deadline",
          source: "focusflow",
        });

        saveSchedule();
      }

      // Generate AI suggestions for optimal work times
      function generateAISuggestions() {
        const suggestions = [];
        const now = new Date();
        const hour = now.getHours();

        // Analyze user patterns (simulated)
        const productivityScore = {
          morning: 0.9,
          afternoon: 0.7,
          evening: 0.6,
        };

        // Get high-priority tasks
        const urgentTasks = tasks
          .filter((t) => t.status !== "completed")
          .sort((a, b) => b.priority - a.priority)
          .slice(0, 3);

        urgentTasks.forEach((task) => {
          let suggestedTime = "";
          if (hour < 12 && productivityScore.morning > 0.8) {
            suggestedTime = "Now (High energy morning slot)";
          } else if (hour < 17) {
            suggestedTime = "This afternoon (2-4 PM)";
          } else {
            suggestedTime = "Tomorrow morning (9-11 AM)";
          }

          suggestions.push({
            task: task.name,
            time: suggestedTime,
            reason: `Priority: ${task.priority}/10`,
            taskId: task.id,
          });
        });

        renderAISuggestions(suggestions);
      }

      // Render AI suggestions
      function renderAISuggestions(suggestions) {
        const container = document.getElementById("suggestionsList");

        if (suggestions.length === 0) {
          container.innerHTML =
            '<p style="color: #718096; font-size: 0.9em;">No urgent tasks. Great job!</p>';
          return;
        }

        container.innerHTML = suggestions
          .map(
            (s) => `
                <div class="suggestion-item" onclick="acceptSuggestion(${s.taskId})">
                    <strong>${s.task}</strong><br>
                    <small style="color: #718096;">${s.time} ‚Ä¢ ${s.reason}</small>
                </div>
            `
          )
          .join("");
      }

      // Accept AI suggestion and start task
      function acceptSuggestion(taskId) {
        const task = tasks.find((t) => t.id === taskId);
        if (task) {
          startPomodoro(task);
        }
      }

      // Start Pomodoro timer
      function startPomodoro(task) {
        currentTask = task;
        pomodoroTimeLeft = 25 * 60; // Reset to 25 minutes
        pomodoroPaused = false;

        document.getElementById("pomodoroTimer").style.display = "flex";
        document.getElementById(
          "timerLabel"
        ).textContent = `Working on: ${task.name}`;
        document.getElementById("pauseBtn").textContent = "‚è∏ Pause";
        document.getElementById("pauseBtn").className = "timer-btn pause";

        clearInterval(pomodoroInterval);
        pomodoroInterval = setInterval(() => {
          if (!pomodoroPaused) {
            pomodoroTimeLeft--;

            const minutes = Math.floor(pomodoroTimeLeft / 60);
            const seconds = pomodoroTimeLeft % 60;
            document.getElementById("timerDisplay").textContent = `${minutes
              .toString()
              .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

            if (pomodoroTimeLeft <= 0) {
              clearInterval(pomodoroInterval);
              handlePomodoroComplete();
            }

            // 20-minute check-in (5 minutes remaining)
            if (pomodoroTimeLeft === 5 * 60) {
              showNotification(
                "Check-in",
                "Are you still working on: " + task.name + "?"
              );
            }
          }
        }, 1000);

        showNotification("Task Started", `Working on: ${task.name}`);
      }

      // Toggle pause/resume
      function togglePauseResume() {
        pomodoroPaused = !pomodoroPaused;
        const btn = document.getElementById("pauseBtn");

        if (pomodoroPaused) {
          btn.textContent = "‚ñ∂ Resume";
          btn.className = "timer-btn resume";
          showNotification(
            "Timer Paused",
            "Take a break. Click Resume when ready."
          );
        } else {
          btn.textContent = "‚è∏ Pause";
          btn.className = "timer-btn pause";
          showNotification("Timer Resumed", "Back to work!");
        }
      }

      // Stop Pomodoro timer
      function stopPomodoro() {
        clearInterval(pomodoroInterval);
        document.getElementById("pomodoroTimer").style.display = "none";

        if (currentTask) {
          // Calculate partial progress
          const minutesWorked = (25 * 60 - pomodoroTimeLeft) / 60;
          const hoursWorked = minutesWorked / 60;
          currentTask.completedHours += hoursWorked;

          stats.focusTime += hoursWorked;
          saveTasks();
          updateStats();
          renderTasks();

          showNotification(
            "Session Stopped",
            `Logged ${minutesWorked.toFixed(0)} minutes of work`
          );
        }

        currentTask = null;
        pomodoroPaused = false;
      }

      // Handle Pomodoro completion
      function handlePomodoroComplete() {
        if (currentTask) {
          currentTask.completedHours += 0.5;

          // Check if task is complete
          if (currentTask.completedHours >= currentTask.totalHours) {
            currentTask.status = "completed";
            stats.completed++;
            showNotification(
              "Task Completed! üéâ",
              `Great job on: ${currentTask.name}`
            );
          } else {
            const remaining =
              currentTask.totalHours - currentTask.completedHours;
            showNotification(
              "Session Complete",
              `${remaining.toFixed(1)} hours remaining for: ${currentTask.name}`
            );
          }

          stats.focusTime += 0.5;
          saveTasks();
          updateStats();
          renderTasks();
          renderCalendar();
        }

        document.getElementById("pomodoroTimer").style.display = "none";
        currentTask = null;
        pomodoroPaused = false;
      }

      // Render tasks list
      function renderTasks() {
        const container = document.getElementById("taskList");
        const activeTasks = tasks.filter((t) => t.status !== "completed");

        if (activeTasks.length === 0) {
          container.innerHTML =
            '<p style="color: #718096;">No active tasks</p>';
          return;
        }

        container.innerHTML = activeTasks
          .map((task) => {
            const progress = (task.completedHours / task.totalHours) * 100;
            const daysLeft = Math.ceil(
              (task.deadline - new Date()) / (1000 * 60 * 60 * 24)
            );

            return `
                    <div class="task-item">
                        <div class="task-header">
                            <span class="task-name">${task.name}</span>
                            <span class="task-deadline" style="color: ${
                              daysLeft <= 1 ? "#e53e3e" : "#718096"
                            }">
                                ${daysLeft} days left
                            </span>
                        </div>
                        <div class="task-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <span style="font-size: 12px; color: #718096;">${Math.round(
                              progress
                            )}%</span>
                        </div>
                        <div style="margin-top: 8px;">
                            <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;" 
                                    onclick='startPomodoro(${JSON.stringify(
                                      task
                                    ).replace(/'/g, "&apos;")})'>
                                Start Session
                            </button>
                        </div>
                    </div>
                `;
          })
          .join("");
      }

      const CALENDAR_DAY_START = 0;
      const CALENDAR_DAY_END = 23;
      const DEFAULT_CALENDAR_VIEW_START = 8;
      const DEFAULT_CALENDAR_VIEW_END = 20;
      const CALENDAR_SLOT_HEIGHT = 60;

      function formatCalendarTime(date) {
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      }

      function formatHourLabel(hour) {
        const temp = new Date();
        temp.setHours(hour, 0, 0, 0);
        return temp.toLocaleTimeString([], { hour: "numeric", hour12: true });
      }

      // Render calendar with deadlines
      function renderCalendar() {
        const container = document.getElementById("weekView");
        if (!container) {
          return;
        }
        const now = new Date();
        const startOfWeek = new Date(currentWeekStart);

        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const hours = Array.from(
          { length: CALENDAR_DAY_END - CALENDAR_DAY_START + 1 },
          (_, i) => CALENDAR_DAY_START + i
        );

        let headerHtml = '<div class="week-view-header"><div></div>';
        days.forEach((day, index) => {
          const date = new Date(startOfWeek);
          date.setDate(startOfWeek.getDate() + index);
          const isToday = date.toDateString() === now.toDateString();
          headerHtml += `<div class="day-header" style="${
            isToday ? "background: #e6fffa; border-color: #0bc5ea;" : ""
          }">
              ${day}<br><small>${date.getDate()}</small>
            </div>`;
        });
        headerHtml += "</div>";

        let bodyHtml = '<div class="week-view-grid">';
        bodyHtml += '<div class="time-column">';
        hours.forEach((hour) => {
          bodyHtml += `<div class="time-slot-label">${formatHourLabel(
            hour
          )}</div>`;
        });
        bodyHtml += "</div>";

        days.forEach((_, dayIndex) => {
          const dayDate = new Date(startOfWeek);
          dayDate.setDate(startOfWeek.getDate() + dayIndex);
          const dayStart = new Date(dayDate);
          dayStart.setHours(CALENDAR_DAY_START, 0, 0, 0);
          const dayEnd = new Date(dayDate);
          dayEnd.setHours(CALENDAR_DAY_END + 1, 0, 0, 0);
          const totalMinutes = (dayEnd - dayStart) / 60000;

          let columnHtml = `<div class="day-column-body" data-day-start="${dayStart.toISOString()}" style="height: ${
            hours.length * CALENDAR_SLOT_HEIGHT
          }px">`;

          hours.forEach((_, hourIndex) => {
            const top = hourIndex * CALENDAR_SLOT_HEIGHT;
            columnHtml += `<div class="hour-divider" style="top: ${top}px"></div>`;
          });

          const dayEvents = schedule
            .filter((item) => {
              if (!item || item.type === "deadline") {
                return false;
              }
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              return eventEnd > dayStart && eventStart < dayEnd;
            })
            .map((item) => {
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              const rawStart = (eventStart - dayStart) / 60000;
              const rawEnd = (eventEnd - dayStart) / 60000;
              const boundedStart = Math.max(0, rawStart);
              const boundedEnd = Math.min(totalMinutes, rawEnd);
              if (boundedEnd <= 0 || boundedStart >= totalMinutes) {
                return null;
              }
              const effectiveEnd = Math.max(boundedEnd, boundedStart + 30);
              return {
                item,
                eventStart,
                eventEnd,
                startMinutes: boundedStart,
                endMinutes: Math.min(totalMinutes, effectiveEnd),
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

          const clusters = [];
          let activeCluster = null;
          dayEvents.forEach((event) => {
            if (!activeCluster || event.startMinutes >= activeCluster.maxEnd) {
              activeCluster = {
                events: [],
                maxEnd: event.endMinutes,
              };
              clusters.push(activeCluster);
            } else {
              activeCluster.maxEnd = Math.max(
                activeCluster.maxEnd,
                event.endMinutes
              );
            }
            activeCluster.events.push(event);
          });

          clusters.forEach((cluster) => {
            const activeEvents = [];
            cluster.columnCount = 0;

            cluster.events.sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

            cluster.events.forEach((event) => {
              for (let i = activeEvents.length - 1; i >= 0; i--) {
                if (activeEvents[i].endMinutes <= event.startMinutes) {
                  activeEvents.splice(i, 1);
                }
              }

              const usedColumns = activeEvents.map((evt) => evt.column);
              let columnIndex = 0;
              while (usedColumns.includes(columnIndex)) {
                columnIndex++;
              }

              event.column = columnIndex;
              activeEvents.push(event);
              cluster.columnCount = Math.max(
                cluster.columnCount,
                columnIndex + 1
              );
            });

            cluster.events.forEach((event) => {
              const columnCount = cluster.columnCount || 1;
              const top = (event.startMinutes / 60) * CALENDAR_SLOT_HEIGHT;
              const height = Math.max(
                ((event.endMinutes - event.startMinutes) / 60) *
                  CALENDAR_SLOT_HEIGHT,
                32
              );

              const columnWidth = Math.round((100 / columnCount) * 1000) / 1000;
              const leftPercent =
                Math.round(columnWidth * event.column * 1000) / 1000;
              const widthStyle =
                columnCount > 1
                  ? `calc(${columnWidth}% - 6px)`
                  : `calc(${columnWidth}% - 2px)`;
              const leftStyle = `${leftPercent}%`;

              const statusClass =
                event.item.status === "completed"
                  ? "completed"
                  : event.item.status === "in-progress"
                  ? "in-progress"
                  : "";
              const isExternal =
                event.item.source === "google" ||
                event.item.type === "external";
              const timeRange = `${formatCalendarTime(
                event.eventStart
              )} - ${formatCalendarTime(event.eventEnd)}`;

              const isDragEligible =
                !isExternal &&
                (!event.item.status || event.item.status === "scheduled");
              const baseClasses = `scheduled-task ${statusClass}${
                isExternal ? " external-event" : ""
              }`;
              const dragAttributes = isDragEligible
                ? ' draggable="true" data-draggable="true"'
                : "";
              const taskIdAttr =
                event.item.taskId !== undefined && event.item.taskId !== null
                  ? ` data-task-id="${event.item.taskId}"`
                  : "";
              const blockAttrs = `${dragAttributes} data-schedule-id="${event.item.id}" data-start-iso="${event.item.start}"${taskIdAttr}`;

              columnHtml += `<div class="${baseClasses}"${blockAttrs} style="top: ${top}px; height: ${height}px; width: ${widthStyle}; left: ${leftStyle};" onclick="openScheduleModal('${
                event.item.id
              }')">
                <span class="event-title">${
                  event.item.taskName || "Scheduled Block"
                }</span>
                <span class="event-time">${timeRange}</span>
              </div>`;
            });
          });

          const dayDeadlines = tasks.filter((task) => {
            const deadline = new Date(task.deadline);
            return (
              deadline >= dayStart &&
              deadline <= dayEnd &&
              task.status !== "completed"
            );
          });

          dayDeadlines.forEach((task) => {
            const deadlineDate = new Date(task.deadline);
            const minutesFromStart = (deadlineDate - dayStart) / 60000;
            const top = Math.max(
              0,
              (minutesFromStart / 60) * CALENDAR_SLOT_HEIGHT - 12
            );
            columnHtml += `<div class="deadline-flag" style="top: ${top}px;">
                <span>üìç</span>
                <span>${task.name}</span>
              </div>`;
          });

          columnHtml += "</div>";
          bodyHtml += columnHtml;
        });

        bodyHtml += "</div>";

        const scrollWrapper = `<div class="calendar-scroll" id="calendarScroll">${bodyHtml}</div>`;
        container.innerHTML = headerHtml + scrollWrapper;

        applyCalendarScrollFocus();
        enableCalendarDragAndDrop();

        const weekEnd = new Date(startOfWeek);
        weekEnd.setDate(startOfWeek.getDate() + 6);
        document.getElementById(
          "currentWeek"
        ).textContent = `${startOfWeek.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}`;
      }

      // Drag-and-drop interactions for calendar focus blocks
      function enableCalendarDragAndDrop() {
        const draggableBlocks = document.querySelectorAll(
          '.scheduled-task[data-draggable="true"]'
        );
        draggableBlocks.forEach((block) => {
          block.addEventListener("dragstart", handleBlockDragStart);
          block.addEventListener("dragend", handleBlockDragEnd);
        });

        const columns = document.querySelectorAll(".day-column-body");
        columns.forEach((column) => {
          column.addEventListener("dragover", handleCalendarDragOver);
          column.addEventListener("dragleave", handleCalendarDragLeave);
          column.addEventListener("drop", handleCalendarDrop);
        });
      }

      function handleBlockDragStart(event) {
        const target = event.currentTarget;
        const scheduleId = target.dataset.scheduleId;
        if (!scheduleId) {
          event.preventDefault();
          return;
        }

        draggedScheduleId = scheduleId;
        target.classList.add("dragging");
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", scheduleId);
        }
      }

      function handleBlockDragEnd(event) {
        event.currentTarget.classList.remove("dragging");
        clearCalendarDragState();
        draggedScheduleId = null;
      }

      function handleCalendarDragOver(event) {
        if (!draggedScheduleId) {
          return;
        }
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = "move";
        }
        event.currentTarget.classList.add("drag-over");
      }

      function handleCalendarDragLeave(event) {
        event.currentTarget.classList.remove("drag-over");
      }

      function handleCalendarDrop(event) {
        if (!draggedScheduleId) {
          return;
        }
        event.preventDefault();

        const column = event.currentTarget;
        column.classList.remove("drag-over");
        const dayStartIso = column.dataset.dayStart;
        if (!dayStartIso) {
          resetDragState(true);
          return;
        }

        const dayStart = new Date(dayStartIso);
        if (Number.isNaN(dayStart.getTime())) {
          resetDragState(true);
          return;
        }

        const scheduleItem = schedule.find(
          (item) => String(item.id) === String(draggedScheduleId)
        );

        if (
          !scheduleItem ||
          scheduleItem.source === "google" ||
          scheduleItem.type === "external"
        ) {
          resetDragState(true);
          return;
        }

        const rect = column.getBoundingClientRect();
        const relativeY = event.clientY - rect.top;
        const clampedY = Math.max(0, Math.min(relativeY, rect.height));
        const halfHourHeight = CALENDAR_SLOT_HEIGHT / 2;
        const slotIndex = Math.floor(clampedY / halfHourHeight);
        const minutesFromStart = slotIndex * 30;

        const newStart = new Date(
          dayStart.getTime() + minutesFromStart * 60000
        );
        newStart.setSeconds(0, 0);

        const currentStart = new Date(scheduleItem.start);
        const currentEnd = scheduleItem.end
          ? new Date(scheduleItem.end)
          : new Date(currentStart.getTime() + FOCUS_SLOT_MS);
        const durationMs = Math.max(
          currentEnd.getTime() - currentStart.getTime(),
          FOCUS_SLOT_MS
        );
        const newEnd = new Date(newStart.getTime() + durationMs);

        const relatedTask = scheduleItem.taskId
          ? tasks.find(
              (task) => String(task.id) === String(scheduleItem.taskId)
            )
          : null;

        if (relatedTask && relatedTask.deadline) {
          const deadlineDate = new Date(relatedTask.deadline);
          if (!Number.isNaN(deadlineDate.getTime())) {
            const deadlineEnd = new Date(deadlineDate);
            deadlineEnd.setHours(23, 59, 59, 999);
            if (newEnd.getTime() > deadlineEnd.getTime()) {
              showDeadlineErrorModal();
              resetDragState(true);
              return;
            }
          }
        }

        if (hasScheduleConflict(newStart, newEnd, scheduleItem.id)) {
          showNotification(
            "Slot Occupied",
            "That time already contains an event. Try a different slot."
          );
          resetDragState(true);
          return;
        }

        scheduleItem.start = newStart.toISOString();
        scheduleItem.end = newEnd.toISOString();

        clearCalendarDragState();
        draggedScheduleId = null;
        sortScheduleEntries();
        saveSchedule({ enforce: false });
        renderCalendar();
      }

      function clearCalendarDragState() {
        document
          .querySelectorAll(".day-column-body.drag-over")
          .forEach((column) => column.classList.remove("drag-over"));
      }

      function resetDragState(shouldRerender = false) {
        clearCalendarDragState();
        document
          .querySelectorAll(".scheduled-task.dragging")
          .forEach((block) => block.classList.remove("dragging"));
        draggedScheduleId = null;
        if (shouldRerender) {
          renderCalendar();
        }
      }

      function changeWeek(offset) {
        currentWeekStart.setDate(currentWeekStart.getDate() + offset * 7);
        currentWeekStart = getStartOfWeek(currentWeekStart);
        renderCalendar();
        if (googleAccountAuthenticated) {
          const eventsContainer = document.getElementById("calendarEvents");
          if (eventsContainer) {
            eventsContainer.innerHTML = "<p>Loading events...</p>";
          }
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) =>
              console.error("Failed to refresh calendar events", error)
            );
        }
      }

      // Handle click on scheduled item
      function handleScheduleClick(scheduleId) {
        openScheduleModal(String(scheduleId));
      }

      function updateGoogleAuthUI() {
        const authButton = document.getElementById("googleAuthButton");
        const authStatus = document.getElementById("authStatus");
        const refreshBtn = document.getElementById("refreshEventsBtn");
        const eventsContainer = document.getElementById("calendarEvents");
        const content = document.getElementById("googleCalContent");

        if (authButton) {
          if (googleAccountAuthenticated) {
            authButton.textContent = "Logout Google";
            authButton.onclick = logoutGoogle;
          } else {
            authButton.textContent = "Connect Google Calendar";
            authButton.onclick = initiateGoogleAuth;
          }
        }

        if (authStatus) {
          if (googleAccountAuthenticated) {
            authStatus.textContent = "Authenticated";
            authStatus.classList.add("success");
            authStatus.classList.remove("warning");
          } else {
            authStatus.textContent = "Not Connected";
            authStatus.classList.remove("success");
            authStatus.classList.add("warning");
          }
        }

        if (refreshBtn) {
          refreshBtn.style.display = googleAccountAuthenticated
            ? "inline-flex"
            : "none";
        }

        if (content) {
          if (!googleAccountAuthenticated) {
            setGoogleCalendarExpanded(false);
          } else if (localStorage.getItem(GOOGLE_CAL_STATE_KEY) === null) {
            setGoogleCalendarExpanded(true);
          }
        }

        if (eventsContainer) {
          if (googleAccountAuthenticated) {
            if (!eventsContainer.dataset.loadedOnce) {
              eventsContainer.innerHTML = "<p>Loading events...</p>";
            }
          } else {
            delete eventsContainer.dataset.loadedOnce;
            eventsContainer.innerHTML =
              '<p style="color: #718096">Connect from the top-right button to sync your Google Calendar.</p>';
          }
        }
      }

      function logoutGoogle() {
        fetch("/logout", { method: "POST" })
          .then(() => {
            googleAccountAuthenticated = false;
            calendarApiLoaded = false;
            if (typeof gapi !== "undefined" && gapi.client) {
              gapi.client.setToken(null);
            }
            schedule = schedule.filter(
              (item) => item.source !== "google" && item.type !== "external"
            );
            saveSchedule();
            renderCalendar();
            updateGoogleAuthUI();
            window.location.reload();
          })
          .catch((error) => {
            console.error("Failed to logout from Google", error);
            showNotification(
              "Logout Failed",
              "Could not disconnect Google right now. Please try again."
            );
          });
      }

      function refreshGoogleEvents() {
        if (!googleAccountAuthenticated) {
          showNotification(
            "Connect Google",
            "Link your Google Calendar from the top-right button first."
          );
          return;
        }

        const eventsContainer = document.getElementById("calendarEvents");
        if (eventsContainer) {
          eventsContainer.innerHTML = "<p>Refreshing events...</p>";
        }

        ensureCalendarApiLoaded()
          .then(() => loadCalendarEvents(currentWeekStart))
          .catch((error) => {
            console.error("Failed to refresh Google events", error);
            showNotification(
              "Refresh Failed",
              "Unable to refresh Google Calendar events right now."
            );
          });
      }

      function openScheduleModal(scheduleId) {
        const modal = document.getElementById("eventModal");
        if (!modal) {
          return;
        }

        const item = schedule.find(
          (entry) => String(entry.id) === String(scheduleId)
        );
        if (!item) {
          return;
        }

        activeScheduleId = item.id;

        const start = new Date(item.start);
        const end = item.end
          ? new Date(item.end)
          : new Date(start.getTime() + 30 * 60 * 1000);

        document.getElementById("modalTitle").textContent =
          item.taskName || "Scheduled Block";
        document.getElementById(
          "modalTime"
        ).textContent = `${start.toLocaleString()} - ${end.toLocaleTimeString(
          [],
          {
            hour: "2-digit",
            minute: "2-digit",
          }
        )}`;

        document.getElementById("modalSource").textContent =
          item.source === "google" || item.type === "external"
            ? "Google Calendar"
            : "FocusFlow";
        document.getElementById("modalStatus").textContent = (
          item.status || "scheduled"
        ).replace(/-/g, " ");
        document.getElementById("modalDuration").textContent = formatDuration(
          end.getTime() - start.getTime()
        );

        const locationRow = document.getElementById("modalLocationRow");
        if (item.location) {
          locationRow.style.display = "flex";
          document.getElementById("modalLocation").textContent = item.location;
        } else {
          locationRow.style.display = "none";
        }

        if (item.source === "google" || item.type === "external") {
          document.getElementById("modalDescription").textContent =
            "Managed via Google Calendar. Hide it here or update it directly in Google.";
          document.getElementById("modalStartBtn").style.display = "none";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Hide This Event";
        } else {
          const relatedTask = tasks.find((t) => t.id === item.taskId);
          const priorityInfo =
            relatedTask && typeof relatedTask.priority === "number"
              ? ` Priority ${relatedTask.priority}/10.`
              : "";
          const description = relatedTask
            ? `Focus block for "${relatedTask.name}".${priorityInfo}`
            : "Focus block scheduled via AI.";
          document.getElementById("modalDescription").textContent = description;
          document.getElementById("modalStartBtn").style.display =
            "inline-flex";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Delete Block";
        }

        modal.classList.add("show");
      }

      function closeEventModal() {
        const modal = document.getElementById("eventModal");
        if (modal) {
          modal.classList.remove("show");
        }
        activeScheduleId = null;
      }

      function handleModalOverlayClick(event) {
        if (event.target && event.target.id === "eventModal") {
          closeEventModal();
        }
      }

      function startFocusFromModal() {
        if (activeScheduleId === null) {
          return;
        }
        const item = schedule.find(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (!item || !item.taskId) {
          return;
        }
        const task = tasks.find((t) => t.id === item.taskId);
        if (!task) {
          return;
        }

        startPomodoro(task);
        item.status = "in-progress";
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function deleteScheduleItem() {
        if (activeScheduleId === null) {
          return;
        }
        const index = schedule.findIndex(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (index === -1) {
          closeEventModal();
          return;
        }

        const [removed] = schedule.splice(index, 1);
        if (removed && removed.source === "google" && removed.externalId) {
          dismissedGoogleEvents.add(String(removed.externalId));
          saveDismissedGoogleEvents();
        }
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function formatDuration(milliseconds) {
        const totalMinutes = Math.max(1, Math.round(milliseconds / 60000));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0 && minutes > 0) {
          return `${hours}h ${minutes}m`;
        }
        if (hours > 0) {
          return `${hours}h`;
        }
        return `${minutes}m`;
      }

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeEventModal();
        }
      });

      // Google Calendar Integration
      function loadGoogleAPI() {
        if (typeof gapi === "undefined" || !gapi.load) {
          setTimeout(loadGoogleAPI, 100);
          return;
        }
        gapi.load("client:auth2", initGoogleClient);
      }

      function initGoogleClient() {
        gapi.load("client", () => {
          gapi.client
            .init({
              apiKey: GOOGLE_API_KEY,
              discoveryDocs: DISCOVERY_DOCS,
            })
            .then(() => authenticateGapiWithFlaskToken());
        });
      }

      function authenticateGapiWithFlaskToken() {
        if (!gapi.client || !gapi.client.setToken) {
          setTimeout(authenticateGapiWithFlaskToken, 500);
          return;
        }
        fetch("/get_gapi_token")
          .then((r) => r.json())
          .then((tokenData) => {
            gapi.client.setToken({ access_token: tokenData.access_token });
            ensureCalendarApiLoaded()
              .then(() => updateSigninStatus(true))
              .catch((error) => {
                console.error("Failed to load Google Calendar API", error);
              });
          });
      }

      function updateSigninStatus(isSignedIn) {
        if (isSignedIn && gapi.client.getToken()) {
          googleAccountAuthenticated = true;
          updateGoogleAuthUI();
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) => {
              console.error("Google Calendar API not ready", error);
            });
        }
      }

      function ensureCalendarApiLoaded() {
        if (calendarApiLoaded) {
          return Promise.resolve();
        }
        if (!gapi.client || !gapi.client.load) {
          return Promise.reject(new Error("gapi client not ready"));
        }
        return gapi.client.load("calendar", "v3").then(() => {
          calendarApiLoaded = true;
        });
      }

      //function initiateGoogleAuth() {
      //  gapi.auth2.getAuthInstance().signIn();
      //}

      function initiateGoogleAuth() {
        // Use Flask OAuth instead of gapi
        window.location.href = "/auth";
      }

      function loadCalendarEvents(weekStart = currentWeekStart) {
        const startWindow = new Date(weekStart);
        startWindow.setHours(0, 0, 0, 0);
        const endWindow = new Date(weekStart);
        endWindow.setDate(endWindow.getDate() + 7);
        endWindow.setHours(23, 59, 59, 999);
        gapi.client.calendar.events
          .list({
            calendarId: "primary",
            timeMin: startWindow.toISOString(),
            timeMax: endWindow.toISOString(),
            showDeleted: false,
            singleEvents: true,
            maxResults: 250,
            orderBy: "startTime",
          })
          .then((response) => {
            const events = response.result.items;
            displayGoogleEvents(events);
            extractDeadlinesFromEvents(events);
            mergeGoogleEventsIntoSchedule(events);
          });
      }

      function displayGoogleEvents(events) {
        const container = document.getElementById("calendarEvents");
        if (!container) {
          return;
        }
        container.dataset.loadedOnce = "true";
        if (events.length > 0) {
          container.innerHTML = "<h4>Upcoming Google Calendar Events:</h4>";
          events.forEach((event) => {
            const when = event.start.dateTime || event.start.date;
            container.innerHTML += `
                        <div style="padding: 8px; background: #f7fafc; margin: 5px 0; border-radius: 6px;">
                            <strong>${event.summary}</strong><br>
                            <small>${new Date(when).toLocaleString()}</small>
                            ${
                              event.description &&
                              event.description.includes("deadline")
                                ? `<button onclick="importAsTask('${event.summary}', '${when}')" 
                                 style="margin-left: 10px; padding: 2px 8px; background: #667eea; 
                                 color: white; border: none; border-radius: 4px; cursor: pointer;">
                                 Import as Task
                                </button>`
                                : ""
                            }
                        </div>
                    `;
          });
        } else {
          container.innerHTML = "<p>No upcoming events found.</p>";
        }
      }

      function extractDeadlinesFromEvents(events) {
        events.forEach((event) => {
          // Check if event title or description contains deadline keywords
          const deadlineKeywords = [
            "deadline",
            "due",
            "submit",
            "delivery",
            "final",
          ];
          const hasDeadline = deadlineKeywords.some(
            (keyword) =>
              (event.summary &&
                event.summary.toLowerCase().includes(keyword)) ||
              (event.description &&
                event.description.toLowerCase().includes(keyword))
          );

          if (hasDeadline) {
            console.log("Found potential deadline:", event.summary);
            // Auto-suggest as task
            showNotification(
              "Deadline Detected",
              `Found deadline in calendar: "${event.summary}". Click to import.`
            );
          }
        });
      }

      function mergeGoogleEventsIntoSchedule(events) {
        if (!Array.isArray(events)) {
          return;
        }

        const normalizedEvents = events
          .filter((event) => event && event.id && event.start)
          .map((event) => ({ ...event, id: String(event.id) }))
          .filter((event) => !dismissedGoogleEvents.has(event.id));
        const incomingIds = new Set(normalizedEvents.map((event) => event.id));

        schedule = schedule.filter((item) => {
          if (item && item.source === "google" && item.externalId) {
            return incomingIds.has(String(item.externalId));
          }
          return true;
        });

        normalizedEvents.forEach((event) => {
          const alreadySynced = schedule.some(
            (item) =>
              item.source === "google" &&
              String(item.externalId) === String(event.id)
          );
          if (alreadySynced) {
            return;
          }

          const startIso =
            event.start.dateTime ||
            (event.start.date ? `${event.start.date}T09:00:00` : null);
          if (!startIso) {
            return;
          }

          const endIso =
            event.end?.dateTime ||
            (event.end?.date ? `${event.end.date}T17:00:00` : null);

          const startDate = new Date(startIso);
          const endDate = endIso
            ? new Date(endIso)
            : new Date(startDate.getTime() + 60 * 60 * 1000);

          schedule.push({
            id: Date.now() + Math.floor(Math.random() * 1000),
            externalId: event.id,
            source: "google",
            taskId: null,
            taskName: `${event.summary || "Google Event"}`,
            start: startDate.toISOString(),
            end: endDate.toISOString(),
            type: "external",
            status: "scheduled",
            location: event.location || "",
          });
        });

        schedule.sort(
          (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
        );

        saveSchedule();
        renderCalendar();
      }

      function importAsTask(eventName, eventTime) {
        document.getElementById("taskName").value = eventName;
        document.getElementById("deadline").value = new Date(eventTime)
          .toISOString()
          .slice(0, 16);
        showNotification(
          "Task Imported",
          "Deadline imported from Google Calendar. Adjust hours and add task."
        );
      }

      // Show notification
      function showNotification(title, body) {
        const notification = document.getElementById("notification");
        document.getElementById("notificationHeader").textContent = title;
        document.getElementById("notificationBody").textContent = body;
        notification.classList.add("show");

        // Auto-hide after 5 seconds
        setTimeout(() => {
          notification.classList.remove("show");
        }, 5000);

        // Browser notification if permitted
        if (Notification.permission === "granted") {
          new Notification(title, { body, icon: "üéØ" });
        }
      }

      function showDeadlineErrorModal() {
        showErrorModal(
          "Can't place block because the deadline would have passed by then."
        );
      }

      function showErrorModal(message) {
        const modal = document.getElementById("errorModal");
        if (!modal) {
          return;
        }
        const messageNode = document.getElementById("errorModalMessage");
        if (messageNode) {
          messageNode.textContent = message;
        }
        modal.classList.add("show");
      }

      function closeErrorModal() {
        const modal = document.getElementById("errorModal");
        if (modal) {
          modal.classList.remove("show");
        }
      }

      function handleErrorModalOverlayClick(event) {
        if (event.target && event.target.id === "errorModal") {
          closeErrorModal();
        }
      }

      // Handle notification actions
      function handleNotification(action) {
        const notification = document.getElementById("notification");
        notification.classList.remove("show");

        if (action === "accept" && currentTask) {
          // Continue with current task
        } else if (action === "reschedule") {
          // Move to next available slot
          generateAISuggestions();
        } else if (action === "decline") {
          // Track reason (simplified for MVP)
          const reasons = [
            "Too tired",
            "Emergency came up",
            "Need a break",
            "Other priority",
          ];
          const reason = reasons[Math.floor(Math.random() * reasons.length)];
          console.log("Task declined:", reason);
        }
      }

      function startNotificationChecker() {
        runNotificationSweep();
        if (!window.focusflowNotificationInterval) {
          window.focusflowNotificationInterval = setInterval(
            runNotificationSweep,
            60000
          );
        }

        if (!window.focusflowAiInterval) {
          setTimeout(() => {
            runAiInsights();
            window.focusflowAiInterval = setInterval(
              runAiInsights,
              45 * 60 * 1000
            );
          }, 5 * 60 * 1000);
        }
      }

      function runNotificationSweep() {
        const now = new Date();
        checkUpcomingFocusBlocks(now);
        checkDeadlineAlerts(now);
        checkMissedTasks(now);
      }

      function checkUpcomingFocusBlocks(now) {
        const toleranceMs = 60 * 1000;
        schedule.forEach((item) => {
          if (!item || item.type === "deadline") {
            return;
          }
          if (item.status && item.status !== "scheduled") {
            return;
          }
          const startTime = new Date(item.start);
          const diff = now.getTime() - startTime.getTime();
          if (diff >= 0 && diff <= toleranceMs) {
            const key = String(item.id);
            if (!notifiedSlots.has(key)) {
              const label = item.taskName || "Scheduled Block";
              showNotification(
                "Focus Block Starting",
                `"${label}" is starting now. Dive in!`
              );
              notifiedSlots.add(key);
              saveNotifiedSlots();
            }
          }
        });
      }

      function checkDeadlineAlerts(now) {
        const todayKey = now.toISOString().slice(0, 10);
        if (now.getHours() >= 12) {
          return;
        }
        const startOfToday = new Date(now);
        startOfToday.setHours(0, 0, 0, 0);
        const endOfToday = new Date(startOfToday);
        endOfToday.setHours(23, 59, 59, 999);
        const nowTime = now.getTime();
        const minInterval = 5 * 60 * 1000;
        if (
          window.focusflowLastDeadlineCheck &&
          nowTime - window.focusflowLastDeadlineCheck < minInterval
        ) {
          return;
        }
        window.focusflowLastDeadlineCheck = nowTime;
        notifiedDeadlines = new Set(
          Array.from(notifiedDeadlines).filter((key) => key.endsWith(todayKey))
        );
        saveNotifiedDeadlines();
        tasks.forEach((task) => {
          if (!task || task.status === "completed") {
            return;
          }
          const deadlineDate = new Date(task.deadline);
          if (
            Number.isNaN(deadlineDate.getTime()) ||
            deadlineDate < startOfToday ||
            deadlineDate > endOfToday ||
            !isSameDay(deadlineDate, now)
          ) {
            return;
          }
          const key = `${task.id}_${todayKey}`;
          if (!notifiedDeadlines.has(key)) {
            showNotification(
              "Deadline Today",
              `"${task.name}" is due today. Make sure it lands on your schedule.`
            );
            notifiedDeadlines.add(key);
            saveNotifiedDeadlines();
          }
        });
      }

      function checkMissedTasks(now) {
        const todayKey = now.toISOString().slice(0, 10);
        if (lastMissedNotificationDate === todayKey) {
          return;
        }

        const startOfToday = new Date(now);
        startOfToday.setHours(0, 0, 0, 0);
        const startOfYesterday = new Date(startOfToday);
        startOfYesterday.setDate(startOfYesterday.getDate() - 1);
        const endOfYesterday = new Date(startOfToday.getTime() - 1);

        const missed = schedule.filter((item) => {
          if (!item || item.type === "deadline") {
            return false;
          }
          if (item.status && item.status !== "scheduled") {
            return false;
          }
          const startTime = new Date(item.start);
          return startTime >= startOfYesterday && startTime <= endOfYesterday;
        });

        if (missed.length > 0) {
          const message =
            missed.length === 1
              ? `You missed "${missed[0].taskName}" yesterday. Consider rescheduling it.`
              : `You missed ${missed.length} focus blocks yesterday. Review and reschedule them.`;
          showNotification(
            missed.length === 1 ? "Missed Focus Block" : "Missed Focus Blocks",
            message
          );
        }

        lastMissedNotificationDate = todayKey;
        localStorage.setItem(
          storageKey("lastMissedNotificationDate"),
          lastMissedNotificationDate
        );
      }

      function runAiInsights() {
        if (Date.now() - lastAiNotification < 15 * 60 * 1000) {
          return;
        }

        const activeTasks = tasks
          .filter((task) => task && task.status !== "completed")
          .map((task) => ({
            name: task.name,
            deadline: (() => {
              const parsed = new Date(task.deadline);
              return Number.isNaN(parsed.getTime())
                ? null
                : parsed.toISOString();
            })(),
            priority: task.priority || null,
            remainingHours: Math.max(
              0,
              (task.totalHours || 0) - (task.completedHours || 0)
            ),
          }));

        const upcomingBlocks = schedule
          .filter((item) => item && item.type !== "deadline")
          .map((item) => ({
            name: item.taskName,
            start: (() => {
              const parsed = new Date(item.start);
              return Number.isNaN(parsed.getTime())
                ? null
                : parsed.toISOString();
            })(),
            end: (() => {
              if (!item.end) {
                return null;
              }
              const parsedEnd = new Date(item.end);
              return Number.isNaN(parsedEnd.getTime())
                ? null
                : parsedEnd.toISOString();
            })(),
            source: item.source || "focusflow",
            status: item.status || "scheduled",
          }));

        if (activeTasks.length === 0 && upcomingBlocks.length === 0) {
          return;
        }

        lastAiNotification = Date.now();
        localStorage.setItem(
          storageKey("lastAiNotification"),
          String(lastAiNotification)
        );

        fetch("/ai_insights", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            timestamp: new Date().toISOString(),
            tasks: activeTasks.slice(0, 20),
            schedule: upcomingBlocks.slice(0, 40),
          }),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("AI insights unavailable");
            }
            return response.json();
          })
          .then((data) => {
            if (data && data.message) {
              showNotification("AI Coach", data.message.trim());
            }
          })
          .catch((error) => {
            console.error("Failed to fetch AI insight", error);
          });
      }

      function isSameDay(a, b) {
        return (
          a.getFullYear() === b.getFullYear() &&
          a.getMonth() === b.getMonth() &&
          a.getDate() === b.getDate()
        );
      }

      function calculateStreak() {
        const completedDays = new Set();
        schedule.forEach((item) => {
          if (item.status !== "completed") return;
          const reference = item.end || item.start;
          if (!reference) return;
          const completedDate = new Date(reference);
          if (Number.isNaN(completedDate.getTime())) return;
          completedDays.add(completedDate.toDateString());
        });

        let streak = 0;
        const cursor = new Date();
        while (completedDays.has(cursor.toDateString())) {
          streak += 1;
          cursor.setDate(cursor.getDate() - 1);
        }
        return streak;
      }

      function updateStats() {
        const completedTasks = tasks.filter(
          (task) => task.status === "completed"
        ).length;
        const totalHours = schedule.reduce((acc, item) => {
          if (!item.start || !item.end) {
            return acc;
          }
          const start = new Date(item.start);
          const end = new Date(item.end);
          if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
            return acc;
          }
          const duration = Math.max((end - start) / (1000 * 60 * 60), 0);
          return item.status === "completed" ? acc + duration : acc;
        }, 0);

        stats = {
          completed: completedTasks,
          focusTime: Number(totalHours.toFixed(2)),
          streak: calculateStreak(),
          totalTasks: tasks.length,
        };

        saveStorage("stats", stats);

        document.getElementById("tasksCompleted").textContent = stats.completed;
        document.getElementById(
          "focusTime"
        ).textContent = `${stats.focusTime.toFixed(1)}h`;
        document.getElementById("streakDays").textContent = stats.streak;

        const completionRate =
          stats.totalTasks > 0
            ? Math.round((stats.completed / stats.totalTasks) * 100)
            : 0;
        document.getElementById(
          "completionRate"
        ).textContent = `${completionRate}%`;
      }

      // Save functions
      function saveTasks() {
        saveStorage("tasks", tasks);
      }

      function saveSchedule(options = {}) {
        if (options.enforce !== false) {
          resolveFocusConflicts({ save: false });
          sortScheduleEntries();
        }
        saveStorage("schedule", schedule);
        pruneNotificationCaches();
      }

      function saveDismissedGoogleEvents() {
        saveStorage("dismissedGoogleEvents", Array.from(dismissedGoogleEvents));
      }

      function saveNotifiedSlots() {
        saveStorage("notifiedSlots", Array.from(notifiedSlots));
      }

      function saveNotifiedDeadlines() {
        saveStorage("notifiedDeadlines", Array.from(notifiedDeadlines));
      }

      function pruneNotificationCaches() {
        const validIds = new Set(schedule.map((item) => String(item.id)));
        notifiedSlots = new Set(
          Array.from(notifiedSlots).filter((id) => validIds.has(String(id)))
        );
        saveNotifiedSlots();
      }

      // // Request notification permission
      // if ("Notification" in window && Notification.permission === "default") {
      //   // Notification.requestPermission();
      // }

      function syncNotificationButton() {
        const button = document.getElementById("notificationPermissionButton");
        if (!button) return;

        if (!("Notification" in window)) {
          button.textContent = "Notifications Unavailable";
          button.classList.remove(
            "notification-active",
            "notification-blocked"
          );
          button.classList.add("notification-blocked");
          button.disabled = true;
          button.title = "Your browser does not support notifications.";
          return;
        }

        button.disabled = false;
        button.classList.remove("notification-active", "notification-blocked");

        const permission = Notification.permission;
        if (permission === "granted") {
          button.textContent = "Notifications Enabled";
          button.classList.add("notification-active");
          button.title =
            "Notifications are enabled. Click if you need to re-check settings.";
        } else if (permission === "denied") {
          button.textContent = "Notifications Blocked";
          button.classList.add("notification-blocked");
          button.title =
            "Notifications are blocked. Update your browser settings, then click to try again.";
        } else {
          button.textContent = "Enable Notifications";
          button.title =
            "Allow browser notifications to receive focus reminders.";
        }
      }

      function requestNotificationPermission() {
        if (!("Notification" in window)) {
          alert("Your browser does not support notifications.");
          syncNotificationButton();
          return;
        }

        if (Notification.permission === "granted") {
          alert("Notifications are already enabled.");
          syncNotificationButton();
          return;
        }

        Notification.requestPermission()
          .then((permission) => {
            if (permission === "granted") {
              alert(
                "Notifications enabled! We'll nudge you when new focus blocks start."
              );
            } else if (permission === "denied") {
              alert(
                "Notifications remain blocked. Please enable them in your browser settings."
              );
            }
            syncNotificationButton();
          })
          .catch((error) => {
            console.error("Notification permission request failed:", error);
            alert(
              "We couldn't update your notification settings. Please try again later."
            );
            syncNotificationButton();
          });
      }

      document.addEventListener("DOMContentLoaded", () => {
        domReady = true;
        window.domReady = true;
        if (window.gapiLoaded) {
          init();
        }
        syncNotificationButton();
      });

      window.addEventListener("focus", syncNotificationButton);
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          syncNotificationButton();
        }
      });

      setTimeout(() => {
        if (!window.gapiLoaded && typeof gapi !== "undefined") {
          window.gapiLoaded = true;
          if (domReady) {
            init();
          }
        }
      }, 3000);
      console.log("page ready ‚Äì gapi loaded:", !!window.gapi);
    </script>
  </body>
</html>
