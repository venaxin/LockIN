<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LockIN - AI Task Scheduler</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Mulish:wght@200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://apis.google.com/js/api.js"
      onload="window.gapiLoaded = true; if (window.domReady) init();"
      async
      defer
    ></script>
    <script>
      window.__gapiLoadCount = 0;
      const gapiCheck = setInterval(() => {
        window.__gapiLoadCount++;
        if (typeof gapi !== "undefined") {
          clearInterval(gapiCheck);
          console.log("gapi loaded after", window.__gapiLoadCount * 100, "ms");
        } else if (window.__gapiLoadCount > 50) {
          clearInterval(gapiCheck);
          console.error("gapi failed to load after 5s");
        }
      }, 100);
    </script>

    <meta
      http-equiv="Content-Security-Policy"
      content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://apis.google.com https://accounts.google.com https://www.gstatic.com https://ssl.gstatic.com https://content.googleapis.com https://*.gstatic.com;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://accounts.google.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://www.googleapis.com https://accounts.google.com https://content.googleapis.com https://www.gstatic.com https://oauth2.googleapis.com;
  frame-src 'self' https://accounts.google.com https://content.googleapis.com https://www.google.com https://www.gstatic.com;
  img-src 'self' data: https: blob:;
  worker-src 'self' blob:;
"
    />
    <style>
      .sidebar {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 22px;
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.15);
        display: flex;
        flex-direction: column;
        flex: 1 1 auto;
        min-height: 0;
        overflow-y: auto;
        gap: 20px;
      }

      .sidebar-tabs {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
      }

      .sidebar-tab-button {
        border: none;
        border-radius: 12px;
        padding: 10px 12px;
        font-weight: 600;
        font-size: 0.9rem;
        background: rgba(226, 232, 240, 0.6);
        color: #334155;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.2s ease, color 0.2s ease;
      }

      .sidebar-tab-button:hover,
      .sidebar-tab-button:focus {
        background: rgba(148, 163, 184, 0.35);
        transform: translateY(-1px);
      }

      .sidebar-tab-button.active {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
        box-shadow: 0 10px 18px rgba(102, 126, 234, 0.25);
      }

      .sidebar-panel-container {
        flex: 1;
        margin-top: 18px;
        position: relative;
      }

      .sidebar-tab-panel {
        display: none;
        flex-direction: column;
        gap: 20px;
      }

      .sidebar-tab-panel.active {
        display: flex;
      }

      .sidebar::-webkit-scrollbar {
        width: 6px;
      }

      .sidebar::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.35);
        border-radius: 999px;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Mulish", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        margin: 0;
        overflow: hidden;
      }

      .app-shell {
        display: flex;
        height: 100vh;
        width: 100%;
        padding: 20px;
        gap: 20px;
      }

      .app-sidebar-wrapper {
        display: flex;
        flex-direction: column;
        width: 340px;
        min-width: 320px;
        gap: 16px;
        height: 100%;
      }

      .mini-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
        border-radius: 18px;
        background: rgba(15, 23, 42, 0.25);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(148, 163, 184, 0.3);
      }

      .mini-logo {
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 16px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.15);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.4);
      }

      .mini-logo img {
        width: 100px;
        height: 30px;
        object-fit: contain;
      }

      .burger-button {
        width: 48px;
        height: 48px;
        border-radius: 16px;
        border: none;
        background: rgba(255, 255, 255, 0.18);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 6px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .burger-button:hover {
        transform: translateY(-2px);
        background: rgba(255, 255, 255, 0.28);
      }

      .burger-line {
        width: 22px;
        height: 3px;
        border-radius: 999px;
        background: #ffffff;
      }

      .sidebar-brand {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding-bottom: 18px;
        border-bottom: 1px solid rgba(226, 232, 240, 0.7);
      }

      .brand-title {
        font-weight: 800;
        font-size: 1.4rem;
        color: #1a202c;
        letter-spacing: 0.02em;
      }

      .brand-tagline {
        color: #4a5568;
        font-weight: 600;
        font-size: 0.9rem;
      }

      .app-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: rgba(255, 255, 255, 0.96);
        box-shadow: 0 18px 35px rgba(15, 23, 42, 0.15);
        border-radius: 24px;
        padding: 32px;
        min-width: 0;
        min-height: 0;
        gap: 24px;
        overflow: hidden;
      }

      .app-main > section {
        flex: 0 0 auto;
        overflow: auto;
        background: rgba(255, 255, 255, 0.92);
        border-radius: 22px;
        padding: 28px;
        box-shadow: inset 0 0 0 1px rgba(226, 232, 240, 0.75);
        display: flex;
        flex-direction: column;
        min-height: 0;
      }

      .app-main > section + section {
        margin-top: 0;
      }

      .app-main > .calendar-section,
      .app-main > .procrastination-panel,
      .app-main > .google-cal-section {
        flex: 1;
      }

      .menu-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.6);
        backdrop-filter: blur(14px);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease;
        z-index: 120;
      }

      .menu-overlay.active {
        opacity: 1;
        pointer-events: auto;
      }

      .menu-overlay-inner {
        width: min(320px, 85vw);
        background: rgba(15, 23, 42, 0.92);
        border-radius: 20px;
        padding: 28px 26px;
        box-shadow: 0 25px 45px rgba(15, 23, 42, 0.35);
        color: #f8fafc;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .menu-overlay-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }

      .menu-title {
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 0.85rem;
      }

      .overlay-close {
        background: none;
        border: none;
        color: inherit;
        font-size: 1.8rem;
        cursor: pointer;
        line-height: 1;
      }

      .menu-nav {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .menu-link {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 14px;
        border-radius: 14px;
        text-decoration: none;
        color: inherit;
        background: rgba(255, 255, 255, 0.06);
        font-weight: 600;
        transition: transform 0.2s ease, background 0.2s ease;
      }

      .menu-link:hover,
      .menu-link:focus,
      .menu-link.active {
        background: rgba(255, 255, 255, 0.14);
        transform: translateX(4px);
      }

      .calendar-header-left {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
      }

      .calendar-google-btn {
        padding: 8px 18px;
        font-size: 0.9em;
        border-width: 2px;
        min-width: 180px;
        justify-content: center;
      }

      .productivity-meter {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        padding: 10px 16px;
        border-radius: 14px;
        background: #ffffff;
        border: 2px solid transparent;
        box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
        min-width: 220px;
        width: 100%;
        transition: border-color 0.2s ease, background 0.2s ease;
      }

      .productivity-bot {
        width: 44px;
        height: 44px;
        flex-shrink: 0;
      }

      .productivity-bot img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .productivity-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .productivity-label {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: #4a5568;
      }

      .productivity-score {
        font-size: 18px;
        font-weight: 700;
        color: #1a202c;
      }

      .productivity-message {
        font-size: 12px;
        color: #4a5568;
        font-weight: 500;
        font-style: italic;
      }

      .productivity-bar {
        width: 100%;
        height: 6px;
        background: #edf2f7;
        border-radius: 999px;
        overflow: hidden;
        margin-top: 4px;
      }

      .productivity-bar-fill {
        height: 100%;
        width: 0;
        background: #48bb78;
        transition: width 0.3s ease;
      }

      .productivity-meter.state-low {
        border-color: #fc8181;
        background: #fff5f5;
      }

      .productivity-meter.state-low .productivity-score {
        color: #c53030;
      }

      .productivity-meter.state-low .productivity-bar-fill {
        background: #e53e3e;
      }

      .productivity-meter.state-low .productivity-message {
        color: #c53030;
      }

      .productivity-meter.state-mid {
        border-color: #f6e05e;
        background: #fffff0;
      }

      .productivity-meter.state-mid .productivity-score {
        color: #975a16;
      }

      .productivity-meter.state-mid .productivity-bar-fill {
        background: linear-gradient(90deg, #f6ad55, #68d391);
      }

      .productivity-meter.state-mid .productivity-message {
        color: #975a16;
      }

      .productivity-meter.state-high {
        border-color: #68d391;
        background: #f0fff4;
      }

      .productivity-meter.state-high .productivity-score {
        color: #276749;
      }

      .productivity-meter.state-high .productivity-bar-fill {
        background: #38a169;
      }

      .productivity-meter.state-high .productivity-message {
        color: #276749;
      }

      .productivity-meter.state-none {
        border-color: #cbd5f5;
        background: #f7fafc;
      }

      .productivity-meter.state-none .productivity-score,
      .productivity-meter.state-none .productivity-message {
        color: #4a5568;
      }

      .productivity-meter.state-none .productivity-bar-fill {
        background: #a0aec0;
      }

      .productivity-mini-top {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 10px;
      }

      .productivity-mini-body {
        display: flex;
        align-items: center;
        gap: 14px;
      }

      .productivity-bubble {
        flex: 1;
        font-size: 13px;
        line-height: 1.5;
        color: #475569;
        font-weight: 600;
      }

      .calendar-section {
        display: flex;
        flex-direction: column;
        gap: 24px;
        height: 100%;
      }

      .add-task-form {
        margin-bottom: 30px;
      }

      .floating-task-entry {
        position: fixed;
        bottom: 26px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }

      .floating-task-button {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
        font-size: 34px;
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 14px 30px rgba(76, 81, 191, 0.35);
        cursor: pointer;
        transition: transform 0.2s ease, opacity 0.2s ease, box-shadow 0.2s ease;
        line-height: 1;
      }

      .floating-task-button:hover {
        transform: translateY(-3px) scale(1.03);
        box-shadow: 0 18px 38px rgba(76, 81, 191, 0.45);
      }

      .floating-task-entry.open .floating-task-button {
        opacity: 0;
        transform: scale(0.7);
        pointer-events: none;
        box-shadow: none;
      }

      .floating-task-panel {
        width: 320px;
        max-width: 90vw;
        background: #ffffff;
        border-radius: 18px;
        border: 2px solid #e2e8f0;
        box-shadow: 0 25px 45px rgba(15, 23, 42, 0.25);
        padding: 22px 20px 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        opacity: 0;
        pointer-events: none;
        visibility: hidden;
        transform: translateY(12px) scale(0.97);
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .floating-task-entry.open .floating-task-panel {
        opacity: 1;
        pointer-events: auto;
        visibility: visible;
        transform: translateY(0) scale(1);
      }

      .floating-task-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
      }

      .floating-task-header h3 {
        color: #2d3748;
        font-size: 1.1em;
        font-weight: 700;
      }

      .floating-task-close {
        background: none;
        border: none;
        color: #4a5568;
        font-size: 1.6em;
        line-height: 1;
        cursor: pointer;
        padding: 0;
      }

      .floating-task-close:hover {
        color: #2d3748;
      }

      .floating-task-form {
        width: 100%;
      }

      .floating-task-actions {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }

      .floating-task-actions .btn {
        width: auto;
        flex: 1;
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        color: #4a5568;
        font-weight: 500;
      }

      input,
      select {
        width: 100%;
        padding: 10px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #4a5568;
      }

      .task-list {
        margin-top: 30px;
      }

      .task-item {
        background: #f7fafc;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
        border-left: 4px solid #667eea;
      }

      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .task-name {
        font-weight: 600;
        color: #2d3748;
      }

      .task-deadline {
        font-size: 12px;
        color: #718096;
      }

      .task-progress {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }

      .progress-bar {
        flex: 1;
        height: 8px;
        background: #e2e8f0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
        transition: width 0.3s;
      }

      .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        margin-bottom: 0;
      }

      .calendar-nav {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .nav-btn {
        background: #edf2f7;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        color: #4a5568;
        transition: background 0.2s, transform 0.2s;
      }

      .nav-btn:hover {
        background: #cbd5f5;
        transform: translateY(-1px);
      }

      .nav-btn:active {
        transform: scale(0.95);
      }

      .week-view {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex: 1;
        min-height: 0;
      }

      .calendar-scroll {
        max-height: 720px;
        overflow-y: auto;
        padding-right: 6px;
        scroll-behavior: smooth;
        flex: 1;
        min-height: 0;
      }

      .calendar-scroll::-webkit-scrollbar {
        width: 8px;
      }

      .calendar-scroll::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.35);
        border-radius: 4px;
      }

      .week-view-header,
      .week-view-grid {
        display: grid;
        grid-template-columns: 80px repeat(7, 1fr);
        gap: 10px;
      }

      .time-slot-label {
        color: #718096;
        font-size: 12px;
        text-align: right;
        padding-right: 10px;
        height: 60px;
        display: flex;
        align-items: flex-start;
        justify-content: flex-end;
      }

      .time-column {
        display: flex;
        flex-direction: column;
      }

      .day-header {
        font-weight: 600;
        color: #2d3748;
        text-align: center;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .day-column-body {
        position: relative;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #ffffff;
        overflow: visible;
        padding: 0 6px;
      }

      .hour-divider {
        position: absolute;
        left: 0;
        right: 0;
        height: 0;
        border-top: 1px solid #f0f0f0;
      }

      .current-time-line {
        position: absolute;
        left: 0;
        right: 0;
        height: 2px;
        background: #f6e05e;
        box-shadow: 0 0 6px rgba(246, 224, 94, 0.6);
        z-index: 15;
      }

      .current-time-line::before {
        content: "";
        position: absolute;
        left: -6px;
        top: -4px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #d69e2e;
        box-shadow: 0 0 8px rgba(214, 158, 46, 0.7);
      }

      .current-time-label {
        position: absolute;
        right: 4px;
        top: -12px;
        background: #fefcbf;
        color: #744210;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 999px;
        box-shadow: 0 2px 6px rgba(148, 88, 10, 0.2);
        font-weight: 600;
      }

      .scheduled-task {
        position: absolute;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 6px;
        border-radius: 6px;
        font-size: 11px;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow: hidden;
        line-height: 1.2;
      }

      .scheduled-task:hover {
        transform: scale(1.02);
      }

      .scheduled-task[data-draggable="true"] {
        cursor: grab;
      }

      .scheduled-task.dragging {
        opacity: 0.85;
        cursor: grabbing;
      }

      .scheduled-task.in-progress {
        background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
      }

      .scheduled-task.completed {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }

      .scheduled-task.missed {
        background: linear-gradient(135deg, #fc8181 0%, #e53e3e 100%);
        box-shadow: 0 0 12px rgba(229, 62, 62, 0.45);
      }

      .scheduled-task.external-event {
        background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
      }

      .scheduled-task .event-title {
        font-weight: 600;
        font-size: 12px;
      }

      .scheduled-task .event-time {
        font-size: 11px;
        opacity: 0.85;
      }

      .day-column-body.drag-over {
        outline: 2px dashed #0bc5ea;
        outline-offset: -4px;
      }

      .deadline-flag {
        position: absolute;
        right: 12px;
        background: #e53e3e;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        box-shadow: 0 2px 4px rgba(229, 62, 62, 0.2);
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        min-width: 300px;
        animation: slideIn 0.3s ease;
        display: none;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      .notification.show {
        display: block;
      }

      .notification-header {
        font-weight: 600;
        margin-bottom: 10px;
        color: #2d3748;
      }

      .notification-body {
        color: #4a5568;
        margin-bottom: 15px;
      }

      .notification-actions {
        display: flex;
        gap: 10px;
      }

      .notification-btn {
        flex: 1;
        padding: 8px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
      }

      .notification-btn.accept {
        background: #48bb78;
        color: white;
      }

      .notification-btn.decline {
        background: #fc8181;
        color: white;
      }

      .notification-btn.reschedule {
        background: #f6d365;
        color: #2d3748;
      }

      .stats-panel {
        background: transparent;
        margin-top: 0;
        box-shadow: none;
      }

      .procrastination-panel {
        margin-top: 0;
        display: grid;
        gap: 18px;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }

      .insight-card {
        background: #ffffff;
        border-radius: 16px;
        padding: 18px 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        border: 1px solid rgba(226, 232, 240, 0.8);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .insight-card-wide {
        grid-column: 1 / -1;
      }

      .insight-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .insight-header h3,
      .insight-header h4 {
        color: #2d3748;
      }

      .risk-chip {
        font-size: 0.9em;
        font-weight: 700;
        padding: 6px 12px;
        border-radius: 999px;
        background: #edf2f7;
        color: #2d3748;
        transition: background 0.2s ease, color 0.2s ease;
      }

      .risk-chip.state-high {
        background: #fed7d7;
        color: #9b2c2c;
      }

      .risk-chip.state-mid {
        background: #faf089;
        color: #b7791f;
      }

      .risk-chip.state-low {
        background: #c6f6d5;
        color: #276749;
      }

      .risk-chip.state-none {
        background: #e2e8f0;
        color: #2d3748;
      }

      .insight-message {
        color: #4a5568;
        font-size: 0.95em;
        line-height: 1.5;
      }

      .insight-subtitle {
        color: #718096;
        font-size: 0.85em;
      }

      .insight-meta {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
      }

      .insight-label {
        display: block;
        font-size: 0.75em;
        text-transform: uppercase;
        color: #a0aec0;
        letter-spacing: 0.04em;
      }

      .insight-value {
        font-size: 1.3em;
        font-weight: 700;
        color: #2d3748;
      }

      .hotspot-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .hotspot-item {
        padding: 10px 12px;
        border-radius: 12px;
        background: #f7fafc;
        border: 1px solid rgba(226, 232, 240, 0.8);
      }

      .hotspot-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        color: #2d3748;
      }

      .hotspot-meta {
        font-size: 0.78em;
        color: #718096;
        margin-top: 4px;
      }

      .hotspot-meter {
        position: relative;
        height: 6px;
        border-radius: 999px;
        background: #e2e8f0;
        overflow: hidden;
        margin-top: 8px;
      }

      .hotspot-meter-fill {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 0;
        background: linear-gradient(90deg, #fc8181, #ed64a6);
        transition: width 0.3s ease;
      }

      .category-risk-table {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .category-risk-row {
        display: grid;
        grid-template-columns: 36px 1fr minmax(120px, 1fr) 60px;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        border-radius: 12px;
        background: #f8fafc;
        border: 1px solid rgba(226, 232, 240, 0.8);
      }

      .category-risk-rank {
        font-weight: 700;
        color: #4a5568;
      }

      .category-risk-info {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .category-risk-label {
        font-weight: 600;
        color: #2d3748;
      }

      .category-risk-open {
        font-size: 0.75em;
        color: #718096;
      }

      .category-risk-bar {
        position: relative;
        height: 8px;
        border-radius: 999px;
        background: #e2e8f0;
        overflow: hidden;
      }

      .category-risk-bar-fill {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 0;
        background: linear-gradient(90deg, #63b3ed, #805ad5);
        transition: width 0.3s ease;
      }

      .category-risk-value {
        font-weight: 700;
        color: #2d3748;
        text-align: right;
      }

      .insight-empty {
        font-size: 0.85em;
        color: #718096;
      }

      @media (max-width: 768px) {
        .category-risk-row {
          grid-template-columns: 28px 1fr;
          grid-template-rows: auto auto;
          row-gap: 6px;
        }

        .category-risk-bar,
        .category-risk-value {
          grid-column: 1 / -1;
        }

        .category-risk-value {
          text-align: left;
        }
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        margin-top: 15px;
      }

      .stat-card {
        text-align: center;
        padding: 15px;
        background: #f7fafc;
        border-radius: 8px;
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        color: #667eea;
      }

      .stat-label {
        color: #718096;
        font-size: 0.9em;
        margin-top: 5px;
      }

      .ai-suggestions {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
      }

      .ai-suggestions h3 {
        color: #92400e;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .suggestion-item {
        background: white;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .suggestion-item:hover {
        transform: translateX(5px);
      }

      .suggestion-item-coach {
        cursor: default;
        background: #fff5eb;
      }

      .suggestion-item-static {
        cursor: default;
      }

      .suggestion-item-static:hover {
        transform: none;
      }

      .suggestion-badge {
        display: inline-block;
        border-radius: 999px;
        background: #edf2f7;
        color: #2d3748;
        font-size: 0.7em;
        font-weight: 600;
        padding: 2px 8px;
        margin-left: 6px;
        vertical-align: middle;
      }

      .pomodoro-timer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 15px;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 100;
      }

      .timer-display {
        font-size: 2.2em;
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 10px;
      }

      .timer-label {
        font-size: 0.9em;
        color: #718096;
        margin-bottom: 15px;
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }

      .timer-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: transform 0.2s;
      }

      .timer-btn:hover {
        transform: scale(1.05);
      }

      .timer-btn.pause {
        background: #f6d365;
        color: #2d3748;
      }

      .timer-btn.resume {
        background: #48bb78;
        color: white;
      }

      .timer-btn.stop {
        background: #fc8181;
        color: white;
      }

      .deadline-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #e53e3e;
        pointer-events: none;
        z-index: 20;
      }

      .deadline-label {
        position: absolute;
        top: -20px;
        background: #e53e3e;
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        transform: translateX(-50%);
      }

      .google-cal-section {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .google-section-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 10px;
        padding: 12px 16px;
        color: #2d3748;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .google-section-toggle:hover {
        background: #edf2f7;
      }

      .google-section-toggle.collapsed .toggle-icon,
      .google-section-toggle .toggle-icon {
        font-size: 0.9em;
        transform: rotate(0deg);
        transition: transform 0.2s ease;
      }

      .google-section-toggle.expanded .toggle-icon {
        transform: rotate(90deg);
      }

      .google-cal-content {
        margin-top: 16px;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        transition: max-height 0.25s ease, opacity 0.25s ease;
        max-height: 600px;
        overflow: hidden;
        opacity: 1;
      }

      .google-cal-content.collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border-width: 0;
      }

      .google-cal-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9em;
        color: #4a5568;
        margin-bottom: 12px;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid #e2e8f0;
        font-size: 0.85em;
      }

      .status-pill.success {
        background: #c6f6d5;
        border-color: #48bb78;
        color: #22543d;
      }

      .status-pill.warning {
        background: #fed7d7;
        border-color: #fc8181;
        color: #9b2c2c;
      }

      .google-btn {
        background: white;
        border: 2px solid #4285f4;
        color: #4285f4;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.3s;
      }

      .google-btn:hover {
        background: #4285f4;
        color: white;
      }

      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(45, 55, 72, 0.45);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1200;
        padding: 20px;
      }

      .modal-overlay.show {
        display: flex;
      }

      .modal-content {
        background: #ffffff;
        border-radius: 16px;
        max-width: 420px;
        width: 100%;
        padding: 24px;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        position: relative;
      }

      .modal-content.notification-permission-modal {
        max-width: 380px;
      }

      .modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: transparent;
        border: none;
        font-size: 20px;
        color: #4a5568;
        cursor: pointer;
      }

      .modal-time {
        color: #4a5568;
        margin-top: 8px;
        font-size: 0.95em;
      }

      .modal-meta {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
        margin-top: 16px;
      }

      .modal-meta div {
        background: #f7fafc;
        border-radius: 8px;
        padding: 10px;
        font-size: 0.85em;
        color: #2d3748;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .meta-label {
        font-size: 0.75em;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #718096;
      }

      .modal-description {
        margin-top: 18px;
        color: #4a5568;
        font-size: 0.95em;
        line-height: 1.5;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
        margin-top: 24px;
        flex-wrap: wrap;
      }

      .modal-actions button {
        flex: 1;
        min-width: 140px;
        padding: 10px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .modal-actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.18);
      }

      .modal-actions button.disabled,
      .modal-actions button:disabled {
        cursor: not-allowed;
        opacity: 0.6;
        box-shadow: none;
        transform: none;
      }

      .modal-actions .primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
      }

      .modal-actions .danger {
        background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);
        color: #ffffff;
      }

      .modal-actions .secondary {
        background: #edf2f7;
        color: #2d3748;
      }

      @media (max-width: 1200px) {
        body {
          overflow: auto;
        }

        .app-shell {
          flex-direction: column;
          height: auto;
        }

        .app-sidebar-wrapper {
          width: 100%;
          min-width: 0;
        }

        .sidebar {
          height: auto;
          min-height: 0;
        }

        .app-main {
          height: auto;
          min-height: 0;
        }
      }

      @media (max-width: 900px) {
        .app-shell {
          padding: 18px;
        }

        .app-main {
          padding: 24px;
        }

        .app-main > section {
          padding: 22px;
        }

        .stats-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      @media (max-width: 700px) {
        .app-shell {
          padding: 16px;
        }

        .mini-header {
          padding: 10px 12px;
        }

        .sidebar {
          padding: 18px;
        }

        .app-main {
          padding: 20px;
        }

        .app-main > section {
          padding: 18px;
        }

        .floating-task-entry {
          bottom: 18px;
        }

        .stats-grid {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 768px) {
        .mini-header {
          background: rgba(15, 23, 42, 0.35);
        }

        .productivity-meter {
          display: flex;
          flex-direction: row;
          gap: 10px;
        }

        .modal-meta {
          grid-template-columns: 1fr;
        }

        .calendar-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 12px;
        }

        .calendar-header-left {
          width: 100%;
          justify-content: space-between;
        }

        .calendar-nav {
          width: 100%;
          justify-content: space-between;
        }

        .calendar-google-btn {
          width: 100%;
          min-width: 0;
        }
      }
    </style>
  </head>
  <body
    data-user-id="{{ user_id }}"
    data-user-email="{{ user_profile.get('email', '') if user_profile else '' }}"
    data-page="{{ page_name }}"
  >
    <div class="app-shell">
      <div class="app-sidebar-wrapper">
        <header class="mini-header">
          <button
            class="burger-button"
            type="button"
            id="burgerButton"
            aria-label="Open navigation"
          >
            <span class="burger-line"></span>
            <span class="burger-line"></span>
            <span class="burger-line"></span>
          </button>
          <div class="mini-logo">
            <img
              src="{{ url_for('static', filename='images/LockIN-logo-noBG.png') }}"
              alt="LockIN logo"
            />
          </div>
        </header>
        <div class="productivity-meter state-mid" id="productivityMeter">
          <div class="productivity-mini-top">
            <span class="productivity-label">Today's Focus</span>
            <span class="productivity-score" id="productivityScore">--/10</span>
          </div>
          <div class="productivity-mini-body">
            <div class="productivity-bot">
              <img
                id="productivityBot"
                src="{{ url_for('static', filename='images/Bot_happy.png') }}"
                alt="Productivity bot cheering"
              />
            </div>
            <div class="productivity-bubble">
              <span class="productivity-message" id="productivityMessage">
                Dialing in your momentum...
              </span>
            </div>
          </div>
          <div class="productivity-bar">
            <div class="productivity-bar-fill" id="productivityBar"></div>
          </div>
        </div>
        <aside class="sidebar" id="sidebar">
          <div
            class="sidebar-tabs"
            role="tablist"
            aria-label="Sidebar sections"
          >
            <button
              class="sidebar-tab-button active"
              type="button"
              data-tab="add"
              id="sidebarTabAdd"
              role="tab"
              aria-selected="true"
              aria-controls="sidebarPanelAdd"
            >
              Add Task
            </button>
            <button
              class="sidebar-tab-button"
              type="button"
              data-tab="ai"
              id="sidebarTabAI"
              role="tab"
              aria-selected="false"
              aria-controls="sidebarPanelAI"
            >
              AI Suggestions
            </button>
            <button
              class="sidebar-tab-button"
              type="button"
              data-tab="tasks"
              id="sidebarTabTasks"
              role="tab"
              aria-selected="false"
              aria-controls="sidebarPanelTasks"
            >
              Active Tasks
            </button>
          </div>
          <div class="sidebar-panel-container">
            <div
              class="sidebar-tab-panel active"
              data-panel="add"
              id="sidebarPanelAdd"
              role="tabpanel"
              aria-labelledby="sidebarTabAdd"
              aria-hidden="false"
            >
              <form
                class="sidebar-add-form"
                id="sidebarAddTaskForm"
                onsubmit="submitSidebarTaskForm(event)"
              >
                <div class="form-group">
                  <label for="sidebarTaskName">Task Name</label>
                  <input
                    type="text"
                    id="sidebarTaskName"
                    placeholder="e.g., Deep work session"
                    required
                  />
                </div>
                <div class="form-group">
                  <label for="sidebarDeadline">Deadline</label>
                  <input type="datetime-local" id="sidebarDeadline" required />
                </div>
                <div class="form-group">
                  <label for="sidebarDaysRequired">Days Required</label>
                  <input
                    type="number"
                    id="sidebarDaysRequired"
                    min="1"
                    value="1"
                    required
                  />
                </div>
                <div class="form-group">
                  <label for="sidebarDailyHours">Daily Hours</label>
                  <input
                    type="number"
                    id="sidebarDailyHours"
                    min="0.5"
                    step="0.5"
                    value="2"
                    required
                  />
                </div>
                <div class="floating-task-actions" style="margin-top: 20px">
                  <button class="btn" type="submit">Schedule It</button>
                </div>
                <p style="color: #64748b; font-size: 0.85rem; margin-top: 12px">
                  Need the full planner? Tap the floating + button for advanced
                  options.
                </p>
              </form>
            </div>
            <div
              class="sidebar-tab-panel"
              data-panel="ai"
              id="sidebarPanelAI"
              role="tabpanel"
              aria-labelledby="sidebarTabAI"
              aria-hidden="true"
              hidden
            >
              <div class="ai-suggestions" id="aiSuggestions">
                <h3>ðŸ¤– AI Suggestions</h3>
                <div id="suggestionsList"></div>
              </div>
            </div>
            <div
              class="sidebar-tab-panel"
              data-panel="tasks"
              id="sidebarPanelTasks"
              role="tabpanel"
              aria-labelledby="sidebarTabTasks"
              aria-hidden="true"
              hidden
            >
              <div class="task-list">
                <h3 style="color: #2d3748; margin-bottom: 15px">
                  Current Focus
                </h3>
                <div id="taskList"></div>
              </div>
            </div>
          </div>
        </aside>
      </div>

      <main class="app-main">
        {% if page_name == 'home' %}
        <section class="calendar-section">
          <div class="calendar-header">
            <div class="calendar-header-left">
              <h2 style="color: #2d3748">Week View</h2>
              <button
                class="google-btn calendar-google-btn"
                id="googleAuthButton"
                type="button"
              >
                Connect Google Calendar
              </button>
            </div>
            <div class="calendar-nav">
              <button
                class="nav-btn"
                id="prevWeekBtn"
                aria-label="Previous week"
              >
                &lsaquo;
              </button>
              <span id="currentWeek" style="color: #718096"></span>
              <button class="nav-btn" id="nextWeekBtn" aria-label="Next week">
                &rsaquo;
              </button>
            </div>
          </div>
          <div class="week-view" id="weekView"></div>
        </section>
        {% elif page_name == 'stats' %}
        <section class="stats-panel">
          <h3 style="color: #2d3748">Productivity Stats</h3>
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="tasksCompleted">0</div>
              <div class="stat-label">Tasks Completed</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="focusTime">0h</div>
              <div class="stat-label">Focus Time Today</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="streakDays">0</div>
              <div class="stat-label">Day Streak</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="completionRate">0%</div>
              <div class="stat-label">Completion Rate</div>
            </div>
          </div>
        </section>
        <section class="procrastination-panel" id="procrastinationPanel">
          <div class="insight-card">
            <div class="insight-header">
              <h3>Procrastination Pulse</h3>
              <span class="risk-chip state-none" id="procrastinationScore"
                >--%</span
              >
            </div>
            <p class="insight-message" id="procrastinationMessage">
              We need a little more data before we can surface trends.
            </p>
            <div class="insight-meta">
              <div>
                <span class="insight-label">Tasks Analyzed</span>
                <span class="insight-value" id="procrastinationTasks">0</span>
              </div>
              <div>
                <span class="insight-label">Missed Slots</span>
                <span class="insight-value" id="procrastinationMissed">0</span>
              </div>
            </div>
          </div>

          <div class="insight-card">
            <div class="insight-header">
              <h4>Hotspot Timings</h4>
            </div>
            <p class="insight-subtitle">
              Day and time windows where focus blocks tend to slip.
            </p>
            <div id="hotspotList" class="hotspot-list"></div>
          </div>

          <div class="insight-card insight-card-wide">
            <div class="insight-header">
              <h4>Category Risk Table</h4>
            </div>
            <p class="insight-subtitle">
              % chance of procrastination by task type.
            </p>
            <div id="categoryRiskRows" class="category-risk-table"></div>
          </div>
        </section>
        {% elif page_name == 'imports' %}
        <section class="google-cal-section" id="googleCalSection">
          <button
            type="button"
            class="google-section-toggle"
            id="googleCalToggle"
          >
            <span>Google Calendar Integration</span>
            <span class="toggle-icon" aria-hidden="true">â–¸</span>
          </button>
          <div class="google-cal-content" id="googleCalContent">
            <div class="google-cal-status">
              <span>Status:</span>
              <span id="authStatus" class="status-pill">Not Connected</span>
            </div>
            <button
              class="google-btn"
              id="refreshEventsBtn"
              style="display: none"
              onclick="refreshGoogleEvents()"
            >
              Refresh Google Events
            </button>
            <div id="calendarEvents" class="google-events-list">
              <p style="color: #718096">
                Connect from the Home page to sync your Google Calendar.
              </p>
            </div>
          </div>
        </section>
        {% endif %}
      </main>
    </div>

    <div class="menu-overlay" id="menuOverlay" aria-hidden="true">
      <div class="menu-overlay-inner">
        <div class="menu-overlay-header">
          <span class="menu-title">Menu</span>
          <button
            class="overlay-close"
            type="button"
            id="menuClose"
            aria-label="Close menu"
          >
            &times;
          </button>
        </div>
        <nav class="menu-nav">
          <a
            href="{{ url_for('index') }}"
            class="menu-link{% if page_name == 'home' %} active{% endif %}"
            data-page="home"
          >
            Home
          </a>
          <a
            href="{{ url_for('stats_page') }}"
            class="menu-link{% if page_name == 'stats' %} active{% endif %}"
            data-page="stats"
          >
            Stats &amp; Coach
          </a>
          <a
            href="{{ url_for('imports_page') }}"
            class="menu-link{% if page_name == 'imports' %} active{% endif %}"
            data-page="imports"
            id="navImportsLink"
          >
            Imported Google Events
          </a>
        </nav>
      </div>
    </div>

    <div class="floating-task-entry" id="floatingTaskEntry">
      <button
        type="button"
        class="floating-task-button"
        id="floatingTaskButton"
        aria-label="Add new task"
        aria-expanded="false"
        aria-controls="floatingTaskPanel"
      >
        +
      </button>
      <div
        class="floating-task-panel"
        id="floatingTaskPanel"
        role="dialog"
        aria-labelledby="floatingTaskTitle"
        aria-hidden="true"
      >
        <div class="floating-task-header">
          <h3 id="floatingTaskTitle">Add New Task</h3>
          <button
            type="button"
            class="floating-task-close"
            id="floatingTaskCloseBtn"
            aria-label="Close add task form"
          >
            &times;
          </button>
        </div>
        <form
          class="floating-task-form"
          id="floatingTaskForm"
          onsubmit="submitFloatingTaskForm(event)"
        >
          <div class="form-group">
            <label for="taskName">Task Name</label>
            <input
              type="text"
              id="taskName"
              placeholder="e.g., Complete project proposal"
            />
          </div>
          <div class="form-group">
            <label for="deadline">Deadline</label>
            <input type="datetime-local" id="deadline" />
          </div>
          <div class="form-group">
            <label for="daysRequired">Days Required</label>
            <input type="number" id="daysRequired" min="1" value="1" />
          </div>
          <div class="form-group">
            <label for="dailyHours">Daily Hours</label>
            <input
              type="number"
              id="dailyHours"
              min="0.5"
              step="0.5"
              value="2"
            />
          </div>
          <div class="floating-task-actions">
            <button class="btn" type="submit">Add Task</button>
            <button
              class="btn btn-secondary"
              type="button"
              id="floatingTaskCancel"
            >
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="notificationPermissionModal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="notificationModalTitle"
      aria-hidden="true"
    >
      <div class="modal-content notification-permission-modal">
        <button
          class="modal-close"
          type="button"
          id="notificationModalClose"
          aria-label="Close notification permission prompt"
        >
          &times;
        </button>
        <h3
          id="notificationModalTitle"
          style="color: #2d3748; font-size: 1.25em; margin-bottom: 12px"
        >
          Stay on Track
        </h3>
        <p
          id="notificationModalMessage"
          style="color: #4a5568; line-height: 1.5; margin-bottom: 20px"
        >
          Enable notifications so we can nudge you when focus blocks begin.
        </p>
        <div class="modal-actions">
          <button class="primary" type="button" id="notificationModalEnable">
            Enable Notifications
          </button>
          <button class="secondary" type="button" id="notificationModalDismiss">
            Maybe Later
          </button>
        </div>
      </div>
    </div>

    <div class="notification" id="notification">
      <div class="notification-header" id="notificationHeader">
        Task Reminder
      </div>
      <div class="notification-body" id="notificationBody">
        It's time for your scheduled task
      </div>
      <div class="notification-actions">
        <button
          class="notification-btn accept"
          onclick="handleNotification('accept')"
        >
          Start
        </button>
        <button
          class="notification-btn reschedule"
          onclick="handleNotification('reschedule')"
        >
          Reschedule
        </button>
        <button
          class="notification-btn decline"
          onclick="handleNotification('decline')"
        >
          Skip
        </button>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="eventModal"
      onclick="handleModalOverlayClick(event)"
    >
      <div class="modal-content">
        <button class="modal-close" onclick="closeEventModal()">&times;</button>
        <h3 id="modalTitle" style="color: #2d3748; font-size: 1.4em">
          Scheduled Block
        </h3>
        <p class="modal-time" id="modalTime"></p>
        <div class="modal-meta">
          <div>
            <span class="meta-label">Source</span>
            <span id="modalSource"></span>
          </div>
          <div>
            <span class="meta-label">Status</span>
            <span id="modalStatus"></span>
          </div>
          <div>
            <span class="meta-label">Duration</span>
            <span id="modalDuration"></span>
          </div>
          <div id="modalLocationRow" style="display: none">
            <span class="meta-label">Location</span>
            <span id="modalLocation"></span>
          </div>
        </div>
        <p class="modal-description" id="modalDescription"></p>
        <div class="modal-actions">
          <button
            class="secondary"
            id="modalCloseBtn"
            onclick="closeEventModal()"
          >
            Close
          </button>
          <button
            class="primary"
            id="modalStartBtn"
            onclick="startFocusFromModal()"
          >
            Start Focus Session
          </button>
          <button
            class="danger"
            id="modalDeleteBtn"
            onclick="deleteScheduleItem()"
          >
            Delete Block
          </button>
        </div>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="errorModal"
      onclick="handleErrorModalOverlayClick(event)"
    >
      <div class="modal-content">
        <button class="modal-close" onclick="closeErrorModal()">&times;</button>
        <h3 style="color: #2d3748; font-size: 1.3em; margin-bottom: 12px">
          Placement Blocked
        </h3>
        <p
          id="errorModalMessage"
          style="color: #4a5568; line-height: 1.4; margin-bottom: 20px"
        ></p>
        <div class="modal-actions">
          <button class="primary" onclick="closeErrorModal()">Got it</button>
        </div>
      </div>
    </div>

    <div class="pomodoro-timer" id="pomodoroTimer" style="display: none">
      <div class="timer-display" id="timerDisplay">25:00</div>
      <div class="timer-label" id="timerLabel">Focus Time</div>
      <div class="timer-controls">
        <button
          class="timer-btn pause"
          id="pauseBtn"
          onclick="togglePauseResume()"
        >
          â¸ Pause
        </button>
        <button class="timer-btn stop" onclick="stopPomodoro()">â¹ Stop</button>
      </div>
    </div>

    <script>
      const DISCOVERY_DOCS = [
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest",
      ];
      const USER_ID = document.body.dataset.userId || "guest";
      const CURRENT_PAGE = document.body.dataset.page || "home";
      const storageKey = (base) => `${base}_${USER_ID}`;
      const DEFAULT_STATS = {
        completed: 0,
        focusTime: 0,
        streak: 0,
        totalTasks: 0,
      };

      let analyticsProductivity = null;
      let analyticsProcrastination = null;
      let aiCoachMessage = null;
      let pendingYesterdayTasks = [];
      let analyticsRefreshIntervalId = null;
      let analyticsRefreshTimeoutId = null;

      const deepClone = (value) => JSON.parse(JSON.stringify(value));
      function loadStorage(base, defaultValue) {
        try {
          const raw = localStorage.getItem(storageKey(base));
          if (!raw) {
            return deepClone(defaultValue);
          }
          return JSON.parse(raw);
        } catch (error) {
          console.warn(`Failed to load ${base} from storage`, error);
          return deepClone(defaultValue);
        }
      }

      function saveStorage(base, value) {
        try {
          localStorage.setItem(storageKey(base), JSON.stringify(value));
        } catch (error) {
          console.warn(`Failed to persist ${base} in storage`, error);
        }
      }

      function formatShortDate(value) {
        if (!value) {
          return "No deadline";
        }
        const parsed = new Date(value);
        if (Number.isNaN(parsed.getTime())) {
          return String(value);
        }
        return parsed.toLocaleDateString(undefined, {
          month: "short",
          day: "numeric",
        });
      }

      function formatMinutesToHours(minutes) {
        if (!minutes || Number.isNaN(Number(minutes))) {
          return "0h";
        }
        const hours = Number(minutes) / 60;
        if (hours >= 1) {
          return `${hours.toFixed(
            Math.abs(hours - Math.round(hours)) < 0.05 ? 0 : 1
          )}h`;
        }
        return `${Math.round(minutes)}m`;
      }

      function labelFromCategory(slug, fallback) {
        if (fallback) {
          return fallback;
        }
        if (!slug) {
          return "General";
        }
        return slug
          .toString()
          .replace(/[_-]+/g, " ")
          .replace(/\b\w/g, (char) => char.toUpperCase());
      }

      const GOOGLE_CAL_STATE_KEY = storageKey("googleCalExpanded");

      async function refreshAnalytics(options = {}) {
        const { silent = false } = options;
        try {
          const [productivityRes, procrastinationRes] = await Promise.all([
            fetch("/analytics/productivity", {
              headers: { Accept: "application/json" },
            }),
            fetch("/analytics/procrastination", {
              headers: { Accept: "application/json" },
            }),
          ]);

          if (!productivityRes.ok || !procrastinationRes.ok) {
            throw new Error("Analytics endpoints unavailable");
          }

          analyticsProductivity = await productivityRes.json();
          analyticsProcrastination = await procrastinationRes.json();
          applyAnalyticsOutputs();
        } catch (error) {
          if (!silent) {
            console.warn("Failed to refresh analytics", error);
          }
        }
      }

      function applyAnalyticsOutputs() {
        updateStats();
        updateProductivityMeter();
        generateAISuggestions();
        renderProcrastinationInsights();
      }

      function scheduleAnalyticsRefresh(delay = 3000) {
        if (analyticsRefreshTimeoutId) {
          clearTimeout(analyticsRefreshTimeoutId);
        }
        analyticsRefreshTimeoutId = setTimeout(() => {
          refreshAnalytics({ silent: true });
          analyticsRefreshTimeoutId = null;
        }, delay);
      }

      function applyAnalyticsStats() {
        if (!analyticsProductivity) {
          return;
        }

        const summary = analyticsProductivity.summary || {};
        const tasksFromServer = Array.isArray(analyticsProductivity.tasks)
          ? analyticsProductivity.tasks
          : [];
        const completedTasks = tasksFromServer.filter(
          (task) => task && task.status === "completed"
        ).length;
        const totalTasks =
          typeof summary.totalTasks === "number"
            ? summary.totalTasks
            : Math.max(tasksFromServer.length, 0);

        const todayIso = new Date().toISOString().slice(0, 10);
        const timeline = Array.isArray(analyticsProductivity.timeline)
          ? analyticsProductivity.timeline
          : [];
        const todayEntry = timeline.find((entry) => entry.date === todayIso);
        const focusMinutesToday = todayEntry ? todayEntry.minutes || 0 : 0;
        const focusHoursToday = focusMinutesToday / 60;

        const streak = analyticsProductivity.streakDays || 0;
        const completionRate =
          totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

        stats = {
          completed: completedTasks,
          focusTime: focusHoursToday,
          streak,
          totalTasks,
        };

        saveStorage("stats", stats);

        const completedNode = document.getElementById("tasksCompleted");
        if (completedNode) {
          completedNode.textContent = completedTasks;
        }

        const focusNode = document.getElementById("focusTime");
        if (focusNode) {
          focusNode.textContent = `${focusHoursToday.toFixed(1)}h`;
        }

        const streakNode = document.getElementById("streakDays");
        if (streakNode) {
          streakNode.textContent = streak;
        }

        const completionNode = document.getElementById("completionRate");
        if (completionNode) {
          completionNode.textContent = `${completionRate}%`;
        }
      }

      // State Management
      let tasks = loadStorage("tasks", []);
      let schedule = loadStorage("schedule", []);
      let dismissedGoogleEvents = new Set(
        loadStorage("dismissedGoogleEvents", []).map(String)
      );
      let notifiedSlots = new Set(loadStorage("notifiedSlots", []).map(String));
      let notifiedDeadlines = new Set(
        loadStorage("notifiedDeadlines", []).map(String)
      );
      let lastMissedNotificationDate = localStorage.getItem(
        storageKey("lastMissedNotificationDate")
      );
      let lastAiNotification = Number(
        localStorage.getItem(storageKey("lastAiNotification")) || "0"
      );
      let activeScheduleId = null;
      let currentTask = null;
      let pomodoroInterval = null;
      let pomodoroTimeLeft = 25 * 60;
      let pomodoroPaused = false;
      let stats = loadStorage("stats", DEFAULT_STATS);

      const FOCUS_SLOT_MINUTES = 30;
      const FOCUS_SLOT_MS = FOCUS_SLOT_MINUTES * 60 * 1000;
      const PREFERRED_TIME_WINDOWS = [
        { startHour: 9, endHour: 11, productivity: 1.2 },
        { startHour: 14, endHour: 16, productivity: 1.0 },
        { startHour: 19, endHour: 21, productivity: 0.8 },
      ];
      const PRODUCTIVITY_MEDIA = {
        low: {
          bot: "{{ url_for('static', filename='images/Bot_sad.png') }}",
          message: "You're procrastinating - let's reclaim the day.",
          alt: "Focus bot looking concerned",
        },
        mid: {
          bot: "{{ url_for('static', filename='images/Bot_happy.png') }}",
          message: "Good going - stay productive and ride the wave!",
          alt: "Focus bot smiling",
        },
        high: {
          bot: "{{ url_for('static', filename='images/Bot_lockedin.png') }}",
          message: "Locked In FR - keep that focus laser sharp!",
          alt: "Focus bot dialed in",
        },
        none: {
          bot: "{{ url_for('static', filename='images/Bot_happy.png') }}",
          message: "We don't have any tasks today - score stays at 0.",
          alt: "Focus bot at ease",
        },
      };

      // Google Calendar API configuration
      const GOOGLE_CLIENT_ID = "{{ google_client_id or '' }}";
      const GOOGLE_API_KEY = "{{ calendar_api_key or '' }}";
      const SCOPES = "{{ google_scopes or '' }}";

      let domReady = false;
      window.gapiLoaded = window.gapiLoaded || false;
      let calendarApiLoaded = false;
      let googleAccountAuthenticated = false;
      let currentWeekStart = getStartOfWeek(new Date());
      let calendarScrollInitialized = false;
      let userAdjustedCalendarScroll = false;
      let draggedScheduleId = null;
      let floatingTaskEntryInitialized = false;
      let notificationModalInitialized = false;
      let previousFocusBeforeNotificationModal = null;

      function setGoogleCalendarExpanded(expand, persist = true) {
        const toggle = document.getElementById("googleCalToggle");
        const content = document.getElementById("googleCalContent");
        if (!toggle || !content) return;

        if (expand) {
          content.classList.remove("collapsed");
          toggle.classList.add("expanded");
          toggle.setAttribute("aria-expanded", "true");
        } else {
          content.classList.add("collapsed");
          toggle.classList.remove("expanded");
          toggle.setAttribute("aria-expanded", "false");
        }

        if (persist) {
          localStorage.setItem(GOOGLE_CAL_STATE_KEY, expand ? "1" : "0");
        }
      }

      function setupGoogleCalendarToggle() {
        const toggle = document.getElementById("googleCalToggle");
        const content = document.getElementById("googleCalContent");
        if (!toggle || !content) return;

        const storedState = localStorage.getItem(GOOGLE_CAL_STATE_KEY);
        if (storedState === "1") {
          setGoogleCalendarExpanded(true, false);
        } else {
          setGoogleCalendarExpanded(false, false);
        }

        toggle.addEventListener("click", () => {
          const shouldExpand = content.classList.contains("collapsed");
          setGoogleCalendarExpanded(shouldExpand);
        });
      }

      function setupMenuOverlay() {
        const burger = document.getElementById("burgerButton");
        const overlay = document.getElementById("menuOverlay");
        const closeBtn = document.getElementById("menuClose");

        if (!burger || !overlay) {
          return;
        }

        const closeMenu = () => {
          overlay.classList.remove("active");
          overlay.setAttribute("aria-hidden", "true");
          document.body.classList.remove("menu-open");
          if (
            document.activeElement &&
            overlay.contains(document.activeElement) &&
            typeof burger.focus === "function"
          ) {
            burger.focus();
          }
        };

        const openMenu = () => {
          overlay.classList.add("active");
          overlay.setAttribute("aria-hidden", "false");
          document.body.classList.add("menu-open");
          const activeLink = overlay.querySelector(
            '.menu-link[data-page="' + CURRENT_PAGE + '"]'
          );
          const focusTarget = activeLink || overlay.querySelector(".menu-link");
          if (focusTarget) {
            requestAnimationFrame(() => focusTarget.focus());
          }
        };

        burger.addEventListener("click", () => {
          if (overlay.classList.contains("active")) {
            closeMenu();
          } else {
            openMenu();
          }
        });

        if (closeBtn) {
          closeBtn.addEventListener("click", closeMenu);
        }

        overlay.addEventListener("click", (event) => {
          if (event.target === overlay) {
            closeMenu();
          }
        });

        overlay.querySelectorAll(".menu-link").forEach((link) => {
          const targetPage = link.dataset.page;
          if (targetPage && targetPage === CURRENT_PAGE) {
            link.classList.add("active");
            link.setAttribute("aria-current", "page");
          }
          link.addEventListener("click", () => {
            closeMenu();
          });
        });

        document.addEventListener("keydown", (event) => {
          if (event.key === "Escape" && overlay.classList.contains("active")) {
            closeMenu();
          }
        });
      }

      function setupSidebarTabs() {
        const tabButtons = Array.from(
          document.querySelectorAll(".sidebar-tab-button")
        );
        const panels = Array.from(
          document.querySelectorAll(".sidebar-tab-panel")
        );

        if (!tabButtons.length || !panels.length) {
          return;
        }

        const activate = (targetId) => {
          if (!targetId) {
            return;
          }
          const target = String(targetId);
          tabButtons.forEach((button) => {
            const isActive = button.dataset.tab === target;
            button.classList.toggle("active", isActive);
            button.setAttribute("aria-selected", isActive ? "true" : "false");
            if (isActive) {
              button.setAttribute("tabindex", "0");
            } else {
              button.setAttribute("tabindex", "-1");
            }
          });

          panels.forEach((panel) => {
            const isActive = panel.dataset.panel === target;
            panel.classList.toggle("active", isActive);
            panel.setAttribute("aria-hidden", isActive ? "false" : "true");
            if (isActive) {
              panel.removeAttribute("hidden");
            } else {
              panel.setAttribute("hidden", "true");
            }
          });
        };

        tabButtons.forEach((button, index) => {
          button.addEventListener("click", () => activate(button.dataset.tab));
          button.addEventListener("keydown", (event) => {
            if (!["ArrowLeft", "ArrowRight"].includes(event.key)) {
              return;
            }
            event.preventDefault();
            const direction = event.key === "ArrowRight" ? 1 : -1;
            const nextIndex =
              (index + direction + tabButtons.length) % tabButtons.length;
            const nextButton = tabButtons[nextIndex];
            if (nextButton) {
              activate(nextButton.dataset.tab);
              nextButton.focus();
            }
          });
        });

        const initial =
          tabButtons.find((btn) => btn.classList.contains("active")) ||
          tabButtons[0];
        if (initial) {
          activate(initial.dataset.tab);
        }
      }

      function applyCalendarScrollFocus() {
        const scrollContainer = document.getElementById("calendarScroll");
        if (!scrollContainer) {
          return;
        }

        if (!calendarScrollInitialized) {
          scrollContainer.addEventListener("scroll", () => {
            if (scrollContainer.dataset.lockScroll === "1") {
              return;
            }
            userAdjustedCalendarScroll = true;
            scrollContainer.dataset.userAdjusted = "true";
          });
        }

        if (!userAdjustedCalendarScroll) {
          scrollContainer.dataset.lockScroll = "1";
          const offset = Math.max(
            0,
            (DEFAULT_CALENDAR_VIEW_START - CALENDAR_DAY_START) *
              CALENDAR_SLOT_HEIGHT
          );
          scrollContainer.scrollTop = offset;
          requestAnimationFrame(() => {
            scrollContainer.dataset.lockScroll = "0";
          });
        }

        calendarScrollInitialized = true;
      }

      // Initialize the app
      function init() {
        setDefaultDeadline();
        setupFloatingTaskEntry();
        setupNotificationPermissionModal();
        setupGoogleCalendarToggle();
        const prevWeekBtn = document.getElementById("prevWeekBtn");
        const nextWeekBtn = document.getElementById("nextWeekBtn");
        if (prevWeekBtn && nextWeekBtn) {
          prevWeekBtn.addEventListener("click", () => changeWeek(-1));
          nextWeekBtn.addEventListener("click", () => changeWeek(1));
        }
        updateGoogleAuthUI();
        renderTasks();
        renderCalendar();
        updateStats();
        startNotificationChecker();
        generateAISuggestions();
        refreshAnalytics({ silent: true });
        runAiInsights();
        if (!analyticsRefreshIntervalId) {
          analyticsRefreshIntervalId = setInterval(
            () => refreshAnalytics({ silent: true }),
            12 * 60 * 1000
          );
        }
        syncNotificationButton();
        checkNotificationPermissionOnLoad();

        fetch("/check_auth")
          .then((r) => r.json())
          .then((data) => {
            const googleSection = document.getElementById("googleCalSection");
            if (googleSection) {
              googleSection.style.display = "block";
            }
            googleAccountAuthenticated = !!data.authenticated;
            updateGoogleAuthUI();
            if (googleAccountAuthenticated) {
              loadGoogleAPI();
              setTimeout(authenticateGapiWithFlaskToken, 1000);
            }
          })
          .catch((error) => {
            console.warn("Failed to confirm Google auth state", error);
          });
      }
      // function authenticateGapiWithFlaskToken() {
      //   if (!gapi.auth2 || !gapi.auth2.getAuthInstance()) {
      //     setTimeout(authenticateGapiWithFlaskToken, 500);
      //     return;
      //   }
      //   fetch("/get_gapi_token")
      //     .then((r) => r.json())
      //     .then((tokenData) => {
      //       const authInstance = gapi.auth2.getAuthInstance();
      //       const user = authInstance.currentUser.get();
      //       user.reloadAuthResponse().then(() => {
      //         user.setAuthResponse({
      //           access_token: tokenData.access_token,
      //           expires_in: tokenData.expires_in,
      //           scope: tokenData.scope,
      //         });
      //         updateSigninStatus(true);
      //       });
      //     });
      // }
      function getStartOfWeek(date) {
        const d = new Date(date);
        const day = d.getDay();
        d.setDate(d.getDate() - day);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      function getDefaultDeadlineValue() {
        const defaultDate = new Date();
        defaultDate.setDate(defaultDate.getDate() + 7);
        return defaultDate.toISOString().slice(0, 16);
      }

      // Set default deadline to one week out
      function setDefaultDeadline(targetId = "deadline") {
        const input = document.getElementById(targetId);
        if (!input) {
          return;
        }
        input.value = getDefaultDeadlineValue();
      }

      function setupFloatingTaskEntry() {
        if (floatingTaskEntryInitialized) {
          return;
        }

        const entry = document.getElementById("floatingTaskEntry");
        const toggleButton = document.getElementById("floatingTaskButton");
        const closeButton = document.getElementById("floatingTaskCloseBtn");
        const cancelButton = document.getElementById("floatingTaskCancel");

        if (!entry || !toggleButton) {
          return;
        }

        floatingTaskEntryInitialized = true;

        toggleButton.addEventListener("click", () => {
          const shouldOpen = !entry.classList.contains("open");
          toggleFloatingTaskForm(shouldOpen);
        });

        if (closeButton) {
          closeButton.addEventListener("click", () => closeFloatingTaskForm());
        }

        if (cancelButton) {
          cancelButton.addEventListener("click", () => closeFloatingTaskForm());
        }

        entry.addEventListener("click", (event) => {
          event.stopPropagation();
        });

        document.addEventListener("click", (event) => {
          if (!entry.classList.contains("open")) {
            return;
          }

          if (!entry.contains(event.target)) {
            closeFloatingTaskForm();
          }
        });
      }

      function setupNotificationPermissionModal() {
        if (notificationModalInitialized) {
          return;
        }

        const modal = document.getElementById("notificationPermissionModal");
        if (!modal) {
          return;
        }

        const enableBtn = document.getElementById("notificationModalEnable");
        const dismissBtn = document.getElementById("notificationModalDismiss");
        const closeBtn = document.getElementById("notificationModalClose");

        notificationModalInitialized = true;

        if (enableBtn) {
          enableBtn.addEventListener("click", () =>
            requestNotificationPermission("modal")
          );
        }

        const handleDismiss = () => {
          hideNotificationPermissionModal();
        };

        if (dismissBtn) {
          dismissBtn.addEventListener("click", handleDismiss);
        }

        if (closeBtn) {
          closeBtn.addEventListener("click", handleDismiss);
        }

        modal.addEventListener("click", (event) => {
          if (event.target === modal) {
            hideNotificationPermissionModal();
          }
        });

        updateNotificationModalContent();
      }

      function showNotificationPermissionModal() {
        const modal = document.getElementById("notificationPermissionModal");
        if (!modal) {
          return;
        }
        const activeElement = document.activeElement;
        if (activeElement instanceof HTMLElement && activeElement !== modal) {
          previousFocusBeforeNotificationModal = activeElement;
        } else {
          previousFocusBeforeNotificationModal = null;
        }
        updateNotificationModalContent();
        modal.classList.add("show");
        modal.setAttribute("aria-hidden", "false");
        requestAnimationFrame(() => {
          const enableBtn = document.getElementById("notificationModalEnable");
          if (enableBtn && !enableBtn.disabled) {
            enableBtn.focus();
          } else {
            const dismissBtn = document.getElementById(
              "notificationModalDismiss"
            );
            if (dismissBtn) {
              dismissBtn.focus();
            }
          }
        });
      }

      function hideNotificationPermissionModal() {
        const modal = document.getElementById("notificationPermissionModal");
        if (!modal) {
          return;
        }
        modal.classList.remove("show");
        modal.setAttribute("aria-hidden", "true");
        if (
          previousFocusBeforeNotificationModal instanceof HTMLElement &&
          document.body.contains(previousFocusBeforeNotificationModal)
        ) {
          try {
            previousFocusBeforeNotificationModal.focus({ preventScroll: true });
          } catch (error) {
            previousFocusBeforeNotificationModal.focus();
          }
        }
        previousFocusBeforeNotificationModal = null;
      }

      function updateNotificationModalContent() {
        const messageNode = document.getElementById("notificationModalMessage");
        const enableBtn = document.getElementById("notificationModalEnable");
        if (!messageNode || !enableBtn) {
          return;
        }

        if (!("Notification" in window)) {
          messageNode.textContent =
            "Your browser does not support notifications, but you can still stay productive here.";
          enableBtn.disabled = true;
          enableBtn.textContent = "Unavailable";
          enableBtn.classList.add("disabled");
          enableBtn.setAttribute("aria-disabled", "true");
          return;
        }

        enableBtn.disabled = false;
        enableBtn.textContent = "Enable Notifications";
        enableBtn.classList.remove("disabled");
        enableBtn.removeAttribute("aria-disabled");

        const permission = Notification.permission;
        if (permission === "denied") {
          messageNode.textContent =
            "Notifications are blocked in your browser settings. Enable them to receive timely reminders.";
          enableBtn.disabled = true;
          enableBtn.textContent = "Notifications Blocked";
          enableBtn.classList.add("disabled");
          enableBtn.setAttribute("aria-disabled", "true");
        } else {
          messageNode.textContent =
            "Enable notifications so we can nudge you when focus blocks begin.";
        }
      }

      function checkNotificationPermissionOnLoad() {
        if (!("Notification" in window)) {
          return;
        }

        if (Notification.permission === "granted") {
          hideNotificationPermissionModal();
          return;
        }

        showNotificationPermissionModal();
      }

      function toggleFloatingTaskForm(shouldOpen) {
        const entry = document.getElementById("floatingTaskEntry");
        const toggleButton = document.getElementById("floatingTaskButton");
        const panel = document.getElementById("floatingTaskPanel");

        if (!entry || !toggleButton || !panel) {
          return;
        }

        if (shouldOpen) {
          entry.classList.add("open");
          toggleButton.setAttribute("aria-expanded", "true");
          panel.setAttribute("aria-hidden", "false");
          requestAnimationFrame(() => {
            const taskNameInput = document.getElementById("taskName");
            if (taskNameInput) {
              taskNameInput.focus();
              taskNameInput.select();
            }
          });
        } else {
          entry.classList.remove("open");
          toggleButton.setAttribute("aria-expanded", "false");
          panel.setAttribute("aria-hidden", "true");
          if (typeof toggleButton.focus === "function") {
            try {
              toggleButton.focus({ preventScroll: true });
            } catch (error) {
              toggleButton.focus();
            }
          }
        }
      }

      function openFloatingTaskForm() {
        toggleFloatingTaskForm(true);
      }

      function closeFloatingTaskForm() {
        toggleFloatingTaskForm(false);
      }

      function submitFloatingTaskForm(event) {
        if (event) {
          event.preventDefault();
        }

        const taskCreated = addTask();
        if (taskCreated) {
          closeFloatingTaskForm();
        }
      }

      // Add a new task
      function addTask(overrides = null) {
        const useOverrides = overrides && typeof overrides === "object";
        const taskNameInput = document.getElementById("taskName");
        const deadlineInput = document.getElementById("deadline");
        const daysInput = document.getElementById("daysRequired");
        const hoursInput = document.getElementById("dailyHours");

        const name =
          useOverrides && overrides.name != null
            ? String(overrides.name).trim()
            : taskNameInput
            ? taskNameInput.value.trim()
            : "";

        const deadlineValue =
          useOverrides && overrides.deadline != null
            ? String(overrides.deadline)
            : deadlineInput
            ? deadlineInput.value
            : "";

        const daysRaw =
          useOverrides && overrides.daysRequired != null
            ? overrides.daysRequired
            : daysInput
            ? daysInput.value
            : 1;

        const hoursRaw =
          useOverrides && overrides.dailyHours != null
            ? overrides.dailyHours
            : hoursInput
            ? hoursInput.value
            : 2;

        const parsedDays = parseInt(daysRaw, 10);
        const daysRequired = Number.isFinite(parsedDays)
          ? Math.max(1, parsedDays)
          : 1;
        const parsedHours = parseFloat(hoursRaw);
        const dailyHours = Number.isFinite(parsedHours)
          ? Math.max(0.5, parsedHours)
          : 2;

        if (!name || !deadlineValue) {
          alert("Please fill in task name and deadline");
          return false;
        }

        const task = {
          id: Date.now(),
          name,
          deadline: new Date(deadlineValue),
          daysRequired,
          dailyHours,
          totalHours: daysRequired * dailyHours,
          completedHours: 0,
          status: "pending",
          priority: calculatePriority(
            new Date(deadlineValue),
            daysRequired * dailyHours
          ),
          createdAt: new Date(),
        };

        tasks.push(task);
        saveTasks();

        // AI Schedule Generation
        generateSchedule(task);

        // Clear form
        if (!useOverrides) {
          if (taskNameInput) {
            taskNameInput.value = "";
          }
          if (daysInput) {
            daysInput.value = "1";
          }
          if (hoursInput) {
            hoursInput.value = "2";
          }
          setDefaultDeadline();
        }

        renderTasks();
        renderCalendar();
        generateAISuggestions();

        updateStats();

        return true;
      }

      function submitSidebarTaskForm(event) {
        if (event) {
          event.preventDefault();
        }

        const form = document.getElementById("sidebarAddTaskForm");
        if (!form) {
          return;
        }

        const nameInput = document.getElementById("sidebarTaskName");
        const deadlineInput = document.getElementById("sidebarDeadline");
        const daysInput = document.getElementById("sidebarDaysRequired");
        const hoursInput = document.getElementById("sidebarDailyHours");

        const created = addTask({
          name: nameInput ? nameInput.value : "",
          deadline: deadlineInput ? deadlineInput.value : "",
          daysRequired: daysInput ? daysInput.value : 1,
          dailyHours: hoursInput ? hoursInput.value : 2,
        });

        if (created) {
          form.reset();
          setDefaultDeadline("sidebarDeadline");
          if (nameInput) {
            nameInput.focus();
          }
        }
      }

      // Calculate task priority based on deadline and time required
      function calculatePriority(deadline, totalHours) {
        const now = new Date();
        const hoursUntilDeadline = (deadline - now) / (1000 * 60 * 60);
        const urgency = totalHours / hoursUntilDeadline;
        return Math.min(10, Math.max(1, Math.round(urgency * 10)));
      }

      function roundToNextSlot(date) {
        const next = new Date(date);
        next.setSeconds(0, 0);
        const minutes = next.getMinutes();
        const remainder = minutes % FOCUS_SLOT_MINUTES;
        if (remainder !== 0) {
          next.setMinutes(minutes + (FOCUS_SLOT_MINUTES - remainder));
        }
        return next;
      }

      function isWeekend(date) {
        const day = date.getDay();
        return day === 0 || day === 6;
      }

      function moveToNextWeekdayMorning(date) {
        const next = new Date(date);
        next.setDate(next.getDate() + 1);
        next.setHours(PREFERRED_TIME_WINDOWS[0].startHour, 0, 0, 0);
        while (isWeekend(next)) {
          next.setDate(next.getDate() + 1);
        }
        return next;
      }

      function getPreferredWindow(date) {
        const hour = date.getHours();
        return PREFERRED_TIME_WINDOWS.find(
          (window) => hour >= window.startHour && hour < window.endHour
        );
      }

      function advanceToNextPreferredStart(date) {
        let candidate = new Date(date);
        candidate.setSeconds(0, 0);
        const hour = candidate.getHours();
        const upcoming = PREFERRED_TIME_WINDOWS.find(
          (window) => window.startHour > hour
        );
        if (upcoming) {
          candidate.setHours(upcoming.startHour, 0, 0, 0);
        } else {
          candidate = moveToNextWeekdayMorning(candidate);
        }
        return candidate;
      }

      function sortScheduleEntries() {
        schedule.sort(
          (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
        );
      }

      function findScheduleConflict(startDate, endDate, ignoreId = null) {
        const startMs = startDate.getTime();
        const endMs = endDate.getTime();
        return schedule.find((entry) => {
          if (!entry || entry.type === "deadline") {
            return false;
          }
          if (ignoreId && String(entry.id) === String(ignoreId)) {
            return false;
          }
          const entryStart = entry.start ? new Date(entry.start) : null;
          const entryEnd = entry.end
            ? new Date(entry.end)
            : entryStart
            ? new Date(entryStart.getTime() + FOCUS_SLOT_MS)
            : null;
          if (!entryStart || !entryEnd) {
            return false;
          }
          return entryEnd.getTime() > startMs && entryStart.getTime() < endMs;
        });
      }

      function hasScheduleConflict(startDate, endDate, ignoreId = null) {
        return Boolean(findScheduleConflict(startDate, endDate, ignoreId));
      }

      function resolveFocusConflicts({ save = false } = {}) {
        let changed = false;
        const movableEntries = schedule
          .filter(
            (item) =>
              item &&
              item.type !== "deadline" &&
              item.source !== "google" &&
              item.type !== "external"
          )
          .sort(
            (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
          );

        movableEntries.forEach((item) => {
          if (!item.start) {
            return;
          }

          let startDate = new Date(item.start);
          if (Number.isNaN(startDate.getTime())) {
            return;
          }
          let endDate = item.end
            ? new Date(item.end)
            : new Date(startDate.getTime() + FOCUS_SLOT_MS);

          let conflict = findScheduleConflict(startDate, endDate, item.id);
          if (!conflict) {
            return;
          }

          const associatedTask = tasks.find(
            (task) => String(task.id) === String(item.taskId)
          );

          let searchLimit = null;
          if (associatedTask && associatedTask.deadline) {
            const deadlineCandidate = new Date(associatedTask.deadline);
            if (!Number.isNaN(deadlineCandidate.getTime())) {
              searchLimit = new Date(deadlineCandidate);
              searchLimit.setHours(23, 59, 59, 999);
            }
          }

          let candidate = roundToNextSlot(
            conflict.end ? new Date(conflict.end) : new Date(endDate)
          );

          let attempts = 0;
          const maxAttempts = 4000;
          const globalLimit = new Date(startDate);
          globalLimit.setDate(globalLimit.getDate() + 60);

          while (attempts < maxAttempts && candidate < globalLimit) {
            attempts++;

            if (isWeekend(candidate)) {
              candidate = moveToNextWeekdayMorning(candidate);
              continue;
            }

            const window = getPreferredWindow(candidate);
            if (!window) {
              candidate = advanceToNextPreferredStart(candidate);
              continue;
            }

            const candidateEnd = new Date(candidate.getTime() + FOCUS_SLOT_MS);

            if (searchLimit && candidateEnd.getTime() > searchLimit.getTime()) {
              candidate = moveToNextWeekdayMorning(candidate);
              searchLimit = null;
              continue;
            }

            const blocker = findScheduleConflict(
              candidate,
              candidateEnd,
              item.id
            );

            if (!blocker) {
              item.start = candidate.toISOString();
              item.end = candidateEnd.toISOString();
              if (window.productivity) {
                item.productivity = window.productivity;
              }
              changed = true;
              break;
            }

            const nextBase = blocker.end ? new Date(blocker.end) : candidateEnd;
            candidate = roundToNextSlot(nextBase);
          }
        });

        if (changed) {
          sortScheduleEntries();
        }

        if (changed && save) {
          saveSchedule({ enforce: false });
          renderCalendar();
        }

        return changed;
      }

      // AI-powered schedule generation
      function generateSchedule(task) {
        const now = new Date();
        const deadline = new Date(task.deadline);
        if (Number.isNaN(deadline.getTime())) {
          console.warn("Invalid deadline provided for task", task);
          return;
        }
        const sessions = Math.ceil(task.totalHours * 2); // 30-min sessions

        schedule = schedule.filter((item) => {
          if (String(item.taskId) !== String(task.id)) {
            return true;
          }
          if (item.source === "google" || item.type === "external") {
            return true;
          }
          return false;
        });

        let currentDate = new Date(now.getTime() + 60 * 60 * 1000);
        currentDate = roundToNextSlot(currentDate);

        let sessionsScheduled = 0;
        let safetyCounter = 0;
        const maxIterations = 4000;

        while (
          sessionsScheduled < sessions &&
          currentDate < deadline &&
          safetyCounter < maxIterations
        ) {
          safetyCounter++;

          if (isWeekend(currentDate)) {
            currentDate = moveToNextWeekdayMorning(currentDate);
            continue;
          }

          const window = getPreferredWindow(currentDate);
          if (!window) {
            currentDate = advanceToNextPreferredStart(currentDate);
            continue;
          }

          const proposedStart = new Date(currentDate);
          const proposedEnd = new Date(proposedStart.getTime() + FOCUS_SLOT_MS);

          if (proposedEnd > deadline) {
            break;
          }

          const duplicate = schedule.some(
            (entry) =>
              String(entry.taskId) === String(task.id) &&
              entry.start === proposedStart.toISOString() &&
              entry.end === proposedEnd.toISOString()
          );

          const conflict = findScheduleConflict(proposedStart, proposedEnd);

          if (!duplicate && !conflict) {
            schedule.push({
              id: `${Date.now()}_${sessionsScheduled}_${Math.floor(
                Math.random() * 100000
              )}`,
              taskId: task.id,
              taskName: task.name,
              start: proposedStart.toISOString(),
              end: proposedEnd.toISOString(),
              type: "pomodoro",
              status: "scheduled",
              productivity: window.productivity,
              source: "focusflow",
            });
            sessionsScheduled++;
            currentDate = new Date(proposedEnd);
            continue;
          }

          if (conflict) {
            const conflictEnd = conflict.end
              ? new Date(conflict.end)
              : new Date(proposedEnd);
            currentDate = roundToNextSlot(conflictEnd);
          } else {
            currentDate = new Date(proposedEnd);
          }
        }

        schedule.push({
          id: `${Date.now()}_${Math.floor(Math.random() * 100000)}_deadline`,
          taskId: task.id,
          taskName: task.name + " (DEADLINE)",
          start: deadline.toISOString(),
          end: deadline.toISOString(),
          type: "deadline",
          status: "deadline",
          source: "focusflow",
        });

        saveSchedule();
      }

      function buildFallbackSuggestions() {
        const fallback = [];
        const now = new Date();
        const hour = now.getHours();

        const productivityScore = {
          morning: 0.9,
          afternoon: 0.7,
          evening: 0.6,
        };

        const urgentTasks = tasks
          .filter((t) => t.status !== "completed")
          .sort((a, b) => b.priority - a.priority)
          .slice(0, 3);

        urgentTasks.forEach((task) => {
          let suggestedTime = "";
          if (hour < 12 && productivityScore.morning > 0.8) {
            suggestedTime = "Now (High energy morning slot)";
          } else if (hour < 17) {
            suggestedTime = "This afternoon (2-4 PM)";
          } else {
            suggestedTime = "Tomorrow morning (9-11 AM)";
          }

          fallback.push({
            title: task.name,
            caption: suggestedTime,
            meta: `Priority: ${task.priority}/10`,
            taskId: task.id,
          });
        });

        return fallback;
      }

      // Generate AI suggestions for optimal work times
      function generateAISuggestions() {
        const suggestions = [];

        if (analyticsProcrastination) {
          const { atRiskTask, categoryRisk, slumpWindows } =
            analyticsProcrastination;

          if (atRiskTask) {
            suggestions.push({
              title: `Rescue: ${atRiskTask.name}`,
              caption: "Highest risk task",
              meta: [
                atRiskTask.deadline
                  ? `Due ${formatShortDate(atRiskTask.deadline)}`
                  : null,
                atRiskTask.priorityScore
                  ? `Priority ${Math.round(atRiskTask.priorityScore)}`
                  : null,
                atRiskTask.daysUntil != null
                  ? `${atRiskTask.daysUntil}d remaining`
                  : null,
              ]
                .filter(Boolean)
                .join(" â€¢ "),
              highlight: labelFromCategory(atRiskTask.category),
            });
          }

          if (Array.isArray(categoryRisk) && categoryRisk.length) {
            const topCategory = categoryRisk[0];
            suggestions.push({
              title: `Focus: ${labelFromCategory(
                topCategory.category,
                topCategory.label
              )}`,
              caption: "Category showing highest procrastination",
              meta: `Average risk ${topCategory.avgRisk}% â€¢ ${topCategory.openTasks} tasks open`,
            });
          }

          if (Array.isArray(slumpWindows) && slumpWindows.length) {
            const window = slumpWindows[0];
            suggestions.push({
              title: `Plan energy dip around ${window.hour}`,
              caption: "Schedule a quick reset or break",
              meta: `${window.sessions} sessions logged â€¢ Avg ${window.avgSessionMinutes}m`,
            });
          }
        }

        if (pendingYesterdayTasks && pendingYesterdayTasks.length) {
          pendingYesterdayTasks.slice(0, 3).forEach((task) => {
            suggestions.push({
              title: `Follow-up: ${task.name}`,
              caption: "Pending from yesterday",
              meta: [
                task.deadline
                  ? `Deadline ${formatShortDate(task.deadline)}`
                  : null,
                task.priorityScore
                  ? `Priority ${Math.round(task.priorityScore)}`
                  : null,
                task.category ? labelFromCategory(task.category) : null,
              ]
                .filter(Boolean)
                .join(" â€¢ "),
            });
          });
        }

        if (analyticsProductivity && analyticsProductivity.recentSessions) {
          const session = analyticsProductivity.recentSessions[0];
          if (session) {
            suggestions.push({
              title: `Repeat momentum: ${session.taskName}`,
              caption: `Last session ${formatShortDate(session.startedAt)}`,
              meta: `${formatMinutesToHours(
                session.durationMinutes
              )} â€¢ ${labelFromCategory(
                session.category,
                session.categoryLabel
              )}`,
            });
          }
        }

        if (!suggestions.length) {
          suggestions.push(...buildFallbackSuggestions());
        }

        renderAISuggestions(suggestions);
      }

      // Render AI suggestions
      function renderAISuggestions(suggestions) {
        const container = document.getElementById("suggestionsList");

        if (suggestions.length === 0) {
          container.innerHTML =
            '<p style="color: #718096; font-size: 0.9em;">No urgent tasks. Great job!</p>';
          return;
        }

        const cards = [];

        if (aiCoachMessage) {
          cards.push(`
            <div class="suggestion-item suggestion-item-coach">
              <strong>Coach Says</strong><br>
              <small style="color: #4a5568;">${aiCoachMessage}</small>
            </div>
          `);
        }

        suggestions.forEach((item) => {
          const title = item.title || item.task || "Focus Suggestion";
          const caption = item.caption || item.time || "";
          const meta = item.meta || item.reason || "";
          const badge = item.highlight
            ? `<span class="suggestion-badge">${item.highlight}</span>`
            : "";
          const isClickable = item.taskId != null;
          const clickAttr = isClickable
            ? `onclick="acceptSuggestion('${String(item.taskId).replace(
                /'/g,
                "\\'"
              )}')"`
            : "";
          const cardClasses = isClickable
            ? "suggestion-item"
            : "suggestion-item suggestion-item-static";

          cards.push(`
            <div class="${cardClasses}" ${clickAttr}>
              <strong>${title}</strong> ${badge}<br>
              ${
                caption
                  ? `<small style="color: #4a5568;">${caption}</small><br>`
                  : ""
              }
              ${meta ? `<small style="color: #718096;">${meta}</small>` : ""}
            </div>
          `);
        });

        if (cards.length === 0) {
          container.innerHTML =
            '<p style="color: #718096; font-size: 0.9em;">No urgent tasks. Great job!</p>';
          return;
        }

        container.innerHTML = cards.join("");
      }

      function renderProcrastinationInsights() {
        const panel = document.getElementById("procrastinationPanel");
        if (!panel) {
          return;
        }

        if (!analyticsProcrastination) {
          panel.classList.remove("active");
          return;
        }

        panel.classList.add("active");

        const riskState = analyticsProcrastination.riskState || "none";
        const riskIndexRaw =
          typeof analyticsProcrastination.riskIndex === "number"
            ? analyticsProcrastination.riskIndex
            : 0;
        const riskIndex = Math.max(0, Math.min(riskIndexRaw, 100));
        const scoreNode = document.getElementById("procrastinationScore");
        if (scoreNode) {
          scoreNode.textContent = `${riskIndex}%`;
          scoreNode.classList.remove(
            "state-low",
            "state-mid",
            "state-high",
            "state-none"
          );
          scoreNode.classList.add(`state-${riskState}`);
        }

        const messageNode = document.getElementById("procrastinationMessage");
        if (messageNode) {
          messageNode.textContent =
            analyticsProcrastination.message ||
            "No procrastination signals yetâ€”log more sessions to build insight.";
        }

        const tasksNode = document.getElementById("procrastinationTasks");
        if (tasksNode) {
          tasksNode.textContent = analyticsProcrastination.tasksAnalyzed || 0;
        }

        const missedNode = document.getElementById("procrastinationMissed");
        if (missedNode) {
          missedNode.textContent = analyticsProcrastination.missedTotal || 0;
        }

        renderHotspotList();
        renderCategoryRiskRows();
      }

      function renderHotspotList() {
        const container = document.getElementById("hotspotList");
        if (!container) {
          return;
        }

        const hotspots = Array.isArray(analyticsProcrastination?.missedHotspots)
          ? analyticsProcrastination.missedHotspots.slice(0, 5)
          : [];

        if (!hotspots.length) {
          container.innerHTML =
            '<p class="insight-empty">No missed slot patterns detected.</p>';
          return;
        }

        const totalMissed = analyticsProcrastination.missedTotal || 0;
        container.innerHTML = hotspots
          .map((item) => {
            const basePercent =
              typeof item.percent === "number"
                ? item.percent
                : totalMissed
                ? (item.count / totalMissed) * 100
                : 0;
            const safePercent = Math.max(0, Math.min(basePercent, 100));
            const label =
              item.label || `${item.day || ""} â€¢ ${item.time || ""}`;
            const descriptor = `${
              item.count || 0
            }Ã— missed â€¢ ${safePercent.toFixed(1)}%`;
            return `
              <div class="hotspot-item">
                <div class="hotspot-row">
                  <span>${label}</span>
                  <span>${safePercent.toFixed(1)}%</span>
                </div>
                <div class="hotspot-meta">${descriptor}</div>
                <div class="hotspot-meter">
                  <div class="hotspot-meter-fill" style="width: ${safePercent}%"></div>
                </div>
              </div>
            `;
          })
          .join("");
      }

      function renderCategoryRiskRows() {
        const container = document.getElementById("categoryRiskRows");
        if (!container) {
          return;
        }

        const categories = Array.isArray(
          analyticsProcrastination?.categoryRiskTopTen
        )
          ? analyticsProcrastination.categoryRiskTopTen.slice(0, 10)
          : Array.isArray(analyticsProcrastination?.categoryRisk)
          ? analyticsProcrastination.categoryRisk.slice(0, 10)
          : [];

        if (!categories.length) {
          container.innerHTML =
            '<p class="insight-empty">Need more data to calculate category risk.</p>';
          return;
        }

        container.innerHTML = categories
          .map((entry, index) => {
            const percentRaw = Number(entry.avgRisk) || 0;
            const percent = Math.max(0, Math.min(percentRaw, 100));
            const label = entry.label || labelFromCategory(entry.category);
            const openTasks = entry.openTasks || 0;
            return `
              <div class="category-risk-row">
                <div class="category-risk-rank">${index + 1}</div>
                <div class="category-risk-info">
                  <span class="category-risk-label">${label}</span>
                  <span class="category-risk-open">${openTasks} open</span>
                </div>
                <div class="category-risk-bar">
                  <div class="category-risk-bar-fill" style="width: ${percent}%"></div>
                </div>
                <div class="category-risk-value">${percent.toFixed(1)}%</div>
              </div>
            `;
          })
          .join("");
      }

      // Accept AI suggestion and start task
      function acceptSuggestion(taskId) {
        if (taskId == null) {
          return;
        }
        const numericId = Number(taskId);
        const lookupKey = Number.isNaN(numericId) ? String(taskId) : numericId;
        const task = tasks.find((t) => String(t.id) === String(lookupKey));
        if (task) {
          startPomodoro(task);
        }
      }

      // Start Pomodoro timer
      function startPomodoro(task) {
        currentTask = task;
        pomodoroTimeLeft = 25 * 60; // Reset to 25 minutes
        pomodoroPaused = false;

        document.getElementById("pomodoroTimer").style.display = "flex";
        document.getElementById(
          "timerLabel"
        ).textContent = `Working on: ${task.name}`;
        document.getElementById("pauseBtn").textContent = "â¸ Pause";
        document.getElementById("pauseBtn").className = "timer-btn pause";

        clearInterval(pomodoroInterval);
        pomodoroInterval = setInterval(() => {
          if (!pomodoroPaused) {
            pomodoroTimeLeft--;

            const minutes = Math.floor(pomodoroTimeLeft / 60);
            const seconds = pomodoroTimeLeft % 60;
            document.getElementById("timerDisplay").textContent = `${minutes
              .toString()
              .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

            if (pomodoroTimeLeft <= 0) {
              clearInterval(pomodoroInterval);
              handlePomodoroComplete();
            }

            // 20-minute check-in (5 minutes remaining)
            if (pomodoroTimeLeft === 5 * 60) {
              showNotification(
                "Check-in",
                "Are you still working on: " + task.name + "?"
              );
            }
          }
        }, 1000);

        showNotification("Task Started", `Working on: ${task.name}`);
      }

      // Toggle pause/resume
      function togglePauseResume() {
        pomodoroPaused = !pomodoroPaused;
        const btn = document.getElementById("pauseBtn");

        if (pomodoroPaused) {
          btn.textContent = "â–¶ Resume";
          btn.className = "timer-btn resume";
          showNotification(
            "Timer Paused",
            "Take a break. Click Resume when ready."
          );
        } else {
          btn.textContent = "â¸ Pause";
          btn.className = "timer-btn pause";
          showNotification("Timer Resumed", "Back to work!");
        }
      }

      // Stop Pomodoro timer
      function stopPomodoro() {
        clearInterval(pomodoroInterval);
        document.getElementById("pomodoroTimer").style.display = "none";

        if (currentTask) {
          // Calculate partial progress
          const minutesWorked = (25 * 60 - pomodoroTimeLeft) / 60;
          const hoursWorked = minutesWorked / 60;
          currentTask.completedHours += hoursWorked;

          stats.focusTime += hoursWorked;
          saveTasks();
          updateStats();
          renderTasks();

          showNotification(
            "Session Stopped",
            `Logged ${minutesWorked.toFixed(0)} minutes of work`
          );
        }

        currentTask = null;
        pomodoroPaused = false;
      }

      // Handle Pomodoro completion
      function handlePomodoroComplete() {
        if (currentTask) {
          currentTask.completedHours += 0.5;

          // Check if task is complete
          if (currentTask.completedHours >= currentTask.totalHours) {
            currentTask.status = "completed";
            stats.completed++;
            showNotification(
              "Task Completed! ðŸŽ‰",
              `Great job on: ${currentTask.name}`
            );
          } else {
            const remaining =
              currentTask.totalHours - currentTask.completedHours;
            showNotification(
              "Session Complete",
              `${remaining.toFixed(1)} hours remaining for: ${currentTask.name}`
            );
          }

          stats.focusTime += 0.5;
          saveTasks();
          updateStats();
          renderTasks();
          renderCalendar();
        }

        document.getElementById("pomodoroTimer").style.display = "none";
        currentTask = null;
        pomodoroPaused = false;
      }

      // Render tasks list
      function renderTasks() {
        const container = document.getElementById("taskList");
        const activeTasks = tasks.filter((t) => t.status !== "completed");

        if (activeTasks.length === 0) {
          container.innerHTML =
            '<p style="color: #718096;">No active tasks</p>';
          return;
        }

        container.innerHTML = activeTasks
          .map((task) => {
            const progress = (task.completedHours / task.totalHours) * 100;
            const daysLeft = Math.ceil(
              (task.deadline - new Date()) / (1000 * 60 * 60 * 24)
            );

            return `
                    <div class="task-item">
                        <div class="task-header">
                            <span class="task-name">${task.name}</span>
                            <span class="task-deadline" style="color: ${
                              daysLeft <= 1 ? "#e53e3e" : "#718096"
                            }">
                                ${daysLeft} days left
                            </span>
                        </div>
                        <div class="task-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <span style="font-size: 12px; color: #718096;">${Math.round(
                              progress
                            )}%</span>
                        </div>
                        <div style="margin-top: 8px;">
                            <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;" 
                                    onclick='startPomodoro(${JSON.stringify(
                                      task
                                    ).replace(/'/g, "&apos;")})'>
                                Start Session
                            </button>
                        </div>
                    </div>
                `;
          })
          .join("");
      }

      const CALENDAR_DAY_START = 0;
      const CALENDAR_DAY_END = 23;
      const DEFAULT_CALENDAR_VIEW_START = 8;
      const DEFAULT_CALENDAR_VIEW_END = 20;
      const CALENDAR_SLOT_HEIGHT = 60;

      function formatCalendarTime(date) {
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      }

      function formatHourLabel(hour) {
        const temp = new Date();
        temp.setHours(hour, 0, 0, 0);
        return temp.toLocaleTimeString([], { hour: "numeric", hour12: true });
      }

      // Render calendar with deadlines
      function renderCalendar() {
        const container = document.getElementById("weekView");
        if (!container) {
          return;
        }
        const now = new Date();
        const startOfWeek = new Date(currentWeekStart);
        const existingScroll = document.getElementById("calendarScroll");
        const previousScrollTop = existingScroll ? existingScroll.scrollTop : 0;
        const userAlreadyAdjusted =
          existingScroll && existingScroll.dataset.userAdjusted === "true";

        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const hours = Array.from(
          { length: CALENDAR_DAY_END - CALENDAR_DAY_START + 1 },
          (_, i) => CALENDAR_DAY_START + i
        );

        let headerHtml = '<div class="week-view-header"><div></div>';
        days.forEach((day, index) => {
          const date = new Date(startOfWeek);
          date.setDate(startOfWeek.getDate() + index);
          const isToday = date.toDateString() === now.toDateString();
          headerHtml += `<div class="day-header" style="${
            isToday ? "background: #e6fffa; border-color: #0bc5ea;" : ""
          }">
              ${day}<br><small>${date.getDate()}</small>
            </div>`;
        });
        headerHtml += "</div>";

        let bodyHtml = '<div class="week-view-grid">';
        bodyHtml += '<div class="time-column">';
        hours.forEach((hour) => {
          bodyHtml += `<div class="time-slot-label">${formatHourLabel(
            hour
          )}</div>`;
        });
        bodyHtml += "</div>";

        days.forEach((_, dayIndex) => {
          const dayDate = new Date(startOfWeek);
          dayDate.setDate(startOfWeek.getDate() + dayIndex);
          const dayStart = new Date(dayDate);
          dayStart.setHours(CALENDAR_DAY_START, 0, 0, 0);
          const dayEnd = new Date(dayDate);
          dayEnd.setHours(CALENDAR_DAY_END + 1, 0, 0, 0);
          const totalMinutes = (dayEnd - dayStart) / 60000;
          const isTodayColumn = dayDate.toDateString() === now.toDateString();

          let columnHtml = `<div class="day-column-body" data-day-start="${dayStart.toISOString()}" style="height: ${
            hours.length * CALENDAR_SLOT_HEIGHT
          }px">`;

          hours.forEach((_, hourIndex) => {
            const top = hourIndex * CALENDAR_SLOT_HEIGHT;
            columnHtml += `<div class="hour-divider" style="top: ${top}px"></div>`;
          });

          if (isTodayColumn && now >= dayStart && now <= dayEnd) {
            const minutesFromStart =
              (now.getTime() - dayStart.getTime()) / 60000;
            const top = (minutesFromStart / 60) * CALENDAR_SLOT_HEIGHT;
            columnHtml += `<div class="current-time-line" style="top: ${top}px;">
                <span class="current-time-label">${formatCalendarTime(
                  now
                )}</span>
              </div>`;
          }

          const dayEvents = schedule
            .filter((item) => {
              if (!item || item.type === "deadline") {
                return false;
              }
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              return eventEnd > dayStart && eventStart < dayEnd;
            })
            .map((item) => {
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              const rawStart = (eventStart - dayStart) / 60000;
              const rawEnd = (eventEnd - dayStart) / 60000;
              const boundedStart = Math.max(0, rawStart);
              const boundedEnd = Math.min(totalMinutes, rawEnd);
              if (boundedEnd <= 0 || boundedStart >= totalMinutes) {
                return null;
              }
              const effectiveEnd = Math.max(boundedEnd, boundedStart + 30);
              return {
                item,
                eventStart,
                eventEnd,
                startMinutes: boundedStart,
                endMinutes: Math.min(totalMinutes, effectiveEnd),
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

          const clusters = [];
          let activeCluster = null;
          dayEvents.forEach((event) => {
            if (!activeCluster || event.startMinutes >= activeCluster.maxEnd) {
              activeCluster = {
                events: [],
                maxEnd: event.endMinutes,
              };
              clusters.push(activeCluster);
            } else {
              activeCluster.maxEnd = Math.max(
                activeCluster.maxEnd,
                event.endMinutes
              );
            }
            activeCluster.events.push(event);
          });

          clusters.forEach((cluster) => {
            const activeEvents = [];
            cluster.columnCount = 0;

            cluster.events.sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

            cluster.events.forEach((event) => {
              for (let i = activeEvents.length - 1; i >= 0; i--) {
                if (activeEvents[i].endMinutes <= event.startMinutes) {
                  activeEvents.splice(i, 1);
                }
              }

              const usedColumns = activeEvents.map((evt) => evt.column);
              let columnIndex = 0;
              while (usedColumns.includes(columnIndex)) {
                columnIndex++;
              }

              event.column = columnIndex;
              activeEvents.push(event);
              cluster.columnCount = Math.max(
                cluster.columnCount,
                columnIndex + 1
              );
            });

            cluster.events.forEach((event) => {
              const columnCount = cluster.columnCount || 1;
              const top = (event.startMinutes / 60) * CALENDAR_SLOT_HEIGHT;
              const height = Math.max(
                ((event.endMinutes - event.startMinutes) / 60) *
                  CALENDAR_SLOT_HEIGHT,
                32
              );

              const columnWidth = Math.round((100 / columnCount) * 1000) / 1000;
              const leftPercent =
                Math.round(columnWidth * event.column * 1000) / 1000;
              const widthStyle =
                columnCount > 1
                  ? `calc(${columnWidth}% - 6px)`
                  : `calc(${columnWidth}% - 2px)`;
              const leftStyle = `${leftPercent}%`;

              const statusClass =
                event.item.status === "completed"
                  ? "completed"
                  : event.item.status === "in-progress"
                  ? "in-progress"
                  : "";
              const isExternal =
                event.item.source === "google" ||
                event.item.type === "external";
              const timeRange = `${formatCalendarTime(
                event.eventStart
              )} - ${formatCalendarTime(event.eventEnd)}`;

              const isDragEligible =
                !isExternal &&
                (!event.item.status || event.item.status === "scheduled");
              const isMissed =
                isTodayColumn &&
                !isExternal &&
                (!event.item.status || event.item.status === "scheduled") &&
                now > event.eventStart;
              const classList = ["scheduled-task"];
              if (statusClass) {
                classList.push(statusClass);
              }
              if (isExternal) {
                classList.push("external-event");
              }
              if (isMissed) {
                classList.push("missed");
              }
              const combinedClasses = classList.join(" ");
              const dragAttributes = isDragEligible
                ? ' draggable="true" data-draggable="true"'
                : "";
              const taskIdAttr =
                event.item.taskId !== undefined && event.item.taskId !== null
                  ? ` data-task-id="${event.item.taskId}"`
                  : "";
              const blockAttrs = `${dragAttributes} data-schedule-id="${event.item.id}" data-start-iso="${event.item.start}"${taskIdAttr}`;

              columnHtml += `<div class="${combinedClasses.trim()}"${blockAttrs} style="top: ${top}px; height: ${height}px; width: ${widthStyle}; left: ${leftStyle};" onclick="openScheduleModal('${
                event.item.id
              }')">
                <span class="event-title">${
                  event.item.taskName || "Scheduled Block"
                }</span>
                <span class="event-time">${timeRange}</span>
              </div>`;
            });
          });

          const dayDeadlines = tasks.filter((task) => {
            const deadline = new Date(task.deadline);
            return (
              deadline >= dayStart &&
              deadline <= dayEnd &&
              task.status !== "completed"
            );
          });

          dayDeadlines.forEach((task) => {
            const deadlineDate = new Date(task.deadline);
            const minutesFromStart = (deadlineDate - dayStart) / 60000;
            const top = Math.max(
              0,
              (minutesFromStart / 60) * CALENDAR_SLOT_HEIGHT - 12
            );
            columnHtml += `<div class="deadline-flag" style="top: ${top}px;">
                <span>ðŸ“</span>
                <span>${task.name}</span>
              </div>`;
          });

          columnHtml += "</div>";
          bodyHtml += columnHtml;
        });

        bodyHtml += "</div>";

        const scrollWrapper = `<div class="calendar-scroll" id="calendarScroll">${bodyHtml}</div>`;
        container.innerHTML = headerHtml + scrollWrapper;
        calendarScrollInitialized = false;
        if (userAlreadyAdjusted) {
          userAdjustedCalendarScroll = true;
        }

        applyCalendarScrollFocus();
        enableCalendarDragAndDrop();

        const newScrollContainer = document.getElementById("calendarScroll");
        if (newScrollContainer && userAlreadyAdjusted) {
          newScrollContainer.scrollTop = previousScrollTop;
          newScrollContainer.dataset.userAdjusted = "true";
          userAdjustedCalendarScroll = true;
        }

        const weekEnd = new Date(startOfWeek);
        weekEnd.setDate(startOfWeek.getDate() + 6);
        document.getElementById(
          "currentWeek"
        ).textContent = `${startOfWeek.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}`;
      }

      // Drag-and-drop interactions for calendar focus blocks
      function enableCalendarDragAndDrop() {
        const draggableBlocks = document.querySelectorAll(
          '.scheduled-task[data-draggable="true"]'
        );
        draggableBlocks.forEach((block) => {
          block.addEventListener("dragstart", handleBlockDragStart);
          block.addEventListener("dragend", handleBlockDragEnd);
        });

        const columns = document.querySelectorAll(".day-column-body");
        columns.forEach((column) => {
          column.addEventListener("dragover", handleCalendarDragOver);
          column.addEventListener("dragleave", handleCalendarDragLeave);
          column.addEventListener("drop", handleCalendarDrop);
        });
      }

      function handleBlockDragStart(event) {
        const target = event.currentTarget;
        const scheduleId = target.dataset.scheduleId;
        if (!scheduleId) {
          event.preventDefault();
          return;
        }

        draggedScheduleId = scheduleId;
        target.classList.add("dragging");
        if (event.dataTransfer) {
          event.dataTransfer.effectAllowed = "move";
          event.dataTransfer.setData("text/plain", scheduleId);
        }
      }

      function handleBlockDragEnd(event) {
        event.currentTarget.classList.remove("dragging");
        clearCalendarDragState();
        draggedScheduleId = null;
      }

      function handleCalendarDragOver(event) {
        if (!draggedScheduleId) {
          return;
        }
        event.preventDefault();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = "move";
        }
        event.currentTarget.classList.add("drag-over");
      }

      function handleCalendarDragLeave(event) {
        event.currentTarget.classList.remove("drag-over");
      }

      function handleCalendarDrop(event) {
        if (!draggedScheduleId) {
          return;
        }
        event.preventDefault();

        const column = event.currentTarget;
        column.classList.remove("drag-over");
        const dayStartIso = column.dataset.dayStart;
        if (!dayStartIso) {
          resetDragState(true);
          return;
        }

        const dayStart = new Date(dayStartIso);
        if (Number.isNaN(dayStart.getTime())) {
          resetDragState(true);
          return;
        }

        const scheduleItem = schedule.find(
          (item) => String(item.id) === String(draggedScheduleId)
        );

        if (
          !scheduleItem ||
          scheduleItem.source === "google" ||
          scheduleItem.type === "external"
        ) {
          resetDragState(true);
          return;
        }

        const rect = column.getBoundingClientRect();
        const relativeY = event.clientY - rect.top;
        const clampedY = Math.max(0, Math.min(relativeY, rect.height));
        const halfHourHeight = CALENDAR_SLOT_HEIGHT / 2;
        const slotIndex = Math.floor(clampedY / halfHourHeight);
        const minutesFromStart = slotIndex * 30;

        const newStart = new Date(
          dayStart.getTime() + minutesFromStart * 60000
        );
        newStart.setSeconds(0, 0);

        const currentStart = new Date(scheduleItem.start);
        const currentEnd = scheduleItem.end
          ? new Date(scheduleItem.end)
          : new Date(currentStart.getTime() + FOCUS_SLOT_MS);
        const durationMs = Math.max(
          currentEnd.getTime() - currentStart.getTime(),
          FOCUS_SLOT_MS
        );
        const newEnd = new Date(newStart.getTime() + durationMs);

        const relatedTask = scheduleItem.taskId
          ? tasks.find(
              (task) => String(task.id) === String(scheduleItem.taskId)
            )
          : null;

        if (relatedTask && relatedTask.deadline) {
          const deadlineDate = new Date(relatedTask.deadline);
          if (!Number.isNaN(deadlineDate.getTime())) {
            const deadlineEnd = new Date(deadlineDate);
            deadlineEnd.setHours(23, 59, 59, 999);
            if (newEnd.getTime() > deadlineEnd.getTime()) {
              showDeadlineErrorModal();
              resetDragState(true);
              return;
            }
          }
        }

        if (hasScheduleConflict(newStart, newEnd, scheduleItem.id)) {
          showNotification(
            "Slot Occupied",
            "That time already contains an event. Try a different slot."
          );
          resetDragState(true);
          return;
        }

        scheduleItem.start = newStart.toISOString();
        scheduleItem.end = newEnd.toISOString();

        clearCalendarDragState();
        draggedScheduleId = null;
        sortScheduleEntries();
        saveSchedule({ enforce: false });
        renderCalendar();
      }

      function clearCalendarDragState() {
        document
          .querySelectorAll(".day-column-body.drag-over")
          .forEach((column) => column.classList.remove("drag-over"));
      }

      function resetDragState(shouldRerender = false) {
        clearCalendarDragState();
        document
          .querySelectorAll(".scheduled-task.dragging")
          .forEach((block) => block.classList.remove("dragging"));
        draggedScheduleId = null;
        if (shouldRerender) {
          renderCalendar();
        }
      }

      function changeWeek(offset) {
        currentWeekStart.setDate(currentWeekStart.getDate() + offset * 7);
        currentWeekStart = getStartOfWeek(currentWeekStart);
        renderCalendar();
        if (googleAccountAuthenticated) {
          const eventsContainer = document.getElementById("calendarEvents");
          if (eventsContainer) {
            eventsContainer.innerHTML = "<p>Loading events...</p>";
          }
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) =>
              console.error("Failed to refresh calendar events", error)
            );
        }
      }

      // Handle click on scheduled item
      function handleScheduleClick(scheduleId) {
        openScheduleModal(String(scheduleId));
      }

      function updateGoogleAuthUI() {
        const authButton = document.getElementById("googleAuthButton");
        const authStatus = document.getElementById("authStatus");
        const refreshBtn = document.getElementById("refreshEventsBtn");
        const eventsContainer = document.getElementById("calendarEvents");
        const content = document.getElementById("googleCalContent");

        if (authButton) {
          if (googleAccountAuthenticated) {
            authButton.textContent = "Disconnect Google Calendar";
            authButton.onclick = logoutGoogle;
          } else {
            authButton.textContent = "Connect Google Calendar";
            authButton.onclick = initiateGoogleAuth;
          }
        }

        if (authStatus) {
          if (googleAccountAuthenticated) {
            authStatus.textContent = "Authenticated";
            authStatus.classList.add("success");
            authStatus.classList.remove("warning");
          } else {
            authStatus.textContent = "Not Connected";
            authStatus.classList.remove("success");
            authStatus.classList.add("warning");
          }
        }

        if (refreshBtn) {
          refreshBtn.style.display = googleAccountAuthenticated
            ? "inline-flex"
            : "none";
        }

        if (content) {
          if (!googleAccountAuthenticated) {
            setGoogleCalendarExpanded(false);
          } else if (localStorage.getItem(GOOGLE_CAL_STATE_KEY) === null) {
            setGoogleCalendarExpanded(true);
          }
        }

        if (eventsContainer) {
          if (googleAccountAuthenticated) {
            if (!eventsContainer.dataset.loadedOnce) {
              eventsContainer.innerHTML = "<p>Loading events...</p>";
            }
          } else {
            delete eventsContainer.dataset.loadedOnce;
            eventsContainer.innerHTML =
              '<p style="color: #718096">Connect from the Home page to sync your Google Calendar.</p>';
          }
        }
      }

      function logoutGoogle() {
        fetch("/logout", { method: "POST" })
          .then(() => {
            googleAccountAuthenticated = false;
            calendarApiLoaded = false;
            if (typeof gapi !== "undefined" && gapi.client) {
              gapi.client.setToken(null);
            }
            schedule = schedule.filter(
              (item) => item.source !== "google" && item.type !== "external"
            );
            saveSchedule();
            renderCalendar();
            updateGoogleAuthUI();
            window.location.reload();
          })
          .catch((error) => {
            console.error("Failed to logout from Google", error);
            showNotification(
              "Logout Failed",
              "Could not disconnect Google right now. Please try again."
            );
          });
      }

      function refreshGoogleEvents() {
        if (!googleAccountAuthenticated) {
          showNotification(
            "Connect Google",
            "Link your Google Calendar from the Home page first."
          );
          return;
        }

        const eventsContainer = document.getElementById("calendarEvents");
        if (eventsContainer) {
          eventsContainer.innerHTML = "<p>Refreshing events...</p>";
        }

        ensureCalendarApiLoaded()
          .then(() => loadCalendarEvents(currentWeekStart))
          .catch((error) => {
            console.error("Failed to refresh Google events", error);
            showNotification(
              "Refresh Failed",
              "Unable to refresh Google Calendar events right now."
            );
          });
      }

      function openScheduleModal(scheduleId) {
        const modal = document.getElementById("eventModal");
        if (!modal) {
          return;
        }

        const item = schedule.find(
          (entry) => String(entry.id) === String(scheduleId)
        );
        if (!item) {
          return;
        }

        activeScheduleId = item.id;

        const start = new Date(item.start);
        const end = item.end
          ? new Date(item.end)
          : new Date(start.getTime() + 30 * 60 * 1000);

        document.getElementById("modalTitle").textContent =
          item.taskName || "Scheduled Block";
        document.getElementById(
          "modalTime"
        ).textContent = `${start.toLocaleString()} - ${end.toLocaleTimeString(
          [],
          {
            hour: "2-digit",
            minute: "2-digit",
          }
        )}`;

        document.getElementById("modalSource").textContent =
          item.source === "google" || item.type === "external"
            ? "Google Calendar"
            : "FocusFlow";
        document.getElementById("modalStatus").textContent = (
          item.status || "scheduled"
        ).replace(/-/g, " ");
        document.getElementById("modalDuration").textContent = formatDuration(
          end.getTime() - start.getTime()
        );

        const locationRow = document.getElementById("modalLocationRow");
        if (item.location) {
          locationRow.style.display = "flex";
          document.getElementById("modalLocation").textContent = item.location;
        } else {
          locationRow.style.display = "none";
        }

        if (item.source === "google" || item.type === "external") {
          document.getElementById("modalDescription").textContent =
            "Managed via Google Calendar. Hide it here or update it directly in Google.";
          document.getElementById("modalStartBtn").style.display = "none";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Hide This Event";
        } else {
          const relatedTask = tasks.find((t) => t.id === item.taskId);
          const priorityInfo =
            relatedTask && typeof relatedTask.priority === "number"
              ? ` Priority ${relatedTask.priority}/10.`
              : "";
          const description = relatedTask
            ? `Focus block for "${relatedTask.name}".${priorityInfo}`
            : "Focus block scheduled via AI.";
          document.getElementById("modalDescription").textContent = description;
          document.getElementById("modalStartBtn").style.display =
            "inline-flex";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Delete Block";
        }

        modal.classList.add("show");
      }

      function closeEventModal() {
        const modal = document.getElementById("eventModal");
        if (modal) {
          modal.classList.remove("show");
        }
        activeScheduleId = null;
      }

      function handleModalOverlayClick(event) {
        if (event.target && event.target.id === "eventModal") {
          closeEventModal();
        }
      }

      function startFocusFromModal() {
        if (activeScheduleId === null) {
          return;
        }
        const item = schedule.find(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (!item || !item.taskId) {
          return;
        }
        const task = tasks.find((t) => t.id === item.taskId);
        if (!task) {
          return;
        }

        startPomodoro(task);
        item.status = "in-progress";
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function deleteScheduleItem() {
        if (activeScheduleId === null) {
          return;
        }
        const index = schedule.findIndex(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (index === -1) {
          closeEventModal();
          return;
        }

        const [removed] = schedule.splice(index, 1);
        if (removed && removed.source === "google" && removed.externalId) {
          dismissedGoogleEvents.add(String(removed.externalId));
          saveDismissedGoogleEvents();
        }
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function formatDuration(milliseconds) {
        const totalMinutes = Math.max(1, Math.round(milliseconds / 60000));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0 && minutes > 0) {
          return `${hours}h ${minutes}m`;
        }
        if (hours > 0) {
          return `${hours}h`;
        }
        return `${minutes}m`;
      }

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeEventModal();
          const entry = document.getElementById("floatingTaskEntry");
          if (entry && entry.classList.contains("open")) {
            closeFloatingTaskForm();
          }
          const notificationModal = document.getElementById(
            "notificationPermissionModal"
          );
          if (
            notificationModal &&
            notificationModal.classList.contains("show")
          ) {
            hideNotificationPermissionModal();
          }
        }
      });

      // Google Calendar Integration
      function loadGoogleAPI() {
        if (typeof gapi === "undefined" || !gapi.load) {
          setTimeout(loadGoogleAPI, 100);
          return;
        }
        gapi.load("client:auth2", initGoogleClient);
      }

      function initGoogleClient() {
        gapi.load("client", () => {
          gapi.client
            .init({
              apiKey: GOOGLE_API_KEY,
              discoveryDocs: DISCOVERY_DOCS,
            })
            .then(() => authenticateGapiWithFlaskToken());
        });
      }

      function authenticateGapiWithFlaskToken() {
        if (!gapi.client || !gapi.client.setToken) {
          setTimeout(authenticateGapiWithFlaskToken, 500);
          return;
        }
        fetch("/get_gapi_token")
          .then((r) => r.json())
          .then((tokenData) => {
            gapi.client.setToken({ access_token: tokenData.access_token });
            ensureCalendarApiLoaded()
              .then(() => updateSigninStatus(true))
              .catch((error) => {
                console.error("Failed to load Google Calendar API", error);
              });
          });
      }

      function updateSigninStatus(isSignedIn) {
        if (isSignedIn && gapi.client.getToken()) {
          googleAccountAuthenticated = true;
          updateGoogleAuthUI();
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) => {
              console.error("Google Calendar API not ready", error);
            });
        }
      }

      function ensureCalendarApiLoaded() {
        if (calendarApiLoaded) {
          return Promise.resolve();
        }
        if (!gapi.client || !gapi.client.load) {
          return Promise.reject(new Error("gapi client not ready"));
        }
        return gapi.client.load("calendar", "v3").then(() => {
          calendarApiLoaded = true;
        });
      }

      //function initiateGoogleAuth() {
      //  gapi.auth2.getAuthInstance().signIn();
      //}

      function initiateGoogleAuth() {
        // Use Flask OAuth instead of gapi
        window.location.href = "/auth";
      }

      function loadCalendarEvents(weekStart = currentWeekStart) {
        const startWindow = new Date(weekStart);
        startWindow.setHours(0, 0, 0, 0);
        const endWindow = new Date(weekStart);
        endWindow.setDate(endWindow.getDate() + 7);
        endWindow.setHours(23, 59, 59, 999);
        gapi.client.calendar.events
          .list({
            calendarId: "primary",
            timeMin: startWindow.toISOString(),
            timeMax: endWindow.toISOString(),
            showDeleted: false,
            singleEvents: true,
            maxResults: 250,
            orderBy: "startTime",
          })
          .then((response) => {
            const events = response.result.items;
            displayGoogleEvents(events);
            extractDeadlinesFromEvents(events);
            mergeGoogleEventsIntoSchedule(events);
          });
      }

      function displayGoogleEvents(events) {
        const container = document.getElementById("calendarEvents");
        if (!container) {
          return;
        }
        container.dataset.loadedOnce = "true";
        if (events.length > 0) {
          container.innerHTML = "<h4>Upcoming Google Calendar Events:</h4>";
          events.forEach((event) => {
            const when = event.start.dateTime || event.start.date;
            container.innerHTML += `
                        <div style="padding: 8px; background: #f7fafc; margin: 5px 0; border-radius: 6px;">
                            <strong>${event.summary}</strong><br>
                            <small>${new Date(when).toLocaleString()}</small>
                            ${
                              event.description &&
                              event.description.includes("deadline")
                                ? `<button onclick="importAsTask('${event.summary}', '${when}')" 
                                 style="margin-left: 10px; padding: 2px 8px; background: #667eea; 
                                 color: white; border: none; border-radius: 4px; cursor: pointer;">
                                 Import as Task
                                </button>`
                                : ""
                            }
                        </div>
                    `;
          });
        } else {
          container.innerHTML = "<p>No upcoming events found.</p>";
        }
      }

      function extractDeadlinesFromEvents(events) {
        events.forEach((event) => {
          // Check if event title or description contains deadline keywords
          const deadlineKeywords = [
            "deadline",
            "due",
            "submit",
            "delivery",
            "final",
          ];
          const hasDeadline = deadlineKeywords.some(
            (keyword) =>
              (event.summary &&
                event.summary.toLowerCase().includes(keyword)) ||
              (event.description &&
                event.description.toLowerCase().includes(keyword))
          );

          if (hasDeadline) {
            console.log("Found potential deadline:", event.summary);
            // Auto-suggest as task
            showNotification(
              "Deadline Detected",
              `Found deadline in calendar: "${event.summary}". Click to import.`
            );
          }
        });
      }

      function mergeGoogleEventsIntoSchedule(events) {
        if (!Array.isArray(events)) {
          return;
        }

        const normalizedEvents = events
          .filter((event) => event && event.id && event.start)
          .map((event) => ({ ...event, id: String(event.id) }))
          .filter((event) => !dismissedGoogleEvents.has(event.id));
        const incomingIds = new Set(normalizedEvents.map((event) => event.id));

        schedule = schedule.filter((item) => {
          if (item && item.source === "google" && item.externalId) {
            return incomingIds.has(String(item.externalId));
          }
          return true;
        });

        normalizedEvents.forEach((event) => {
          const alreadySynced = schedule.some(
            (item) =>
              item.source === "google" &&
              String(item.externalId) === String(event.id)
          );
          if (alreadySynced) {
            return;
          }

          const startIso =
            event.start.dateTime ||
            (event.start.date ? `${event.start.date}T09:00:00` : null);
          if (!startIso) {
            return;
          }

          const endIso =
            event.end?.dateTime ||
            (event.end?.date ? `${event.end.date}T17:00:00` : null);

          const startDate = new Date(startIso);
          const endDate = endIso
            ? new Date(endIso)
            : new Date(startDate.getTime() + 60 * 60 * 1000);

          schedule.push({
            id: Date.now() + Math.floor(Math.random() * 1000),
            externalId: event.id,
            source: "google",
            taskId: null,
            taskName: `${event.summary || "Google Event"}`,
            start: startDate.toISOString(),
            end: endDate.toISOString(),
            type: "external",
            status: "scheduled",
            location: event.location || "",
          });
        });

        schedule.sort(
          (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
        );

        saveSchedule();
        renderCalendar();
      }

      function importAsTask(eventName, eventTime) {
        document.getElementById("taskName").value = eventName;
        document.getElementById("deadline").value = new Date(eventTime)
          .toISOString()
          .slice(0, 16);
        showNotification(
          "Task Imported",
          "Deadline imported from Google Calendar. Adjust hours and add task."
        );
      }

      // Show notification
      function showNotification(title, body) {
        const notification = document.getElementById("notification");
        document.getElementById("notificationHeader").textContent = title;
        document.getElementById("notificationBody").textContent = body;
        notification.classList.add("show");

        // Auto-hide after 5 seconds
        setTimeout(() => {
          notification.classList.remove("show");
        }, 5000);

        // Browser notification if permitted
        if (Notification.permission === "granted") {
          new Notification(title, { body, icon: "ðŸŽ¯" });
        }
      }

      function showDeadlineErrorModal() {
        showErrorModal(
          "Can't place block because the deadline would have passed by then."
        );
      }

      function showErrorModal(message) {
        const modal = document.getElementById("errorModal");
        if (!modal) {
          return;
        }
        const messageNode = document.getElementById("errorModalMessage");
        if (messageNode) {
          messageNode.textContent = message;
        }
        modal.classList.add("show");
      }

      function closeErrorModal() {
        const modal = document.getElementById("errorModal");
        if (modal) {
          modal.classList.remove("show");
        }
      }

      function handleErrorModalOverlayClick(event) {
        if (event.target && event.target.id === "errorModal") {
          closeErrorModal();
        }
      }

      // Handle notification actions
      function handleNotification(action) {
        const notification = document.getElementById("notification");
        notification.classList.remove("show");

        if (action === "accept" && currentTask) {
          // Continue with current task
        } else if (action === "reschedule") {
          // Move to next available slot
          generateAISuggestions();
        } else if (action === "decline") {
          // Track reason (simplified for MVP)
          const reasons = [
            "Too tired",
            "Emergency came up",
            "Need a break",
            "Other priority",
          ];
          const reason = reasons[Math.floor(Math.random() * reasons.length)];
          console.log("Task declined:", reason);
        }
      }

      function startNotificationChecker() {
        runNotificationSweep();
        if (!window.focusflowNotificationInterval) {
          window.focusflowNotificationInterval = setInterval(
            runNotificationSweep,
            60000
          );
        }

        if (!window.focusflowAiInterval) {
          setTimeout(() => {
            runAiInsights();
            window.focusflowAiInterval = setInterval(
              runAiInsights,
              45 * 60 * 1000
            );
          }, 5 * 60 * 1000);
        }
      }

      function runNotificationSweep() {
        const now = new Date();
        checkUpcomingFocusBlocks(now);
        checkDeadlineAlerts(now);
        checkMissedTasks(now);
        updateProductivityMeter();
        if (!draggedScheduleId) {
          renderCalendar();
        }
      }

      function checkUpcomingFocusBlocks(now) {
        const toleranceMs = 60 * 1000;
        schedule.forEach((item) => {
          if (!item || item.type === "deadline") {
            return;
          }
          if (item.status && item.status !== "scheduled") {
            return;
          }
          const startTime = new Date(item.start);
          const diff = now.getTime() - startTime.getTime();
          if (diff >= 0 && diff <= toleranceMs) {
            const key = String(item.id);
            if (!notifiedSlots.has(key)) {
              const label = item.taskName || "Scheduled Block";
              showNotification(
                "Focus Block Starting",
                `"${label}" is starting now. Dive in!`
              );
              notifiedSlots.add(key);
              saveNotifiedSlots();
            }
          }
        });
      }

      function checkDeadlineAlerts(now) {
        const todayKey = now.toISOString().slice(0, 10);
        if (now.getHours() >= 12) {
          return;
        }
        const startOfToday = new Date(now);
        startOfToday.setHours(0, 0, 0, 0);
        const endOfToday = new Date(startOfToday);
        endOfToday.setHours(23, 59, 59, 999);
        const nowTime = now.getTime();
        const minInterval = 5 * 60 * 1000;
        if (
          window.focusflowLastDeadlineCheck &&
          nowTime - window.focusflowLastDeadlineCheck < minInterval
        ) {
          return;
        }
        window.focusflowLastDeadlineCheck = nowTime;
        notifiedDeadlines = new Set(
          Array.from(notifiedDeadlines).filter((key) => key.endsWith(todayKey))
        );
        saveNotifiedDeadlines();
        tasks.forEach((task) => {
          if (!task || task.status === "completed") {
            return;
          }
          const deadlineDate = new Date(task.deadline);
          if (
            Number.isNaN(deadlineDate.getTime()) ||
            deadlineDate < startOfToday ||
            deadlineDate > endOfToday ||
            !isSameDay(deadlineDate, now)
          ) {
            return;
          }
          const key = `${task.id}_${todayKey}`;
          if (!notifiedDeadlines.has(key)) {
            showNotification(
              "Deadline Today",
              `"${task.name}" is due today. Make sure it lands on your schedule.`
            );
            notifiedDeadlines.add(key);
            saveNotifiedDeadlines();
          }
        });
      }

      function checkMissedTasks(now) {
        const todayKey = now.toISOString().slice(0, 10);
        if (lastMissedNotificationDate === todayKey) {
          return;
        }

        const startOfToday = new Date(now);
        startOfToday.setHours(0, 0, 0, 0);
        const startOfYesterday = new Date(startOfToday);
        startOfYesterday.setDate(startOfYesterday.getDate() - 1);
        const endOfYesterday = new Date(startOfToday.getTime() - 1);

        const missed = schedule.filter((item) => {
          if (!item || item.type === "deadline") {
            return false;
          }
          if (item.status && item.status !== "scheduled") {
            return false;
          }
          const startTime = new Date(item.start);
          return startTime >= startOfYesterday && startTime <= endOfYesterday;
        });

        if (missed.length > 0) {
          const message =
            missed.length === 1
              ? `You missed "${missed[0].taskName}" yesterday. Consider rescheduling it.`
              : `You missed ${missed.length} focus blocks yesterday. Review and reschedule them.`;
          showNotification(
            missed.length === 1 ? "Missed Focus Block" : "Missed Focus Blocks",
            message
          );
        }

        lastMissedNotificationDate = todayKey;
        localStorage.setItem(
          storageKey("lastMissedNotificationDate"),
          lastMissedNotificationDate
        );
      }

      function runAiInsights() {
        if (Date.now() - lastAiNotification < 15 * 60 * 1000) {
          return;
        }

        const activeTasks = tasks
          .filter((task) => task && task.status !== "completed")
          .map((task) => ({
            name: task.name,
            deadline: (() => {
              const parsed = new Date(task.deadline);
              return Number.isNaN(parsed.getTime())
                ? null
                : parsed.toISOString();
            })(),
            priority: task.priority || null,
            remainingHours: Math.max(
              0,
              (task.totalHours || 0) - (task.completedHours || 0)
            ),
          }));

        const upcomingBlocks = schedule
          .filter((item) => item && item.type !== "deadline")
          .map((item) => ({
            name: item.taskName,
            start: (() => {
              const parsed = new Date(item.start);
              return Number.isNaN(parsed.getTime())
                ? null
                : parsed.toISOString();
            })(),
            end: (() => {
              if (!item.end) {
                return null;
              }
              const parsedEnd = new Date(item.end);
              return Number.isNaN(parsedEnd.getTime())
                ? null
                : parsedEnd.toISOString();
            })(),
            source: item.source || "focusflow",
            status: item.status || "scheduled",
          }));

        if (activeTasks.length === 0 && upcomingBlocks.length === 0) {
          return;
        }

        lastAiNotification = Date.now();
        localStorage.setItem(
          storageKey("lastAiNotification"),
          String(lastAiNotification)
        );

        fetch("/ai_insights", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            timestamp: new Date().toISOString(),
            tasks: activeTasks.slice(0, 20),
            schedule: upcomingBlocks.slice(0, 40),
          }),
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("AI insights unavailable");
            }
            return response.json();
          })
          .then((data) => {
            aiCoachMessage = data && data.message ? data.message.trim() : null;
            pendingYesterdayTasks = Array.isArray(data.pendingYesterday)
              ? data.pendingYesterday
              : [];
            generateAISuggestions();
            if (aiCoachMessage) {
              showNotification("AI Coach", aiCoachMessage);
            }
          })
          .catch((error) => {
            console.error("Failed to fetch AI insight", error);
          });
      }

      function isSameDay(a, b) {
        return (
          a.getFullYear() === b.getFullYear() &&
          a.getMonth() === b.getMonth() &&
          a.getDate() === b.getDate()
        );
      }

      function calculateStreak() {
        const completedDays = new Set();
        schedule.forEach((item) => {
          if (item.status !== "completed") return;
          const reference = item.end || item.start;
          if (!reference) return;
          const completedDate = new Date(reference);
          if (Number.isNaN(completedDate.getTime())) return;
          completedDays.add(completedDate.toDateString());
        });

        let streak = 0;
        const cursor = new Date();
        while (completedDays.has(cursor.toDateString())) {
          streak += 1;
          cursor.setDate(cursor.getDate() - 1);
        }
        return streak;
      }

      function updateStats() {
        if (analyticsProductivity) {
          applyAnalyticsStats();
          updateProductivityMeter();
          return;
        }

        const completedTasks = tasks.filter(
          (task) => task.status === "completed"
        ).length;
        const totalHours = schedule.reduce((acc, item) => {
          if (!item.start || !item.end) {
            return acc;
          }
          const start = new Date(item.start);
          const end = new Date(item.end);
          if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
            return acc;
          }
          const duration = Math.max((end - start) / (1000 * 60 * 60), 0);
          return item.status === "completed" ? acc + duration : acc;
        }, 0);

        stats = {
          completed: completedTasks,
          focusTime: Number(totalHours.toFixed(2)),
          streak: calculateStreak(),
          totalTasks: tasks.length,
        };

        saveStorage("stats", stats);

        const completedNode = document.getElementById("tasksCompleted");
        if (completedNode) {
          completedNode.textContent = stats.completed;
        }

        const focusNode = document.getElementById("focusTime");
        if (focusNode) {
          focusNode.textContent = `${stats.focusTime.toFixed(1)}h`;
        }

        const streakNode = document.getElementById("streakDays");
        if (streakNode) {
          streakNode.textContent = stats.streak;
        }

        const completionRate =
          stats.totalTasks > 0
            ? Math.round((stats.completed / stats.totalTasks) * 100)
            : 0;
        const completionNode = document.getElementById("completionRate");
        if (completionNode) {
          completionNode.textContent = `${completionRate}%`;
        }

        updateProductivityMeter();
      }

      function calculateProductivityScore(referenceDate = new Date()) {
        const now =
          referenceDate instanceof Date
            ? new Date(referenceDate)
            : new Date(referenceDate);
        if (Number.isNaN(now.getTime())) {
          return { score: 5, status: "mid" };
        }

        const startOfDay = new Date(now);
        startOfDay.setHours(0, 0, 0, 0);
        const endOfDay = new Date(startOfDay);
        endOfDay.setHours(23, 59, 59, 999);

        let totalMinutes = 0;
        let expectedMinutes = 0;
        let completedMinutes = 0;
        let earliestSlot = null;

        schedule.forEach((item) => {
          if (
            !item ||
            item.type === "deadline" ||
            item.source === "google" ||
            item.type === "external"
          ) {
            return;
          }

          const start = new Date(item.start);
          if (Number.isNaN(start.getTime())) {
            return;
          }

          if (start < startOfDay || start > endOfDay) {
            return;
          }

          const end = item.end
            ? new Date(item.end)
            : new Date(start.getTime() + FOCUS_SLOT_MS);
          if (Number.isNaN(end.getTime())) {
            return;
          }

          const durationMinutes = Math.max(
            (end.getTime() - start.getTime()) / 60000,
            FOCUS_SLOT_MINUTES
          );

          totalMinutes += durationMinutes;
          if (start <= now) {
            expectedMinutes += durationMinutes;
          }

          if (!earliestSlot || start < earliestSlot) {
            earliestSlot = start;
          }

          if (item.status === "completed") {
            completedMinutes += durationMinutes;
            return;
          }

          if (item.status === "in-progress") {
            const elapsedMs = Math.max(
              0,
              Math.min(now.getTime(), end.getTime()) - start.getTime()
            );
            const creditMinutes = Math.min(durationMinutes, elapsedMs / 60000);
            completedMinutes += creditMinutes;
          }
        });

        if (totalMinutes === 0) {
          return { score: 0, status: "none" };
        }

        let score;
        if (expectedMinutes === 0) {
          const baselineRatio =
            totalMinutes > 0 ? completedMinutes / totalMinutes : 0;
          score = Math.round(Math.max(0, Math.min(1, baselineRatio)) * 10);
          score = Math.max(5, Math.min(7, score));
          if (earliestSlot && earliestSlot > now) {
            score = Math.max(score, 6);
          }
        } else {
          const ratio = completedMinutes / Math.max(expectedMinutes, 1);
          score = Math.round(Math.max(0, Math.min(1, ratio)) * 10);
        }

        score = Math.max(0, Math.min(10, score));

        let status = "mid";
        if (score <= 4) {
          status = "low";
        } else if (score >= 8) {
          status = "high";
        }

        return { score, status };
      }

      function updateProductivityMeter() {
        const meter = document.getElementById("productivityMeter");
        const scoreNode = document.getElementById("productivityScore");
        const messageNode = document.getElementById("productivityMessage");
        const barNode = document.getElementById("productivityBar");
        const botNode = document.getElementById("productivityBot");

        if (!meter || !scoreNode || !messageNode || !barNode || !botNode) {
          return;
        }

        if (analyticsProductivity) {
          const state = analyticsProductivity.state || "none";
          const config = PRODUCTIVITY_MEDIA[state] || PRODUCTIVITY_MEDIA.mid;
          const rawScore = Math.max(
            0,
            Math.min(
              typeof analyticsProductivity.score === "number"
                ? analyticsProductivity.score
                : 0,
              100
            )
          );
          const normalizedScore = rawScore / 10;
          const message =
            analyticsProductivity.message || config.message || "Stay focused.";

          meter.classList.remove(
            "state-low",
            "state-mid",
            "state-high",
            "state-none"
          );
          meter.classList.add(`state-${state}`);

          scoreNode.textContent = `${normalizedScore.toFixed(1)}/10`;
          messageNode.textContent = message;
          barNode.style.width = `${rawScore}%`;
          botNode.src = config.bot;
          botNode.alt = config.alt;
          return;
        }

        const { score, status } = calculateProductivityScore();
        const config = PRODUCTIVITY_MEDIA[status] || PRODUCTIVITY_MEDIA.mid;

        meter.classList.remove(
          "state-low",
          "state-mid",
          "state-high",
          "state-none"
        );
        meter.classList.add(`state-${status}`);

        scoreNode.textContent = `${score}/10`;
        messageNode.textContent = config.message;
        barNode.style.width = `${Math.max(
          0,
          Math.min(100, (score / 10) * 100)
        )}%`;
        botNode.src = config.bot;
        botNode.alt = config.alt;
      }

      // Save functions
      function saveTasks() {
        saveStorage("tasks", tasks);
        updateProductivityMeter();
        scheduleAnalyticsRefresh();
      }

      function saveSchedule(options = {}) {
        if (options.enforce !== false) {
          resolveFocusConflicts({ save: false });
          sortScheduleEntries();
        }
        saveStorage("schedule", schedule);
        pruneNotificationCaches();
        updateProductivityMeter();
        scheduleAnalyticsRefresh();
      }

      function saveDismissedGoogleEvents() {
        saveStorage("dismissedGoogleEvents", Array.from(dismissedGoogleEvents));
      }

      function saveNotifiedSlots() {
        saveStorage("notifiedSlots", Array.from(notifiedSlots));
      }

      function saveNotifiedDeadlines() {
        saveStorage("notifiedDeadlines", Array.from(notifiedDeadlines));
      }

      function pruneNotificationCaches() {
        const validIds = new Set(schedule.map((item) => String(item.id)));
        notifiedSlots = new Set(
          Array.from(notifiedSlots).filter((id) => validIds.has(String(id)))
        );
        saveNotifiedSlots();
      }

      // // Request notification permission
      // if ("Notification" in window && Notification.permission === "default") {
      //   // Notification.requestPermission();
      // }

      function syncNotificationButton() {
        updateNotificationModalContent();

        if ("Notification" in window && Notification.permission === "granted") {
          hideNotificationPermissionModal();
        }
      }

      function requestNotificationPermission(source = "ui") {
        const fromModal = source === "modal";

        if (!("Notification" in window)) {
          if (!fromModal) {
            alert("Your browser does not support notifications.");
          }
          hideNotificationPermissionModal();
          syncNotificationButton();
          return;
        }

        if (Notification.permission === "granted") {
          if (!fromModal) {
            alert("Notifications are already enabled.");
          }
          hideNotificationPermissionModal();
          syncNotificationButton();
          return;
        }

        Notification.requestPermission()
          .then((permission) => {
            if (permission === "granted") {
              if (!fromModal) {
                alert(
                  "Notifications enabled! We'll nudge you when new focus blocks start."
                );
              }
              hideNotificationPermissionModal();
            } else if (permission === "denied" && !fromModal) {
              alert(
                "Notifications remain blocked. Please enable them in your browser settings."
              );
            }
            syncNotificationButton();
          })
          .catch((error) => {
            console.error("Notification permission request failed:", error);
            if (!fromModal) {
              alert(
                "We couldn't update your notification settings. Please try again later."
              );
            }
            syncNotificationButton();
          });
      }

      document.addEventListener("DOMContentLoaded", () => {
        domReady = true;
        window.domReady = true;
        setupMenuOverlay();
        setupSidebarTabs();
        setDefaultDeadline("sidebarDeadline");
        if (window.gapiLoaded) {
          init();
        }
        syncNotificationButton();
        updateProductivityMeter();
      });

      window.addEventListener("focus", syncNotificationButton);
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          syncNotificationButton();
        }
      });

      setTimeout(() => {
        if (!window.gapiLoaded && typeof gapi !== "undefined") {
          window.gapiLoaded = true;
          if (domReady) {
            init();
          }
        }
      }, 3000);
      console.log("page ready â€“ gapi loaded:", !!window.gapi);
    </script>
  </body>
</html>
