<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LockIN - AI Task Scheduler</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Mulish:wght@200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://apis.google.com/js/api.js"
      onload="window.gapiLoaded = true; if (window.domReady) init();"
      async
      defer
    ></script>
    <script>
      window.__gapiLoadCount = 0;
      const gapiCheck = setInterval(() => {
        window.__gapiLoadCount++;
        if (typeof gapi !== "undefined") {
          clearInterval(gapiCheck);
          console.log("gapi loaded after", window.__gapiLoadCount * 100, "ms");
        } else if (window.__gapiLoadCount > 50) {
          clearInterval(gapiCheck);
          console.error("gapi failed to load after 5s");
        }
      }, 100);
    </script>

    <meta
      http-equiv="Content-Security-Policy"
      content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://apis.google.com https://accounts.google.com https://www.gstatic.com https://ssl.gstatic.com https://content.googleapis.com https://*.gstatic.com;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://accounts.google.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://www.googleapis.com https://accounts.google.com https://content.googleapis.com https://www.gstatic.com https://oauth2.googleapis.com;
  frame-src 'self' https://accounts.google.com https://content.googleapis.com https://www.google.com https://www.gstatic.com;
  img-src 'self' data: https: blob:;
  worker-src 'self' blob:;
"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Mulish", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        position: relative;
        padding-top: 40px;
      }

      .header-actions {
        position: absolute;
        top: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .header-actions .header-google-btn {
        padding: 8px 16px;
        font-size: 0.9em;
        border-width: 1px;
        min-width: 180px;
        justify-content: center;
      }

      .header-button {
        background: #f7fafc;
        border: 2px solid #e2e8f0;
        color: #2d3748;
        padding: 8px 16px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .header-button:hover {
        background: #e2e8f0;
      }

      .header-button.notification-active {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        border-color: #2f855a;
        color: #ffffff;
      }

      .header-button.notification-blocked {
        background: #fed7d7;
        border-color: #fc8181;
        color: #c53030;
      }

      .header .logo {
        max-width: 200px;
        width: 100%;
        height: auto;
        display: block;
        margin: 0 auto 10px;
      }

      .header p {
        opacity: 0.9;
        font-size: 1.1em;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .sidebar {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        max-height: 120vh;
        overflow-y: auto;
        /* NEW: Re-order sidebar */
        display: flex;
        flex-direction: column;
      }

      .calendar-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .add-task-form {
        margin-bottom: 30px;
        order: 3; /* NEW: Move to bottom */
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        color: #4a5568;
        font-weight: 500;
      }

      input,
      select {
        width: 100%;
        padding: 10px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #4a5568;
      }

      .task-list {
        margin-top: 30px;
        order: 4; /* NEW: Move below Add Task */
      }

      .task-item {
        background: #f7fafc;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
        border-left: 4px solid #667eea;
      }

      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .task-name {
        font-weight: 600;
        color: #2d3748;
      }

      .task-deadline {
        font-size: 12px;
        color: #718096;
      }

      .task-progress {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }

      .progress-bar {
        flex: 1;
        height: 8px;
        background: #e2e8f0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
        transition: width 0.3s;
      }

      .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .calendar-nav {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .nav-btn {
        background: #edf2f7;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        color: #4a5568;
        transition: background 0.2s, transform 0.2s;
      }

      .nav-btn:hover {
        background: #cbd5f5;
        transform: translateY(-1px);
      }

      .nav-btn:active {
        transform: scale(0.95);
      }

      .week-view {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .calendar-scroll {
        max-height: 720px;
        overflow-y: auto;
        padding-right: 6px;
        scroll-behavior: smooth;
      }

      .calendar-scroll::-webkit-scrollbar {
        width: 8px;
      }

      .calendar-scroll::-webkit-scrollbar-thumb {
        background: rgba(102, 126, 234, 0.35);
        border-radius: 4px;
      }

      .week-view-header,
      .week-view-grid {
        display: grid;
        grid-template-columns: 80px repeat(7, 1fr);
        gap: 10px;
      }

      .time-slot-label {
        color: #718096;
        font-size: 12px;
        text-align: right;
        padding-right: 10px;
        height: 60px;
        display: flex;
        align-items: flex-start;
        justify-content: flex-end;
      }

      .time-column {
        display: flex;
        flex-direction: column;
      }

      .day-header {
        font-weight: 600;
        color: #2d3748;
        text-align: center;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .day-column-body {
        position: relative;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #ffffff;
        overflow: visible;
        padding: 0 6px;
      }

      .hour-divider {
        position: absolute;
        left: 0;
        right: 0;
        height: 0;
        border-top: 1px solid #f0f0f0;
      }

      .scheduled-task {
        position: absolute;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 6px;
        border-radius: 6px;
        font-size: 11px;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow: hidden;
        line-height: 1.2;
      }

      .scheduled-task:hover {
        transform: scale(1.02);
      }

      .scheduled-task.in-progress {
        background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
      }

      .scheduled-task.completed {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }

      .scheduled-task.external-event {
        background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
      }

      .scheduled-task .event-title {
        font-weight: 600;
        font-size: 12px;
      }

      .scheduled-task .event-time {
        font-size: 11px;
        opacity: 0.85;
      }

      .deadline-flag {
        position: absolute;
        right: 12px;
        background: #e53e3e;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        box-shadow: 0 2px 4px rgba(229, 62, 62, 0.2);
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        min-width: 300px;
        animation: slideIn 0.3s ease;
        display: none;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      .notification.show {
        display: block;
      }

      .notification-header {
        font-weight: 600;
        margin-bottom: 10px;
        color: #2d3748;
      }

      .notification-body {
        color: #4a5568;
        margin-bottom: 15px;
      }

      .notification-actions {
        display: flex;
        gap: 10px;
      }

      .notification-btn {
        flex: 1;
        padding: 8px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
      }

      .notification-btn.accept {
        background: #48bb78;
        color: white;
      }

      .notification-btn.decline {
        background: #fc8181;
        color: white;
      }

      .notification-btn.reschedule {
        background: #f6d365;
        color: #2d3748;
      }

      .stats-panel {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        margin-top: 15px;
      }

      .stat-card {
        text-align: center;
        padding: 15px;
        background: #f7fafc;
        border-radius: 8px;
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        color: #667eea;
      }

      .stat-label {
        color: #718096;
        font-size: 0.9em;
        margin-top: 5px;
      }

      /* --- MODIFIED AI SUGGESTIONS --- */
      .ai-suggestions {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
        order: 2; /* NEW: Move to middle */
      }

      .ai-suggestions h3 {
        color: #92400e;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      #aiSuggestionText {
        color: #333;
        line-height: 1.5;
        font-size: 0.95em;
      }
      #aiSuggestionButton {
          margin-top: 10px;
          padding: 8px 12px;
          font-size: 0.9em;
          width: auto;
      }
      /* --- END AI SUGGESTIONS --- */


      .pomodoro-timer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 15px;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 100;
      }

      .timer-display {
        font-size: 2.2em;
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 10px;
      }

      .timer-label {
        font-size: 0.9em;
        color: #718096;
        margin-bottom: 15px;
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }

      .timer-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: transform 0.2s;
      }

      .timer-btn:hover {
        transform: scale(1.05);
      }

      .timer-btn.pause {
        background: #f6d365;
        color: #2d3748;
      }

      .timer-btn.resume {
        background: #48bb78;
        color: white;
      }

      .timer-btn.stop {
        background: #fc8181;
        color: white;
      }

      .deadline-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #e53e3e;
        pointer-events: none;
        z-index: 20;
      }

      .deadline-label {
        position: absolute;
        top: -20px;
        background: #e53e3e;
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        transform: translateX(-50%);
      }

      .google-cal-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .google-section-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 10px;
        padding: 12px 16px;
        color: #2d3748;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .google-section-toggle:hover {
        background: #edf2f7;
      }

      .google-section-toggle.collapsed .toggle-icon,
      .google-section-toggle .toggle-icon {
        font-size: 0.9em;
        transform: rotate(0deg);
        transition: transform 0.2s ease;
      }

      .google-section-toggle.expanded .toggle-icon {
        transform: rotate(90deg);
      }

      .google-cal-content {
        margin-top: 16px;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 16px;
        transition: max-height 0.25s ease, opacity 0.25s ease;
        max-height: 600px;
        overflow: hidden;
        opacity: 1;
      }

      .google-cal-content.collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border-width: 0;
      }

      .google-cal-status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9em;
        color: #4a5568;
        margin-bottom: 12px;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid #e2e8f0;
        font-size: 0.85em;
      }

      .status-pill.success {
        background: #c6f6d5;
        border-color: #48bb78;
        color: #22543d;
      }

      .status-pill.warning {
        background: #fed7d7;
        border-color: #fc8181;
        color: #9b2c2c;
      }

      .google-btn {
        background: white;
        border: 2px solid #4285f4;
        color: #4285f4;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.3s;
      }

      .google-btn:hover {
        background: #4285f4;
        color: white;
      }

      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(45, 55, 72, 0.45);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1200;
        padding: 20px;
      }

      .modal-overlay.show {
        display: flex;
      }

      .modal-content {
        background: #ffffff;
        border-radius: 16px;
        max-width: 420px;
        width: 100%;
        padding: 24px;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: transparent;
        border: none;
        font-size: 20px;
        color: #4a5568;
        cursor: pointer;
      }

      .modal-time {
        color: #4a5568;
        margin-top: 8px;
        font-size: 0.95em;
      }

      .modal-meta {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
        margin-top: 16px;
      }

      .modal-meta div {
        background: #f7fafc;
        border-radius: 8px;
        padding: 10px;
        font-size: 0.85em;
        color: #2d3748;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .meta-label {
        font-size: 0.75em;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #718096;
      }

      .modal-description {
        margin-top: 18px;
        color: #4a5568;
        font-size: 0.95em;
        line-height: 1.5;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
        margin-top: 24px;
        flex-wrap: wrap;
      }

      .modal-actions button {
        flex: 1;
        min-width: 140px;
        padding: 10px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .modal-actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.18);
      }

      .modal-actions .primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
      }

      .modal-actions .danger {
        background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);
        color: #ffffff;
      }

      .modal-actions .secondary {
        background: #edf2f7;
        color: #2d3748;
      }
      
      /* --- NEW STYLES FROM MERGE --- */
      .btn-small-action {
          padding: 6px 12px;
          font-size: 12px;
          flex: 1;
      }
      .btn-add-today {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      .btn-added-today {
        background: #48bb78; /* Green */
        color: white;
        cursor: not-allowed;
      }
      
      .today-plan-section {
        background: #f7fafc;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        order: 1; /* NEW: Move to top */
      }
      .today-plan-section h2 {
         color: #2d3748; 
         margin-bottom: 15px;
      }
      #todayTaskList .task-item {
          background: white;
          padding: 10px;
          display: flex;
          justify-content: space-between;
          align-items: center;
          border-left: 4px solid #48bb78; /* Green for today */
      }
      #todayTaskList .task-name {
          font-size: 0.9em;
      }
      #todayTaskList .btn-remove-today {
          background: none;
          border: none;
          color: #fc8181;
          cursor: pointer;
          font-size: 20px;
          font-weight: bold;
          padding: 0 5px;
      }
      /* --- END NEW STYLES --- */

      @media (max-width: 768px) {
        .main-grid {
          grid-template-columns: 1fr;
        }

        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
        .logo {
          height: 100px;
        }

        .header-actions {
          position: static;
          justify-content: flex-end;
          margin-bottom: 10px;
        }

        .modal-meta {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body
    data-user-id="{{ user_id }}"
    data-user-email="{{ user_profile.get('email', '') if user_profile else '' }}"
  >
    <div class="container">
      <div class="header">
        <div class="header-actions">
          <button class="google-btn header-google-btn" id="googleAuthButton">
            Connect Google Calendar
          </button>
          <button
            type="button"
            class="header-button"
            id="notificationPermissionButton"
            onclick="requestNotificationPermission()"
          >
            Enable Notifications
          </button>
        </div>
        <img
          src="{{ url_for('static', filename='images/LockIN-logo-noBG.png') }}"
          class="logo"
          alt="LockIN logo"
        />
        <p>Find your flow, stay locked in.</p>
      </div>

      <div class="main-grid">
        <div class="sidebar">
          
          <div class="today-plan-section">
            <h2 style="color: #2d3748; margin-bottom: 15px;">üìÖ Today's Plan</h2>
            <div id="todaySummary" style="margin-bottom: 15px; font-weight: 600; color: #4a5568;">
              </div>
            <div id="todayTaskList">
              </div>
          </div>
          
          <div class="ai-suggestions" id="aiSuggestions">
            <h3>ü§ñ AI Suggestions</h3>
            <div id="aiSuggestionText">Loading...</div>
            <button id="aiSuggestionButton" class="btn" style="display: none;">Add to Today</button>
          </div>

          <div class="add-task-form">
            <h2 style="color: #2d3748; margin-bottom: 20px">Add New Task</h2>
            <div class="form-group">
              <label for="taskName">Task Name</label>
              <input
                type="text"
                id="taskName"
                placeholder="e.g., Complete project proposal"
              />
            </div>
            <div class="form-group">
              <label for="deadline">Deadline</label>
              <input type="datetime-local" id="deadline" />
            </div>
            <div class="form-group">
              <label for="daysRequired">Days Required</label>
              <input type="number" id="daysRequired" min="1" value="1" />
            </div>
            <div class="form-group">
              <label for="dailyHours">Daily Hours</label>
              <input
                type="number"
                id="dailyHours"
                min="0.5"
                step="0.5"
                value="2"
              />
            </div>
            <button class="btn" onclick="addTask()">Add Task</button>
          </div>

          <div class="task-list">
            <h3 style="color: #2d3748; margin-bottom: 15px">Master Task List (Backlog)</h3>
            <div id="taskList">
              </div>
          </div>

        </div>

        <div class="calendar-section">
          <div class="calendar-header">
            <h2 style="color: #2d3748">Week View</h2>
            <div class="calendar-nav">
              <button
                class="nav-btn"
                id="prevWeekBtn"
                aria-label="Previous week"
              >
                &lsaquo;
              </button>
              <span id="currentWeek" style="color: #718096"></span>
              <button class="nav-btn" id="nextWeekBtn" aria-label="Next week">
                &rsaquo;
              </button>
            </div>
          </div>
          <div class="week-view" id="weekView">
            </div>
        </div>
      </div>
      <div class="stats-panel">
        <h3 style="color: #2d3748">Productivity Stats</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="tasksCompleted">0</div>
            <div class="stat-label">Tasks Completed</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="focusTime">0h</div>
            <div class="stat-label">Focus Time Today</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="streakDays">0</div>
            <div class="stat-label">Day Streak</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="completionRate">0%</div>
            <div class="stat-label">Completion Rate</div>
          </div>
        </div>
      </div>
    </div>

    <div class="notification" id="notification">
      <div class="notification-header" id="notificationHeader">
        Task Reminder
      </div>
      <div class="notification-body" id="notificationBody">
        It's time for your scheduled task
      </div>
      <div class="notification-actions">
        <button
          class="notification-btn accept"
          onclick="handleNotification('accept')"
        >
          Start
        </button>
        <button
          class="notification-btn reschedule"
          onclick="handleNotification('reschedule')"
        >
          Reschedule
        </button>
        <button
          class="notification-btn decline"
          onclick="handleNotification('decline')"
        >
          Skip
        </button>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="eventModal"
      onclick="handleModalOverlayClick(event)"
    >
      <div class="modal-content">
        <button class="modal-close" onclick="closeEventModal()">&times;</button>
        <h3 id="modalTitle" style="color: #2d3748; font-size: 1.4em">
          Scheduled Block
        </h3>
        <p class="modal-time" id="modalTime"></p>
        <div class="modal-meta">
          <div>
            <span class="meta-label">Source</span>
            <span id="modalSource"></span>
          </div>
          <div>
            <span class="meta-label">Status</span>
            <span id="modalStatus"></span>
          </div>
          <div>
            <span class="meta-label">Duration</span>
            <span id="modalDuration"></span>
          </div>
          <div id="modalLocationRow" style="display: none">
            <span class="meta-label">Location</span>
            <span id="modalLocation"></span>
          </div>
        </div>
        <p class="modal-description" id="modalDescription"></p>
        <div class="modal-actions">
          <button
            class="secondary"
            id="modalCloseBtn"
            onclick="closeEventModal()"
          >
            Close
          </button>
          <button
            class="primary"
            id="modalStartBtn"
            onclick="startFocusFromModal()"
          >
            Start Focus Session
          </button>
          <button
            class="danger"
            id="modalDeleteBtn"
            onclick="deleteScheduleItem()"
          >
            Delete Block
          </button>
        </div>
      </div>
    </div>

    <div class="pomodoro-timer" id="pomodoroTimer" style="display: none">
      <div class="timer-display" id="timerDisplay">25:00</div>
      <div class="timer-label" id="timerLabel">Focus Time</div>
      <div class="timer-controls">
        <button
          class="timer-btn pause"
          id="pauseBtn"
          onclick="togglePauseResume()"
        >
          ‚è∏ Pause
        </button>
        <button class="timer-btn stop" onclick="stopPomodoro()">‚èπ Stop</button>
      </div>
    </div>

    <div class="google-cal-section" id="googleCalSection" style="display: none">
      <button type="button" class="google-section-toggle" id="googleCalToggle">
        <span>Google Calendar Integration</span>
        <span class="toggle-icon" aria-hidden="true">‚ñ∏</span>
      </button>
      <div class="google-cal-content collapsed" id="googleCalContent">
        <div class="google-cal-status">
          <span>Status:</span>
          <span id="authStatus" class="status-pill">Not Connected</span>
        </div>
        <button
          class="google-btn"
          id="refreshEventsBtn"
          style="display: none"
          onclick="refreshGoogleEvents()"
        >
          Refresh Google Events
        </button>
        <div id="calendarEvents" style="margin-top: 15px">
          <p style="color: #718096">
            Connect from the top-right button to sync your Google Calendar.
          </p>
        </div>
      </div>
    </div>

    <script>
      // --- ORIGINAL CONSTANTS AND STATE ---
      const DISCOVERY_DOCS = [
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest",
      ];
      const USER_ID = document.body.dataset.userId || "guest";
      const storageKey = (base) => `${base}_${USER_ID}`;
      const DEFAULT_STATS = {
        completed: 0,
        focusTime: 0,
        streak: 0,
        totalTasks: 0,
      };

      const deepClone = (value) => JSON.parse(JSON.stringify(value));
      function loadStorage(base, defaultValue) {
        try {
          const raw = localStorage.getItem(storageKey(base));
          if (!raw) {
            return deepClone(defaultValue);
          }
          return JSON.parse(raw);
        } catch (error) {
          console.warn(`Failed to load ${base} from storage`, error);
          return deepClone(defaultValue);
        }
      }

      function saveStorage(base, value) {
        try {
          localStorage.setItem(storageKey(base), JSON.stringify(value));
        } catch (error) {
          console.warn(`Failed to persist ${base} in storage`, error);
        }
      }

      const GOOGLE_CAL_STATE_KEY = storageKey("googleCalExpanded");

      // State Management
      let tasks = loadStorage("tasks", []); // This is now a local cache, backend is source of truth
      let schedule = loadStorage("schedule", []); // This is also local cache
      let dismissedGoogleEvents = new Set(
        loadStorage("dismissedGoogleEvents", []).map(String)
      );
      let notifiedSlots = new Set(loadStorage("notifiedSlots", []).map(String));
      let notifiedDeadlines = new Set(
        loadStorage("notifiedDeadlines", []).map(String)
      );
      let lastMissedNotificationDate = localStorage.getItem(
        storageKey("lastMissedNotificationDate")
      );
      let lastAiNotification = Number(
        localStorage.getItem(storageKey("lastAiNotification")) || "0"
      );
      let activeScheduleId = null;
      let currentTask = null;
      let pomodoroInterval = null;
      let pomodoroTimeLeft = 25 * 60;
      let pomodoroPaused = false;
      let stats = loadStorage("stats", DEFAULT_STATS);

      // Google Calendar API configuration
      const GOOGLE_CLIENT_ID = "{{ google_client_id or '' }}";
      const GOOGLE_API_KEY = "{{ calendar_api_key or '' }}";
      const SCOPES = "{{ google_scopes or '' }}";

      let domReady = false;
      window.gapiLoaded = window.gapiLoaded || false;
      let calendarApiLoaded = false;
      let googleAccountAuthenticated = false;
      let currentWeekStart = getStartOfWeek(new Date());
      let calendarScrollInitialized = false;
      let userAdjustedCalendarScroll = false;
      
      // --- NEW STATE VARS ---
      let todayTasks = []; // In-memory cache for today's tasks
      let masterTasks = []; // In-memory cache for master list
      let currentAiSuggestion = null; // Store the AI's suggestion object


      function setGoogleCalendarExpanded(expand, persist = true) {
        // ... (This function is unchanged from your file)
        const toggle = document.getElementById("googleCalToggle");
        const content = document.getElementById("googleCalContent");
        if (!toggle || !content) return;

        if (expand) {
          content.classList.remove("collapsed");
          toggle.classList.add("expanded");
          toggle.setAttribute("aria-expanded", "true");
        } else {
          content.classList.add("collapsed");
          toggle.classList.remove("expanded");
          toggle.setAttribute("aria-expanded", "false");
        }

        if (persist) {
          localStorage.setItem(GOOGLE_CAL_STATE_KEY, expand ? "1" : "0");
        }
      }

      function setupGoogleCalendarToggle() {
        // ... (This function is unchanged from your file)
        const toggle = document.getElementById("googleCalToggle");
        const content = document.getElementById("googleCalContent");
        if (!toggle || !content) return;

        const storedState = localStorage.getItem(GOOGLE_CAL_STATE_KEY);
        if (storedState === "1") {
          setGoogleCalendarExpanded(true, false);
        } else {
          setGoogleCalendarExpanded(false, false);
        }

        toggle.addEventListener("click", () => {
          const shouldExpand = content.classList.contains("collapsed");
          setGoogleCalendarExpanded(shouldExpand);
        });
      }

      function applyCalendarScrollFocus() {
        // ... (This function is unchanged from your file)
        const scrollContainer = document.getElementById("calendarScroll");
        if (!scrollContainer) {
          return;
        }

        if (!calendarScrollInitialized) {
          scrollContainer.addEventListener("scroll", () => {
            if (scrollContainer.dataset.lockScroll === "1") {
              return;
            }
            userAdjustedCalendarScroll = true;
            scrollContainer.dataset.userAdjusted = "true";
          });
        }

        if (!userAdjustedCalendarScroll) {
          scrollContainer.dataset.lockScroll = "1";
          const offset = Math.max(
            0,
            (DEFAULT_CALENDAR_VIEW_START - CALENDAR_DAY_START) *
              CALENDAR_SLOT_HEIGHT
          );
          scrollContainer.scrollTop = offset;
          requestAnimationFrame(() => {
            scrollContainer.dataset.lockScroll = "0";
          });
        }

        calendarScrollInitialized = true;
      }

      // --- MODIFIED init() FUNCTION ---
      function init() {
        setDefaultDeadline();
        setupGoogleCalendarToggle();
        const prevWeekBtn = document.getElementById("prevWeekBtn");
        const nextWeekBtn = document.getElementById("nextWeekBtn");
        if (prevWeekBtn && nextWeekBtn) {
          prevWeekBtn.addEventListener("click", () => changeWeek(-1));
          nextWeekBtn.addEventListener("click", () => changeWeek(1));
        }
        updateGoogleAuthUI();
        
        // --- NEW LOADING FUNCTIONS ---
        loadTodayTasks(); // Load today's plan
        loadMasterTasks(); // Load master list
        generateAISuggestions(); // Load AI suggestion
        // --- END NEW ---
        
        renderCalendar(); // This will now use schedule from backend
        updateStats(); // This should also be data from backend
        startNotificationChecker();
        syncNotificationButton();

        fetch("/check_auth")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("googleCalSection").style.display = "block";
            googleAccountAuthenticated = !!data.authenticated;
            updateGoogleAuthUI();
            if (googleAccountAuthenticated) {
              loadGoogleAPI();
              setTimeout(authenticateGapiWithFlaskToken, 1000);
            }
          });
      }
      
      function getStartOfWeek(date) {
        // ... (This function is unchanged from your file)
        const d = new Date(date);
        const day = d.getDay();
        d.setDate(d.getDate() - day);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      function setDefaultDeadline() {
        // ... (This function is unchanged from your file)
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 7);
        document.getElementById("deadline").value = tomorrow
          .toISOString()
          .slice(0, 16);
      }

      // --- NEW: Today's Plan Functions ---

      async function loadTodayTasks() {
        try {
          const response = await fetch('/today_tasks');
          if (!response.ok) throw new Error('Failed to fetch today\'s tasks');
          todayTasks = await response.json();
          renderTodayPlan();
          // After loading today's tasks, refresh the master list
          // to show the correct "Add/Added" button state
          renderTasks(); // Re-render master list
        } catch (error) {
          console.error(error);
          showNotification('Error', "Could not load your plan for today.");
        }
      }

      function renderTodayPlan() {
        const container = document.getElementById('todayTaskList');
        const summaryEl = document.getElementById('todaySummary');

        if (!container || !summaryEl) return;

        if (todayTasks.length === 0) {
          container.innerHTML = '<p style="color: #718096; text-align: center; padding: 10px;">Your plan for today is empty. Add a task!</p>';
        } else {
          container.innerHTML = todayTasks.map(task => `
            <div class="task-item" data-task-id="${task.id}">
                <span class="task-name">${task.name}</span>
                <button class="btn-remove-today" onclick="removeFromToday(${task.id})">&times;</button>
            </div>
          `).join('');
        }
        
        // Render Summary
        const totalMinutes = todayTasks.reduce((acc, task) => acc + (task.estimatedMinutes || 0), 0);
        const hours = (totalMinutes / 60).toFixed(1);
        summaryEl.textContent = `Tasks: ${todayTasks.length}  ‚Ä¢  Est. Time: ${hours}h`;
      }

      async function addToToday(taskId) {
        try {
          const response = await fetch('/today_tasks', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ task_id: taskId })
          });
          if (!response.ok) throw new Error('Failed to add task');
          
          await loadTodayTasks(); // Reload today's list
          showNotification('Task Added', 'Task added to your plan for today.');

        } catch (error) {
          console.error(error);
          showNotification('Error', 'Could not add task to today\'s plan.');
        }
      }

      async function removeFromToday(taskId) {
         try {
          const response = await fetch(`/today_tasks/${taskId}`, {
            method: 'DELETE'
          });
          if (!response.ok) throw new Error('Failed to remove task');
          
          await loadTodayTasks(); // Reload today's list
          
        } catch (error) {
          console.error(error);
          showNotification('Error', 'Could not remove task from today\'s plan.');
        }
      }

      // --- NEW: AI Suggestion Function ---

      async function generateAISuggestions() {
        const suggestionTextEl = document.getElementById('aiSuggestionText');
        const suggestionButtonEl = document.getElementById('aiSuggestionButton');
        
        if (!suggestionTextEl || !suggestionButtonEl) return;
        
        try {
          const response = await fetch('/ai_today_suggestion');
          if (!response.ok) throw new Error('No suggestion available');
          const suggestion = await response.json();
          
          currentAiSuggestion = suggestion; // Store the suggestion
          
          suggestionTextEl.innerHTML = suggestion.message; // Use innerHTML to render the <strong> tag
          
          if (suggestion.taskToSuggest) {
            suggestionButtonEl.textContent = `Add "${suggestion.taskToSuggest.name}"`;
            suggestionButtonEl.style.display = 'block';
            suggestionButtonEl.onclick = () => {
              addToToday(suggestion.taskToSuggest.id);
              suggestionButtonEl.style.display = 'none'; // Hide after clicking
              generateAISuggestions(); // Get next suggestion
            };
          } else {
            suggestionButtonEl.style.display = 'none';
          }
          
        } catch (error) {
          console.error(error);
          suggestionTextEl.textContent = 'Could not load AI suggestion.';
          suggestionButtonEl.style.display = 'none';
        }
      }


      // --- MODIFIED: addTask ---
      // This function now uses the backend
      async function addTask() {
        const name = document.getElementById("taskName").value;
        const deadline = document.getElementById("deadline").value;
        const daysRequired = parseInt(
          document.getElementById("daysRequired").value
        );
        const dailyHours = parseFloat(
          document.getElementById("dailyHours").value
        );

        if (!name || !deadline) {
          alert("Please fill in task name and deadline");
          return;
        }

        // Use your Flask backend endpoint
        try {
            const response = await fetch('/add_task', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    name: name,
                    deadline: deadline,
                    days_req: daysRequired,
                    hours_daily: dailyHours
                })
            });
            
            if (!response.ok) throw new Error('Failed to add task');
            
            const result = await response.json();
            
            // Clear form
            document.getElementById("taskName").value = "";
            document.getElementById("daysRequired").value = "1";
            document.getElementById("dailyHours").value = "2";
            setDefaultDeadline();

            // Refresh everything
            loadMasterTasks();
            generateAISuggestions();
            showNotification('Task Added', `Task "${name}" was created.`);
            
        } catch (error) {
            console.error(error);
            showNotification('Error', 'Could not add the task.');
        }
      }

      // Calculate task priority based on deadline and time required
      // THIS FUNCTION IS NOW OBSOLETE (backend does it), but we'll keep it to avoid errors
      function calculatePriority(deadline, totalHours) {
        const now = new Date();
        const hoursUntilDeadline = (deadline - now) / (1000 * 60 * 60);
        const urgency = totalHours / hoursUntilDeadline;
        return Math.min(10, Math.max(1, Math.round(urgency * 10)));
      }

      // AI-powered schedule generation
      // THIS FUNCTION IS NOW OBSOLETE (backend does it)
      function generateSchedule(task) {
        // ... (This is your original function, left intact)
        const now = new Date();
        const deadline = new Date(task.deadline);
        if (Number.isNaN(deadline.getTime())) {
          console.warn("Invalid deadline provided for task", task);
          return;
        }
        const sessions = Math.ceil(task.totalHours * 2);

        schedule = schedule.filter((item) => {
          if (String(item.taskId) !== String(task.id)) {
            return true;
          }
          if (item.source === "google" || item.type === "external") {
            return true;
          }
          return false;
        });

        let currentDate = new Date(now);
        currentDate.setHours(currentDate.getHours() + 1);
        currentDate.setMinutes(0);

        const preferredTimes = [
          { start: 9, end: 11, productivity: 1.2 }, 
          { start: 14, end: 16, productivity: 1.0 },
          { start: 19, end: 21, productivity: 0.8 },
        ];

        let sessionsScheduled = 0;

        while (sessionsScheduled < sessions && currentDate < deadline) {
          const hour = currentDate.getHours();
          const dayOfWeek = currentDate.getDay();

          if (dayOfWeek === 0 || dayOfWeek === 6) {
            currentDate.setDate(currentDate.getDate() + 1);
            currentDate.setHours(9, 0, 0, 0);
            continue;
          }

          const timeSlot = preferredTimes.find(
            (t) => hour >= t.start && hour < t.end
          );

          if (timeSlot) {
            const scheduleItem = {
              id: `${Date.now()}_${sessionsScheduled}_${Math.floor(
                Math.random() * 100000
              )}`,
              taskId: task.id,
              taskName: task.name,
              start: new Date(currentDate).toISOString(),
              end: new Date(currentDate.getTime() + 30 * 60000).toISOString(),
              type: "pomodoro",
              status: "scheduled",
              productivity: timeSlot.productivity,
              source: "focusflow",
            };

            const isDuplicate = schedule.some(
              (entry) =>
                String(entry.taskId) === String(scheduleItem.taskId) &&
                entry.start === scheduleItem.start &&
                entry.end === scheduleItem.end
            );

            if (!isDuplicate) {
              schedule.push(scheduleItem);
            }
            sessionsScheduled++;
            currentDate.setMinutes(currentDate.getMinutes() + 30);
          } else {
            currentDate.setHours(currentDate.getHours() + 1);
          }

          if (hour >= 21) {
            currentDate.setDate(currentDate.getDate() + 1);
            currentDate.setHours(9, 0, 0, 0);
          }
        }
        schedule.push({
          id: `${Date.now()}_${Math.floor(Math.random() * 100000)}_deadline`,
          taskId: task.id,
          taskName: task.name + " (DEADLINE)",
          start: deadline.toISOString(),
          end: deadline.toISOString(),
          type: "deadline",
          status: "deadline",
          source: "focusflow",
        });

        saveSchedule();
      }

      // DELETED: generateAISuggestions(), renderAISuggestions(), acceptSuggestion()
      // They are replaced by the new async function

      // --- MODIFIED: StartPomodoro ---
      function startPomodoro(task) { // task is now an object from the API
        currentTask = task;
        pomodoroTimeLeft = 25 * 60; 
        pomodoroPaused = false;

        document.getElementById("pomodoroTimer").style.display = "flex";
        document.getElementById(
          "timerLabel"
        ).textContent = `Working on: ${task.name}`;
        document.getElementById("pauseBtn").textContent = "‚è∏ Pause";
        document.getElementById("pauseBtn").className = "timer-btn pause";

        clearInterval(pomodoroInterval);
        pomodoroInterval = setInterval(() => {
          if (!pomodoroPaused) {
            pomodoroTimeLeft--;

            const minutes = Math.floor(pomodoroTimeLeft / 60);
            const seconds = pomodoroTimeLeft % 60;
            document.getElementById("timerDisplay").textContent = `${minutes
              .toString()
              .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

            if (pomodoroTimeLeft <= 0) {
              clearInterval(pomodoroInterval);
              handlePomodoroComplete();
            }

            if (pomodoroTimeLeft === 5 * 60) {
              showNotification(
                "Check-in",
                "Are you still working on: " + task.name + "?"
              );
            }
          }
        }, 1000);

        showNotification("Task Started", `Working on: ${task.name}`);
      }

      function togglePauseResume() {
        // ... (This function is unchanged)
        pomodoroPaused = !pomodoroPaused;
        const btn = document.getElementById("pauseBtn");

        if (pomodoroPaused) {
          btn.textContent = "‚ñ∂ Resume";
          btn.className = "timer-btn resume";
          showNotification(
            "Timer Paused",
            "Take a break. Click Resume when ready."
          );
        } else {
          btn.textContent = "‚è∏ Pause";
          btn.className = "timer-btn pause";
          showNotification("Timer Resumed", "Back to work!");
        }
      }

      // --- MODIFIED: stopPomodoro ---
      function stopPomodoro() {
        clearInterval(pomodoroInterval);
        document.getElementById("pomodoroTimer").style.display = "none";

        if (currentTask) {
          const minutesWorked = (25 * 60 - pomodoroTimeLeft) / 60;
          
          // NEW: Log session to backend
          logSession(currentTask.id, minutesWorked);
          
          stats.focusTime += (minutesWorked / 60);
          updateStats();
          loadMasterTasks(); // Refresh tasks

          showNotification(
            "Session Stopped",
            `Logged ${minutesWorked.toFixed(0)} minutes of work`
          );
        }

        currentTask = null;
        pomodoroPaused = false;
      }

      // --- MODIFIED: handlePomodoroComplete ---
      function handlePomodoroComplete() {
        if (currentTask) {
          // NEW: Log session to backend
          logSession(currentTask.id, 25); // Log 25 minutes
          
          stats.focusTime += 0.5;
          updateStats();
          loadMasterTasks();
          renderCalendar(); // This should also be refreshed from backend
          
          // Show a generic completion notification
          showNotification(
             "Session Complete!",
             `Great job! You completed a 25-minute session on: ${currentTask.name}`
          );
        }

        document.getElementById("pomodoroTimer").style.display = "none";
        currentTask = null;
        pomodoroPaused = false;
      }
      
      // --- NEW: Helper to log session to backend ---
      async function logSession(taskId, minutes) {
          try {
              await fetch('/log_session', {
                  method: 'POST',
                  headers: {'Content-Type': 'application/json'},
                  body: JSON.stringify({
                      task_id: taskId,
                      duration_minutes: minutes,
                      start_at: new Date(Date.now() - minutes * 60000).toISOString(),
                      end_at: new Date().toISOString()
                  })
              });
              loadMasterTasks(); // Refresh tasks to show new progress
              updateStats(); // Refresh stats from backend if possible
          } catch (error) {
              console.error('Failed to log session', error);
          }
      }

      // --- NEW: Renamed function ---
      async function loadMasterTasks() {
          try {
              const response = await fetch('/get_priorities'); // Fetch from your existing endpoint
              if (!response.ok) throw new Error('Failed to fetch tasks');
              masterTasks = await response.json(); // Store in new cache
              renderTasks(); // Re-render master list
          } catch (error) {
              console.error(error);
              document.getElementById('taskList').innerHTML = '<p style="color: #fc8181;">Could not load master task list.</p>';
          }
      }
      
      // --- MODIFIED: renderTasks (Master List) ---
      function renderTasks() {
        const container = document.getElementById("taskList");
        if (!container) return;

        if (masterTasks.length === 0) {
          container.innerHTML =
            '<p style="color: #718096;">Your master task list is empty. Add a task!</p>';
          return;
        }

        const todayTaskIds = new Set(todayTasks.map(task => task.id));

        container.innerHTML = masterTasks
          .map((task) => {
            const progress = (task.actualMinutes / (task.estimatedMinutes || 1)) * 100;
            const daysLeft = task.daysUntilDeadline;

            let deadlineColor = '#718096';
            let deadlineText = `...`; // Default
            
            if (daysLeft !== null) {
                deadlineText = `${daysLeft} days left`;
                if (daysLeft <= 0) {
                    deadlineColor = '#e53e3e'; // Red
                    deadlineText = 'Overdue';
                } else if (daysLeft <= 3) {
                    deadlineColor = '#f6d365'; // Yellow
                }
            } else {
              deadlineText = "No deadline";
            }

            const isAdded = todayTaskIds.has(task.id);
            const buttonClass = isAdded ? 'btn-added-today' : 'btn-add-today';
            const buttonText = isAdded ? '‚úî Added' : 'Add to Today';

            return `
                    <div class="task-item" data-task-id="${task.id}">
                        <div class="task-header">
                            <span class="task-name">${task.name}</span>
                            <span class="task-deadline" style="color: ${deadlineColor}; font-weight: 600;">
                                ${deadlineText}
                            </span>
                        </div>
                        <div class="task-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <span style="font-size: 12px; color: #718096;">${Math.round(progress)}%</span>
                        </div>
                        <div style="margin-top: 8px; display: flex; gap: 10px;">
                            <button class="btn btn-secondary btn-small-action" 
                                    onclick='startPomodoro(${JSON.stringify(
                                      task
                                    ).replace(/'/g, "&apos;")})'>
                                Start Session
                            </button>
                            <button class="btn btn-small-action ${buttonClass}" 
                                    onclick='addToToday(${task.id})' ${isAdded ? 'disabled' : ''}>
                                ${buttonText}
                            </button>
                        </div>
                    </div>
                `;
          })
          .join("");
      }

      // --- ALL OTHER ORIGINAL FUNCTIONS ---
      // (Your original calendar, modal, GAPI, and notification logic is all here)
      
      const CALENDAR_DAY_START = 0;
      const CALENDAR_DAY_END = 23;
      const DEFAULT_CALENDAR_VIEW_START = 8;
      const DEFAULT_CALENDAR_VIEW_END = 20;
      const CALENDAR_SLOT_HEIGHT = 60;

      function formatCalendarTime(date) {
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      }

      function formatHourLabel(hour) {
        const temp = new Date();
        temp.setHours(hour, 0, 0, 0);
        return temp.toLocaleTimeString([], { hour: "numeric", hour12: true });
      }

      function renderCalendar() {
        const container = document.getElementById("weekView");
        if (!container) {
          return;
        }
        const now = new Date();
        const startOfWeek = new Date(currentWeekStart);

        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const hours = Array.from(
          { length: CALENDAR_DAY_END - CALENDAR_DAY_START + 1 },
          (_, i) => CALENDAR_DAY_START + i
        );

        let headerHtml = '<div class="week-view-header"><div></div>';
        days.forEach((day, index) => {
          const date = new Date(startOfWeek);
          date.setDate(startOfWeek.getDate() + index);
          const isToday = date.toDateString() === now.toDateString();
          headerHtml += `<div class="day-header" style="${
            isToday ? "background: #e6fffa; border-color: #0bc5ea;" : ""
          }">
              ${day}<br><small>${date.getDate()}</small>
            </div>`;
        });
        headerHtml += "</div>";

        let bodyHtml = '<div class="week-view-grid">';
        bodyHtml += '<div class="time-column">';
        hours.forEach((hour) => {
          bodyHtml += `<div class="time-slot-label">${formatHourLabel(
            hour
          )}</div>`;
        });
        bodyHtml += "</div>";

        days.forEach((_, dayIndex) => {
          const dayDate = new Date(startOfWeek);
          dayDate.setDate(startOfWeek.getDate() + dayIndex);
          const dayStart = new Date(dayDate);
          dayStart.setHours(CALENDAR_DAY_START, 0, 0, 0);
          const dayEnd = new Date(dayDate);
          dayEnd.setHours(CALENDAR_DAY_END + 1, 0, 0, 0);
          const totalMinutes = (dayEnd - dayStart) / 60000;

          let columnHtml = `<div class="day-column-body" style="height: ${
            hours.length * CALENDAR_SLOT_HEIGHT
          }px">`;

          hours.forEach((_, hourIndex) => {
            const top = hourIndex * CALENDAR_SLOT_HEIGHT;
            columnHtml += `<div class="hour-divider" style="top: ${top}px"></div>`;
          });

          const dayEvents = schedule
            .filter((item) => {
              if (!item || item.type === "deadline") {
                return false;
              }
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              return eventEnd > dayStart && eventStart < dayEnd;
            })
            .map((item) => {
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              const rawStart = (eventStart - dayStart) / 60000;
              const rawEnd = (eventEnd - dayStart) / 60000;
              const boundedStart = Math.max(0, rawStart);
              const boundedEnd = Math.min(totalMinutes, rawEnd);
              if (boundedEnd <= 0 || boundedStart >= totalMinutes) {
                return null;
              }
              const effectiveEnd = Math.max(boundedEnd, boundedStart + 30);
              return {
                item,
                eventStart,
                eventEnd,
                startMinutes: boundedStart,
                endMinutes: Math.min(totalMinutes, effectiveEnd),
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

          const clusters = [];
          let activeCluster = null;
          dayEvents.forEach((event) => {
            if (!activeCluster || event.startMinutes >= activeCluster.maxEnd) {
              activeCluster = {
                events: [],
                maxEnd: event.endMinutes,
              };
              clusters.push(activeCluster);
            } else {
              activeCluster.maxEnd = Math.max(
                activeCluster.maxEnd,
                event.endMinutes
              );
            }
            activeCluster.events.push(event);
          });

          clusters.forEach((cluster) => {
            const activeEvents = [];
            cluster.columnCount = 0;

            cluster.events.sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

            cluster.events.forEach((event) => {
              for (let i = activeEvents.length - 1; i >= 0; i--) {
                if (activeEvents[i].endMinutes <= event.startMinutes) {
                  activeEvents.splice(i, 1);
                }
              }

              const usedColumns = activeEvents.map((evt) => evt.column);
              let columnIndex = 0;
              while (usedColumns.includes(columnIndex)) {
                columnIndex++;
              }

              event.column = columnIndex;
              activeEvents.push(event);
              cluster.columnCount = Math.max(
                cluster.columnCount,
                columnIndex + 1
              );
            });

            cluster.events.forEach((event) => {
              const columnCount = cluster.columnCount || 1;
              const top = (event.startMinutes / 60) * CALENDAR_SLOT_HEIGHT;
              const height = Math.max(
                ((event.endMinutes - event.startMinutes) / 60) *
                  CALENDAR_SLOT_HEIGHT,
                32
              );

              const columnWidth = Math.round((100 / columnCount) * 1000) / 1000;
              const leftPercent =
                Math.round(columnWidth * event.column * 1000) / 1000;
              const widthStyle =
                columnCount > 1
                  ? `calc(${columnWidth}% - 6px)`
                  : `calc(${columnWidth}% - 2px)`;
              const leftStyle = `${leftPercent}%`;

              const statusClass =
                event.item.status === "completed"
                  ? "completed"
                  : event.item.status === "in-progress"
                  ? "in-progress"
                  : "";
              const isExternal =
                event.item.source === "google" ||
                event.item.type === "external";
              const timeRange = `${formatCalendarTime(
                event.eventStart
              )} - ${formatCalendarTime(event.eventEnd)}`;

              columnHtml += `<div class="scheduled-task ${statusClass}${
                isExternal ? " external-event" : ""
              }" style="top: ${top}px; height: ${height}px; width: ${widthStyle}; left: ${leftStyle};" onclick="openScheduleModal('${
                event.item.id
              }')">
                <span class="event-title">${
                  event.item.taskName || "Scheduled Block"
                }</span>
                <span class="event-time">${timeRange}</span>
              </div>`;
            });
          });

          const dayDeadlines = masterTasks.filter((task) => {
            if (!task.deadline) return false;
            const deadline = new Date(task.deadline);
            return (
              deadline >= dayStart &&
              deadline <= dayEnd &&
              task.status !== "completed"
            );
          });

          dayDeadlines.forEach((task) => {
            const deadlineDate = new Date(task.deadline);
            const minutesFromStart = (deadlineDate - dayStart) / 60000;
            const top = Math.max(
              0,
              (minutesFromStart / 60) * CALENDAR_SLOT_HEIGHT - 12
            );
            columnHtml += `<div class="deadline-flag" style="top: ${top}px;">
                <span>üìç</span>
                <span>${task.name}</span>
              </div>`;
          });

          columnHtml += "</div>";
          bodyHtml += columnHtml;
        });

        bodyHtml += "</div>";

        const scrollWrapper = `<div class="calendar-scroll" id="calendarScroll">${bodyHtml}</div>`;
        container.innerHTML = headerHtml + scrollWrapper;

        applyCalendarScrollFocus();

        const weekEnd = new Date(startOfWeek);
        weekEnd.setDate(startOfWeek.getDate() + 6);
        document.getElementById(
          "currentWeek"
        ).textContent = `${startOfWeek.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}`;
      }

      function changeWeek(offset) {
        // ... (This function is unchanged)
        currentWeekStart.setDate(currentWeekStart.getDate() + offset * 7);
        currentWeekStart = getStartOfWeek(currentWeekStart);
        renderCalendar();
        if (googleAccountAuthenticated) {
          const eventsContainer = document.getElementById("calendarEvents");
          if (eventsContainer) {
            eventsContainer.innerHTML = "<p>Loading events...</p>";
          }
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) =>
              console.error("Failed to refresh calendar events", error)
            );
        }
      }

      function handleScheduleClick(scheduleId) {
        // ... (This function is unchanged)
        openScheduleModal(String(scheduleId));
      }

      function updateGoogleAuthUI() {
        // ... (This function is unchanged)
        const authButton = document.getElementById("googleAuthButton");
        const authStatus = document.getElementById("authStatus");
        const refreshBtn = document.getElementById("refreshEventsBtn");
        const eventsContainer = document.getElementById("calendarEvents");
        const content = document.getElementById("googleCalContent");

        if (authButton) {
          if (googleAccountAuthenticated) {
            authButton.textContent = "Logout Google";
            authButton.onclick = logoutGoogle;
          } else {
            authButton.textContent = "Connect Google Calendar";
            authButton.onclick = initiateGoogleAuth;
          }
        }

        if (authStatus) {
          if (googleAccountAuthenticated) {
            authStatus.textContent = "Authenticated";
            authStatus.classList.add("success");
            authStatus.classList.remove("warning");
          } else {
            authStatus.textContent = "Not Connected";
            authStatus.classList.remove("success");
            authStatus.classList.add("warning");
          }
        }

        if (refreshBtn) {
          refreshBtn.style.display = googleAccountAuthenticated
            ? "inline-flex"
            : "none";
        }

        if (content) {
          if (!googleAccountAuthenticated) {
            setGoogleCalendarExpanded(false);
          } else if (localStorage.getItem(GOOGLE_CAL_STATE_KEY) === null) {
            setGoogleCalendarExpanded(true);
          }
        }

        if (eventsContainer) {
          if (googleAccountAuthenticated) {
            if (!eventsContainer.dataset.loadedOnce) {
              eventsContainer.innerHTML = "<p>Loading events...</p>";
            }
          } else {
            delete eventsContainer.dataset.loadedOnce;
            eventsContainer.innerHTML =
              '<p style="color: #718096">Connect from the top-right button to sync your Google Calendar.</p>';
          }
        }
      }

      function logoutGoogle() {
        // ... (This function is unchanged)
        fetch("/logout", { method: "POST" })
          .then(() => {
            googleAccountAuthenticated = false;
            calendarApiLoaded = false;
            if (typeof gapi !== "undefined" && gapi.client) {
              gapi.client.setToken(null);
            }
            schedule = schedule.filter(
              (item) => item.source !== "google" && item.type !== "external"
            );
            saveSchedule();
            renderCalendar();
            updateGoogleAuthUI();
            window.location.reload();
          })
          .catch((error) => {
            console.error("Failed to logout from Google", error);
            showNotification(
              "Logout Failed",
              "Could not disconnect Google right now. Please try again."
            );
          });
      }

      function refreshGoogleEvents() {
        // ... (This function is unchanged)
        if (!googleAccountAuthenticated) {
          showNotification(
            "Connect Google",
            "Link your Google Calendar from the top-right button first."
          );
          return;
        }

        const eventsContainer = document.getElementById("calendarEvents");
        if (eventsContainer) {
          eventsContainer.innerHTML = "<p>Refreshing events...</p>";
        }

        ensureCalendarApiLoaded()
          .then(() => loadCalendarEvents(currentWeekStart))
          .catch((error) => {
            console.error("Failed to refresh Google events", error);
            showNotification(
              "Refresh Failed",
              "Unable to refresh Google Calendar events right now."
            );
          });
      }

      function openScheduleModal(scheduleId) {
        // ... (This function is unchanged)
        const modal = document.getElementById("eventModal");
        if (!modal) {
          return;
        }

        const item = schedule.find(
          (entry) => String(entry.id) === String(scheduleId)
        );
        if (!item) {
          return;
        }

        activeScheduleId = item.id;

        const start = new Date(item.start);
        const end = item.end
          ? new Date(item.end)
          : new Date(start.getTime() + 30 * 60 * 1000);

        document.getElementById("modalTitle").textContent =
          item.taskName || "Scheduled Block";
        document.getElementById(
          "modalTime"
        ).textContent = `${start.toLocaleString()} - ${end.toLocaleTimeString(
          [],
          {
            hour: "2-digit",
            minute: "2-digit",
          }
        )}`;

        document.getElementById("modalSource").textContent =
          item.source === "google" || item.type === "external"
            ? "Google Calendar"
            : "FocusFlow";
        document.getElementById("modalStatus").textContent = (
          item.status || "scheduled"
        ).replace(/-/g, " ");
        document.getElementById("modalDuration").textContent = formatDuration(
          end.getTime() - start.getTime()
        );

        const locationRow = document.getElementById("modalLocationRow");
        if (item.location) {
          locationRow.style.display = "flex";
          document.getElementById("modalLocation").textContent = item.location;
        } else {
          locationRow.style.display = "none";
        }

        if (item.source === "google" || item.type === "external") {
          document.getElementById("modalDescription").textContent =
            "Managed via Google Calendar. Hide it here or update it directly in Google.";
          document.getElementById("modalStartBtn").style.display = "none";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Hide This Event";
        } else {
          const relatedTask = masterTasks.find((t) => t.id === item.taskId); // MODIFIED
          const priorityInfo =
            relatedTask && typeof relatedTask.priorityScore === "number" // MODIFIED
              ? ` Priority ${relatedTask.priorityScore}/100.`
              : "";
          const description = relatedTask
            ? `Focus block for "${relatedTask.name}".${priorityInfo}`
            : "Focus block scheduled via AI.";
          document.getElementById("modalDescription").textContent = description;
          document.getElementById("modalStartBtn").style.display =
            "inline-flex";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Delete Block";
        }

        modal.classList.add("show");
      }

      function closeEventModal() {
        // ... (This function is unchanged)
        const modal = document.getElementById("eventModal");
        if (modal) {
          modal.classList.remove("show");
        }
        activeScheduleId = null;
      }

      function handleModalOverlayClick(event) {
        // ... (This function is unchanged)
        if (event.target && event.target.id === "eventModal") {
          closeEventModal();
        }
      }

      function startFocusFromModal() {
        // ... (This function is unchanged)
        if (activeScheduleId === null) {
          return;
        }
        const item = schedule.find(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (!item || !item.taskId) {
          return;
        }
        const task = masterTasks.find((t) => t.id === item.taskId); // MODIFIED
        if (!task) {
           showNotification("Error", "Could not find parent task.");
          return;
        }

        startPomodoro(task);
        item.status = "in-progress";
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function deleteScheduleItem() {
        // ... (This function is unchanged)
        if (activeScheduleId === null) {
          return;
        }
        const index = schedule.findIndex(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (index === -1) {
          closeEventModal();
          return;
        }

        const [removed] = schedule.splice(index, 1);
        if (removed && removed.source === "google" && removed.externalId) {
          dismissedGoogleEvents.add(String(removed.externalId));
          saveDismissedGoogleEvents();
        }
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function formatDuration(milliseconds) {
        // ... (This function is unchanged)
        const totalMinutes = Math.max(1, Math.round(milliseconds / 60000));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0 && minutes > 0) {
          return `${hours}h ${minutes}m`;
        }
        if (hours > 0) {
          return `${hours}h`;
        }
        return `${minutes}m`;
      }

      document.addEventListener("keydown", (event) => {
        // ... (This function is unchanged)
        if (event.key === "Escape") {
          closeEventModal();
        }
      });

      function loadGoogleAPI() {
        // ... (This function is unchanged)
        if (typeof gapi === "undefined" || !gapi.load) {
          setTimeout(loadGoogleAPI, 100);
          return;
        }
        gapi.load("client:auth2", initGoogleClient);
      }

      function initGoogleClient() {
        // ... (This function is unchanged)
        gapi.load("client", () => {
          gapi.client
            .init({
              apiKey: GOOGLE_API_KEY,
              discoveryDocs: DISCOVERY_DOCS,
            })
            .then(() => authenticateGapiWithFlaskToken());
        });
      }

      function authenticateGapiWithFlaskToken() {
        // ... (This function is unchanged)
        if (!gapi.client || !gapi.client.setToken) {
          setTimeout(authenticateGapiWithFlaskToken, 500);
          return;
        }
        fetch("/get_gapi_token")
          .then((r) => r.json())
          .then((tokenData) => {
            gapi.client.setToken({ access_token: tokenData.access_token });
            ensureCalendarApiLoaded()
              .then(() => updateSigninStatus(true))
              .catch((error) => {
                console.error("Failed to load Google Calendar API", error);
              });
          });
      }

      function updateSigninStatus(isSignedIn) {
        // ... (This function is unchanged)
        if (isSignedIn && gapi.client.getToken()) {
          googleAccountAuthenticated = true;
          updateGoogleAuthUI();
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) => {
              console.error("Google Calendar API not ready", error);
            });
        }
      }

      function ensureCalendarApiLoaded() {
        // ... (This function is unchanged)
        if (calendarApiLoaded) {
          return Promise.resolve();
        }
        if (!gapi.client || !gapi.client.load) {
          return Promise.reject(new Error("gapi client not ready"));
        }
        return gapi.client.load("calendar", "v3").then(() => {
          calendarApiLoaded = true;
        });
      }

      function initiateGoogleAuth() {
        // ... (This function is unchanged)
        window.location.href = "/auth";
      }

      function loadCalendarEvents(weekStart = currentWeekStart) {
        // ... (This function is unchanged)
        const startWindow = new Date(weekStart);
        startWindow.setHours(0, 0, 0, 0);
        const endWindow = new Date(weekStart);
        endWindow.setDate(endWindow.getDate() + 7);
        endWindow.setHours(23, 59, 59, 999);
        gapi.client.calendar.events
          .list({
            calendarId: "primary",
            timeMin: startWindow.toISOString(),
            timeMax: endWindow.toISOString(),
            showDeleted: false,
            singleEvents: true,
            maxResults: 250,
            orderBy: "startTime",
          })
          .then((response) => {
            const events = response.result.items;
            displayGoogleEvents(events);
            extractDeadlinesFromEvents(events);
            mergeGoogleEventsIntoSchedule(events);
          });
      }

      function displayGoogleEvents(events) {
        // ... (This function is unchanged)
        const container = document.getElementById("calendarEvents");
        if (!container) {
          return;
        }
        container.dataset.loadedOnce = "true";
        if (events.length > 0) {
          container.innerHTML = "<h4>Upcoming Google Calendar Events:</h4>";
          events.forEach((event) => {
            const when = event.start.dateTime || event.start.date;
            container.innerHTML += `
                        <div style="padding: 8px; background: #f7fafc; margin: 5px 0; border-radius: 6px;">
                            <strong>${event.summary}</strong><br>
                            <small>${new Date(when).toLocaleString()}</small>
                            ${
                              event.description &&
                              event.description.includes("deadline")
                                ? `<button onclick="importAsTask('${event.summary}', '${when}')" 
                                 style="margin-left: 10px; padding: 2px 8px; background: #667eea; 
                                 color: white; border: none; border-radius: 4px; cursor: pointer;">
                                 Import as Task
                                </button>`
                                : ""
                            }
                        </div>
                    `;
          });
        } else {
          container.innerHTML = "<p>No upcoming events found.</p>";
        }
      }

      function extractDeadlinesFromEvents(events) {
        // ... (This function is unchanged)
        events.forEach((event) => {
          const deadlineKeywords = [
            "deadline",
            "due",
            "submit",
            "delivery",
            "final",
          ];
          const hasDeadline = deadlineKeywords.some(
            (keyword) =>
              (event.summary &&
                event.summary.toLowerCase().includes(keyword)) ||
              (event.description &&
                event.description.toLowerCase().includes(keyword))
          );

          if (hasDeadline) {
            console.log("Found potential deadline:", event.summary);
            showNotification(
              "Deadline Detected",
              `Found deadline in calendar: "${event.summary}". Click to import.`
            );
          }
        });
      }

      function mergeGoogleEventsIntoSchedule(events) {
        // ... (This function is unchanged)
        if (!Array.isArray(events)) {
          return;
        }

        const normalizedEvents = events
          .filter((event) => event && event.id && event.start)
          .map((event) => ({ ...event, id: String(event.id) }))
          .filter((event) => !dismissedGoogleEvents.has(event.id));
        const incomingIds = new Set(normalizedEvents.map((event) => event.id));

        schedule = schedule.filter((item) => {
          if (item && item.source === "google" && item.externalId) {
            return incomingIds.has(String(item.externalId));
          }
          return true;
        });

        normalizedEvents.forEach((event) => {
          const alreadySynced = schedule.some(
            (item) =>
              item.source === "google" &&
              String(item.externalId) === String(event.id)
          );
          if (alreadySynced) {
            return;
          }

          const startIso =
            event.start.dateTime ||
            (event.start.date ? `${event.start.date}T09:00:00` : null);
          if (!startIso) {
            return;
          }

          const endIso =
            event.end?.dateTime ||
            (event.end?.date ? `${event.end.date}T17:00:00` : null);

          const startDate = new Date(startIso);
          const endDate = endIso
            ? new Date(endIso)
            : new Date(startDate.getTime() + 60 * 60 * 1000);

          schedule.push({
            id: Date.now() + Math.floor(Math.random() * 1000),
            externalId: event.id,
            source: "google",
            taskId: null,
            taskName: `${event.summary || "Google Event"}`,
            start: startDate.toISOString(),
            end: endDate.toISOString(),
            type: "external",
            status: "scheduled",
            location: event.location || "",
          });
        });

        schedule.sort(
          (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
        );

        saveSchedule();
        renderCalendar();
      }

      function importAsTask(eventName, eventTime) {
        // ... (This function is unchanged)
        document.getElementById("taskName").value = eventName;
        document.getElementById("deadline").value = new Date(eventTime)
          .toISOString()
          .slice(0, 16);
        showNotification(
          "Task Imported",
          "Deadline imported from Google Calendar. Adjust hours and add task."
        );
      }

      function showNotification(title, body) {
        // ... (This function is unchanged)
        const notification = document.getElementById("notification");
        document.getElementById("notificationHeader").textContent = title;
        document.getElementById("notificationBody").textContent = body;
        notification.classList.add("show");

        setTimeout(() => {
          notification.classList.remove("show");
        }, 5000);

        if (Notification.permission === "granted") {
          new Notification(title, { body, icon: "üéØ" });
        }
      }

      function handleNotification(action) {
        // ... (This function is unchanged)
        const notification = document.getElementById("notification");
        notification.classList.remove("show");

        if (action === "accept" && currentTask) {
        } else if (action === "reschedule") {
          // generateAISuggestions(); // Old, local call
        } else if (action === "decline") {
          const reasons = [
            "Too tired",
            "Emergency came up",
            "Need a break",
            "Other priority",
          ];
          const reason = reasons[Math.floor(Math.random() * reasons.length)];
          console.log("Task declined:", reason);
        }
      }

      function startNotificationChecker() {
        // ... (This function is unchanged)
        runNotificationSweep();
        if (!window.focusflowNotificationInterval) {
          window.focusflowNotificationInterval = setInterval(
            runNotificationSweep,
            60000
          );
        }

        if (!window.focusflowAiInterval) {
          setTimeout(() => {
            // runAiInsights(); // This is replaced by the new /ai_today_suggestion
            window.focusflowAiInterval = setInterval(
              runAiInsights,
              45 * 60 * 1000
            );
          }, 5 * 60 * 1000);
        }
      }

      function runNotificationSweep() {
        // ... (This function is unchanged)
        const now = new Date();
        checkUpcomingFocusBlocks(now);
        checkDeadlineAlerts(now);
        checkMissedTasks(now);
      }

      function checkUpcomingFocusBlocks(now) {
        // ... (This function is unchanged)
        const toleranceMs = 60 * 1000;
        schedule.forEach((item) => {
          if (!item || item.type === "deadline") {
            return;
          }
          if (item.status && item.status !== "scheduled") {
            return;
          }
          const startTime = new Date(item.start);
          const diff = now.getTime() - startTime.getTime();
          if (diff >= 0 && diff <= toleranceMs) {
            const key = String(item.id);
            if (!notifiedSlots.has(key)) {
              const label = item.taskName || "Scheduled Block";
              showNotification(
                "Focus Block Starting",
                `"${label}" is starting now. Dive in!`
              );
              notifiedSlots.add(key);
              saveNotifiedSlots();
            }
          }
        });
      }

      function checkDeadlineAlerts(now) {
        // ... (This function is unchanged)
        const todayKey = now.toISOString().slice(0, 10);
        if (now.getHours() >= 12) {
          return;
        }
        const startOfToday = new Date(now);
        startOfToday.setHours(0, 0, 0, 0);
        const endOfToday = new Date(startOfToday);
        endOfToday.setHours(23, 59, 59, 999);
        const nowTime = now.getTime();
        const minInterval = 5 * 60 * 1000;
        if (
          window.focusflowLastDeadlineCheck &&
          nowTime - window.focusflowLastDeadlineCheck < minInterval
        ) {
          return;
        }
        window.focusflowLastDeadlineCheck = nowTime;
        notifiedDeadlines = new Set(
          Array.from(notifiedDeadlines).filter((key) => key.endsWith(todayKey))
        );
        saveNotifiedDeadlines();
        masterTasks.forEach((task) => { // MODIFIED
          if (!task || task.status === "completed") {
            return;
          }
          const deadlineDate = new Date(task.deadline);
          if (
            Number.isNaN(deadlineDate.getTime()) ||
            deadlineDate < startOfToday ||
            deadlineDate > endOfToday ||
            !isSameDay(deadlineDate, now)
          ) {
            return;
          }
          const key = `${task.id}_${todayKey}`;
          if (!notifiedDeadlines.has(key)) {
            showNotification(
              "Deadline Today",
              `"${task.name}" is due today. Make sure it lands on your schedule.`
            );
            notifiedDeadlines.add(key);
            saveNotifiedDeadlines();
          }
        });
      }

      function checkMissedTasks(now) {
        // ... (This function is unchanged)
        const todayKey = now.toISOString().slice(0, 10);
        if (lastMissedNotificationDate === todayKey) {
          return;
        }

        const startOfToday = new Date(now);
        startOfToday.setHours(0, 0, 0, 0);
        const startOfYesterday = new Date(startOfToday);
        startOfYesterday.setDate(startOfYesterday.getDate() - 1);
        const endOfYesterday = new Date(startOfToday.getTime() - 1);

        const missed = schedule.filter((item) => {
          if (!item || item.type === "deadline") {
            return false;
          }
          if (item.status && item.status !== "scheduled") {
            return false;
          }
          const startTime = new Date(item.start);
          return startTime >= startOfYesterday && startTime <= endOfYesterday;
        });

        if (missed.length > 0) {
          const message =
            missed.length === 1
              ? `You missed "${missed[0].taskName}" yesterday. Consider rescheduling it.`
              : `You missed ${missed.length} focus blocks yesterday. Review and reschedule them.`;
          showNotification(
            missed.length === 1 ? "Missed Focus Block" : "Missed Focus Blocks",
            message
          );
        }

        lastMissedNotificationDate = todayKey;
        localStorage.setItem(
          storageKey("lastMissedNotificationDate"),
          lastMissedNotificationDate
        );
      }

      // MODIFIED: This function is no longer the main AI driver
      function runAiInsights() {
        console.log("Periodic AI check... (now handled by /ai_today_suggestion)");
        // This is fine to keep, it just won't do much
      }

      function isSameDay(a, b) {
        // ... (This function is unchanged)
        return (
          a.getFullYear() === b.getFullYear() &&
          a.getMonth() === b.getMonth() &&
          a.getDate() === b.getDate()
        );
      }

      function calculateStreak() {
        // ... (This function is unchanged)
        const completedDays = new Set();
        schedule.forEach((item) => {
          if (item.status !== "completed") return;
          const reference = item.end || item.start;
          if (!reference) return;
          const completedDate = new Date(reference);
          if (Number.isNaN(completedDate.getTime())) return;
          completedDays.add(completedDate.toDateString());
        });

        let streak = 0;
        const cursor = new Date();
        while (completedDays.has(cursor.toDateString())) {
          streak += 1;
          cursor.setDate(cursor.getDate() - 1);
        }
        return streak;
      }

      // MODIFIED: This should be updated to pull from backend
      function updateStats() {
        // This is still using local state, which is fine for now
        // A better solution would be to fetch this from the backend
        const completedTasks = masterTasks.filter(
          (task) => task.status === "completed"
        ).length;
        const totalHours = schedule.reduce((acc, item) => {
          if (!item.start || !item.end) {
            return acc;
          }
          const start = new Date(item.start);
          const end = new Date(item.end);
          if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
            return acc;
          }
          const duration = Math.max((end - start) / (1000 * 60 * 60), 0);
          return item.status === "completed" ? acc + duration : acc;
        }, 0);

        stats = {
          completed: completedTasks,
          focusTime: Number(totalHours.toFixed(2)),
          streak: calculateStreak(),
          totalTasks: masterTasks.length,
        };

        // saveStorage("stats", stats); // No longer save, just display

        document.getElementById("tasksCompleted").textContent = stats.completed;
        document.getElementById(
          "focusTime"
        ).textContent = `${stats.focusTime.toFixed(1)}h`;
        document.getElementById("streakDays").textContent = stats.streak;

        const completionRate =
          stats.totalTasks > 0
            ? Math.round((stats.completed / stats.totalTasks) * 100)
            : 0;
        document.getElementById(
          "completionRate"
        ).textContent = `${completionRate}%`;
      }

      function saveTasks() {
        // saveStorage("tasks", tasks); // OBSOLETE
      }

      function saveSchedule() {
        // ... (This function is unchanged)
        saveStorage("schedule", schedule);
        pruneNotificationCaches();
      }

      function saveDismissedGoogleEvents() {
        // ... (This function is unchanged)
        saveStorage("dismissedGoogleEvents", Array.from(dismissedGoogleEvents));
      }

      function saveNotifiedSlots() {
        // ... (This function is unchanged)
        saveStorage("notifiedSlots", Array.from(notifiedSlots));
      }

      function saveNotifiedDeadlines() {
        // ... (This function is unchanged)
        saveStorage("notifiedDeadlines", Array.from(notifiedDeadlines));
      }

      function pruneNotificationCaches() {
        // ... (This function is unchanged)
        const validIds = new Set(schedule.map((item) => String(item.id)));
        notifiedSlots = new Set(
          Array.from(notifiedSlots).filter((id) => validIds.has(String(id)))
        );
        saveNotifiedSlots();
      }

      function syncNotificationButton() {
        // ... (This function is unchanged)
        const button = document.getElementById("notificationPermissionButton");
        if (!button) return;

        if (!("Notification" in window)) {
          button.textContent = "Notifications Unavailable";
          button.classList.remove(
            "notification-active",
            "notification-blocked"
          );
          button.classList.add("notification-blocked");
          button.disabled = true;
          button.title = "Your browser does not support notifications.";
          return;
        }

        button.disabled = false;
        button.classList.remove("notification-active", "notification-blocked");

        const permission = Notification.permission;
        if (permission === "granted") {
          button.textContent = "Notifications Enabled";
          button.classList.add("notification-active");
          button.title =
            "Notifications are enabled. Click if you need to re-check settings.";
        } else if (permission === "denied") {
          button.textContent = "Notifications Blocked";
          button.classList.add("notification-blocked");
          button.title =
            "Notifications are blocked. Update your browser settings, then click to try again.";
        } else {
          button.textContent = "Enable Notifications";
          button.title =
            "Allow browser notifications to receive focus reminders.";
        }
      }

      function requestNotificationPermission() {
        // ... (This function is unchanged)
        if (!("Notification" in window)) {
          alert("Your browser does not support notifications.");
          syncNotificationButton();
          return;
        }

        if (Notification.permission === "granted") {
          alert("Notifications are already enabled.");
          syncNotificationButton();
          return;
        }

        Notification.requestPermission()
          .then((permission) => {
            if (permission === "granted") {
              alert(
                "Notifications enabled! We'll nudge you when new focus blocks start."
              );
            } else if (permission === "denied") {
              alert(
                "Notifications remain blocked. Please enable them in your browser settings."
              );
            }
            syncNotificationButton();
          })
          .catch((error) => {
            console.error("Notification permission request failed:", error);
            alert(
              "We couldn't update your notification settings. Please try again later."
            );
            syncNotificationButton();
          });
      }

      document.addEventListener("DOMContentLoaded", () => {
        // ... (This function is unchanged)
        domReady = true;
        window.domReady = true;
        if (window.gapiLoaded) {
          init();
        }
        syncNotificationButton();
      });

      window.addEventListener("focus", syncNotificationButton);
      document.addEventListener("visibilitychange", () => {
        // ... (This function is unchanged)
        if (!document.hidden) {
          syncNotificationButton();
        }
      });

      setTimeout(() => {
        // ... (This function is unchanged)
        if (!window.gapiLoaded && typeof gapi !== "undefined") {
          window.gapiLoaded = true;
          if (domReady) {
            init();
          }
        }
      }, 3000);
      console.log("page ready ‚Äì gapi loaded:", !!window.gapi);
    </script>
  </body>
</html>
