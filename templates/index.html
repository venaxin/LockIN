<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LockIN - AI Task Scheduler</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Mulish:wght@200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <script
      src="https://apis.google.com/js/api.js"
      onload="window.gapiLoaded = true; if (window.domReady) init();"
      async
      defer
    ></script>
    <script>
      window.__gapiLoadCount = 0;
      const gapiCheck = setInterval(() => {
        window.__gapiLoadCount++;
        if (typeof gapi !== "undefined") {
          clearInterval(gapiCheck);
          console.log("gapi loaded after", window.__gapiLoadCount * 100, "ms");
        } else if (window.__gapiLoadCount > 50) {
          clearInterval(gapiCheck);
          console.error("gapi failed to load after 5s");
        }
      }, 100);
    </script>

    <meta
      http-equiv="Content-Security-Policy"
      content="
  default-src 'self';
  script-src 'self' 'unsafe-inline' https://apis.google.com https://accounts.google.com https://www.gstatic.com https://ssl.gstatic.com https://content.googleapis.com https://*.gstatic.com;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://accounts.google.com;
  font-src 'self' https://fonts.gstatic.com;
  connect-src 'self' https://www.googleapis.com https://accounts.google.com https://content.googleapis.com https://www.gstatic.com https://oauth2.googleapis.com;
  frame-src 'self' https://accounts.google.com https://content.googleapis.com https://www.google.com https://www.gstatic.com;
  img-src 'self' data: https: blob:;
  worker-src 'self' blob:;
"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Mulish", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
      }

      .header .logo {
        max-width: 200px;
        width: 100%;
        height: auto;
        display: block;
        margin: 0 auto 10px;
      }

      .header p {
        opacity: 0.9;
        font-size: 1.1em;
      }

      .main-grid {
        display: grid;
        grid-template-columns: 350px 1fr;
        gap: 20px;
        margin-bottom: 20px;
      }

      .sidebar {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        max-height: 85vh;
        overflow-y: auto;
      }

      .calendar-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .add-task-form {
        margin-bottom: 30px;
      }

      .form-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        color: #4a5568;
        font-weight: 500;
      }

      input,
      select {
        width: 100%;
        padding: 10px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: #667eea;
      }

      .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s;
        width: 100%;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn-secondary {
        background: #e2e8f0;
        color: #4a5568;
      }

      .task-list {
        margin-top: 30px;
      }

      .task-item {
        background: #f7fafc;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 10px;
        border-left: 4px solid #667eea;
      }

      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }

      .task-name {
        font-weight: 600;
        color: #2d3748;
      }

      .task-deadline {
        font-size: 12px;
        color: #718096;
      }

      .task-progress {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
      }

      .progress-bar {
        flex: 1;
        height: 8px;
        background: #e2e8f0;
        border-radius: 4px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
        transition: width 0.3s;
      }

      .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .calendar-nav {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .nav-btn {
        background: #edf2f7;
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 18px;
        color: #4a5568;
        transition: background 0.2s, transform 0.2s;
      }

      .nav-btn:hover {
        background: #cbd5f5;
        transform: translateY(-1px);
      }

      .nav-btn:active {
        transform: scale(0.95);
      }

      .week-view {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .week-view-header,
      .week-view-grid {
        display: grid;
        grid-template-columns: 80px repeat(7, 1fr);
        gap: 10px;
      }

      .time-slot-label {
        color: #718096;
        font-size: 12px;
        text-align: right;
        padding-right: 10px;
        height: 60px;
        display: flex;
        align-items: flex-start;
        justify-content: flex-end;
      }

      .time-column {
        display: flex;
        flex-direction: column;
      }

      .day-header {
        font-weight: 600;
        color: #2d3748;
        text-align: center;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #e2e8f0;
        background: #f8fafc;
      }

      .day-column-body {
        position: relative;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background: #ffffff;
        overflow: visible;
        padding: 0 6px;
      }

      .hour-divider {
        position: absolute;
        left: 0;
        right: 0;
        height: 0;
        border-top: 1px solid #f0f0f0;
      }

      .scheduled-task {
        position: absolute;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 6px;
        border-radius: 6px;
        font-size: 11px;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow: hidden;
        line-height: 1.2;
      }

      .scheduled-task:hover {
        transform: scale(1.02);
      }

      .scheduled-task.in-progress {
        background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
      }

      .scheduled-task.completed {
        background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
      }

      .scheduled-task.external-event {
        background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
      }

      .scheduled-task .event-title {
        font-weight: 600;
        font-size: 12px;
      }

      .scheduled-task .event-time {
        font-size: 11px;
        opacity: 0.85;
      }

      .deadline-flag {
        position: absolute;
        right: 12px;
        background: #e53e3e;
        color: #fff;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        box-shadow: 0 2px 4px rgba(229, 62, 62, 0.2);
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        min-width: 300px;
        animation: slideIn 0.3s ease;
        display: none;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
        }
        to {
          transform: translateX(0);
        }
      }

      .notification.show {
        display: block;
      }

      .notification-header {
        font-weight: 600;
        margin-bottom: 10px;
        color: #2d3748;
      }

      .notification-body {
        color: #4a5568;
        margin-bottom: 15px;
      }

      .notification-actions {
        display: flex;
        gap: 10px;
      }

      .notification-btn {
        flex: 1;
        padding: 8px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
      }

      .notification-btn.accept {
        background: #48bb78;
        color: white;
      }

      .notification-btn.decline {
        background: #fc8181;
        color: white;
      }

      .notification-btn.reschedule {
        background: #f6d365;
        color: #2d3748;
      }

      .stats-panel {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 20px;
        margin-top: 15px;
      }

      .stat-card {
        text-align: center;
        padding: 15px;
        background: #f7fafc;
        border-radius: 8px;
      }

      .stat-value {
        font-size: 2em;
        font-weight: bold;
        color: #667eea;
      }

      .stat-label {
        color: #718096;
        font-size: 0.9em;
        margin-top: 5px;
      }

      .ai-suggestions {
        background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        padding: 15px;
        border-radius: 8px;
        margin: 20px 0;
      }

      .ai-suggestions h3 {
        color: #92400e;
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .suggestion-item {
        background: white;
        padding: 10px;
        border-radius: 6px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .suggestion-item:hover {
        transform: translateX(5px);
      }

      .pomodoro-timer {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: white;
        padding: 20px;
        border-radius: 15px;
        min-width: 180px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        z-index: 100;
      }

      .timer-display {
        font-size: 2.2em;
        font-weight: bold;
        color: #2d3748;
        margin-bottom: 10px;
      }

      .timer-label {
        font-size: 0.9em;
        color: #718096;
        margin-bottom: 15px;
      }

      .timer-controls {
        display: flex;
        gap: 10px;
      }

      .timer-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: transform 0.2s;
      }

      .timer-btn:hover {
        transform: scale(1.05);
      }

      .timer-btn.pause {
        background: #f6d365;
        color: #2d3748;
      }

      .timer-btn.resume {
        background: #48bb78;
        color: white;
      }

      .timer-btn.stop {
        background: #fc8181;
        color: white;
      }

      .deadline-indicator {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 2px;
        background: #e53e3e;
        pointer-events: none;
        z-index: 20;
      }

      .deadline-label {
        position: absolute;
        top: -20px;
        background: #e53e3e;
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 10px;
        white-space: nowrap;
        transform: translateX(-50%);
      }

      .google-cal-section {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .google-btn {
        background: white;
        border: 2px solid #4285f4;
        color: #4285f4;
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 10px;
        transition: all 0.3s;
      }

      .google-btn:hover {
        background: #4285f4;
        color: white;
      }

      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(45, 55, 72, 0.45);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1200;
        padding: 20px;
      }

      .modal-overlay.show {
        display: flex;
      }

      .modal-content {
        background: #ffffff;
        border-radius: 16px;
        max-width: 420px;
        width: 100%;
        padding: 24px;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: transparent;
        border: none;
        font-size: 20px;
        color: #4a5568;
        cursor: pointer;
      }

      .modal-time {
        color: #4a5568;
        margin-top: 8px;
        font-size: 0.95em;
      }

      .modal-meta {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 12px;
        margin-top: 16px;
      }

      .modal-meta div {
        background: #f7fafc;
        border-radius: 8px;
        padding: 10px;
        font-size: 0.85em;
        color: #2d3748;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .meta-label {
        font-size: 0.75em;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #718096;
      }

      .modal-description {
        margin-top: 18px;
        color: #4a5568;
        font-size: 0.95em;
        line-height: 1.5;
      }

      .modal-actions {
        display: flex;
        gap: 12px;
        margin-top: 24px;
        flex-wrap: wrap;
      }

      .modal-actions button {
        flex: 1;
        min-width: 140px;
        padding: 10px 16px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: 600;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      .modal-actions button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.18);
      }

      .modal-actions .primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #ffffff;
      }

      .modal-actions .danger {
        background: linear-gradient(135deg, #fc8181 0%, #f56565 100%);
        color: #ffffff;
      }

      .modal-actions .secondary {
        background: #edf2f7;
        color: #2d3748;
      }

      @media (max-width: 768px) {
        .main-grid {
          grid-template-columns: 1fr;
        }

        .stats-grid {
          grid-template-columns: repeat(2, 1fr);
        }
        .logo {
          height: 100px;
        }

        .modal-meta {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <img
          src="{{ url_for('static', filename='images/LockIN-logo-noBG.png') }}"
          class="logo"
          alt="LockIN logo"
        />
        <p>AI-Powered Task Scheduling with Pomodoro Tracking</p>
        <button onclick="requestNotificationPermission()">
          Enable Notifications
        </button>
      </div>

      <div class="main-grid">
        <div class="sidebar">
          <div class="add-task-form">
            <h2 style="color: #2d3748; margin-bottom: 20px">Add New Task</h2>
            <div class="form-group">
              <label for="taskName">Task Name</label>
              <input
                type="text"
                id="taskName"
                placeholder="e.g., Complete project proposal"
              />
            </div>
            <div class="form-group">
              <label for="deadline">Deadline</label>
              <input type="datetime-local" id="deadline" />
            </div>
            <div class="form-group">
              <label for="daysRequired">Days Required</label>
              <input type="number" id="daysRequired" min="1" value="1" />
            </div>
            <div class="form-group">
              <label for="dailyHours">Daily Hours</label>
              <input
                type="number"
                id="dailyHours"
                min="0.5"
                step="0.5"
                value="2"
              />
            </div>
            <button class="btn" onclick="addTask()">Add Task</button>
          </div>

          <div class="ai-suggestions" id="aiSuggestions">
            <h3>ü§ñ AI Suggestions</h3>
            <div id="suggestionsList"></div>
          </div>

          <div class="task-list">
            <h3 style="color: #2d3748; margin-bottom: 15px">Active Tasks</h3>
            <div id="taskList"></div>
          </div>
        </div>

        <div class="calendar-section">
          <div class="calendar-header">
            <h2 style="color: #2d3748">Week View</h2>
            <div class="calendar-nav">
              <button
                class="nav-btn"
                id="prevWeekBtn"
                aria-label="Previous week"
              >
                &lsaquo;
              </button>
              <span id="currentWeek" style="color: #718096"></span>
              <button class="nav-btn" id="nextWeekBtn" aria-label="Next week">
                &rsaquo;
              </button>
            </div>
          </div>
          <div class="week-view" id="weekView">
            <!-- Calendar will be generated here -->
          </div>
        </div>
      </div>

      <div class="stats-panel">
        <h3 style="color: #2d3748">Productivity Stats</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="tasksCompleted">0</div>
            <div class="stat-label">Tasks Completed</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="focusTime">0h</div>
            <div class="stat-label">Focus Time Today</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="streakDays">0</div>
            <div class="stat-label">Day Streak</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="completionRate">0%</div>
            <div class="stat-label">Completion Rate</div>
          </div>
        </div>
      </div>
    </div>

    <div class="notification" id="notification">
      <div class="notification-header" id="notificationHeader">
        Task Reminder
      </div>
      <div class="notification-body" id="notificationBody">
        It's time for your scheduled task
      </div>
      <div class="notification-actions">
        <button
          class="notification-btn accept"
          onclick="handleNotification('accept')"
        >
          Start
        </button>
        <button
          class="notification-btn reschedule"
          onclick="handleNotification('reschedule')"
        >
          Reschedule
        </button>
        <button
          class="notification-btn decline"
          onclick="handleNotification('decline')"
        >
          Skip
        </button>
      </div>
    </div>

    <div
      class="modal-overlay"
      id="eventModal"
      onclick="handleModalOverlayClick(event)"
    >
      <div class="modal-content">
        <button class="modal-close" onclick="closeEventModal()">&times;</button>
        <h3 id="modalTitle" style="color: #2d3748; font-size: 1.4em">
          Scheduled Block
        </h3>
        <p class="modal-time" id="modalTime"></p>
        <div class="modal-meta">
          <div>
            <span class="meta-label">Source</span>
            <span id="modalSource"></span>
          </div>
          <div>
            <span class="meta-label">Status</span>
            <span id="modalStatus"></span>
          </div>
          <div>
            <span class="meta-label">Duration</span>
            <span id="modalDuration"></span>
          </div>
          <div id="modalLocationRow" style="display: none">
            <span class="meta-label">Location</span>
            <span id="modalLocation"></span>
          </div>
        </div>
        <p class="modal-description" id="modalDescription"></p>
        <div class="modal-actions">
          <button
            class="secondary"
            id="modalCloseBtn"
            onclick="closeEventModal()"
          >
            Close
          </button>
          <button
            class="primary"
            id="modalStartBtn"
            onclick="startFocusFromModal()"
          >
            Start Focus Session
          </button>
          <button
            class="danger"
            id="modalDeleteBtn"
            onclick="deleteScheduleItem()"
          >
            Delete Block
          </button>
        </div>
      </div>
    </div>

    <div class="pomodoro-timer" id="pomodoroTimer" style="display: none">
      <div class="timer-display" id="timerDisplay">25:00</div>
      <div class="timer-label" id="timerLabel">Focus Time</div>
      <div class="timer-controls">
        <button
          class="timer-btn pause"
          id="pauseBtn"
          onclick="togglePauseResume()"
        >
          ‚è∏ Pause
        </button>
        <button class="timer-btn stop" onclick="stopPomodoro()">‚èπ Stop</button>
      </div>
    </div>

    <div class="google-cal-section" id="googleCalSection" style="display: none">
      <h3 style="color: #2d3748; margin-bottom: 15px">
        Google Calendar Integration
        <span
          id="authStatus"
          style="font-size: 0.8em; color: #48bb78; margin-left: 10px"
        ></span>
      </h3>
      <button class="google-btn" id="connectBtn" onclick="initiateGoogleAuth()">
        Connect Google Calendar
      </button>
      <div id="calendarEvents" style="margin-top: 15px"></div>
    </div>

    <script>
      const DISCOVERY_DOCS = [
        "https://www.googleapis.com/discovery/v1/apis/calendar/v3/rest",
      ];
      // State Management
      let tasks = JSON.parse(localStorage.getItem("tasks") || "[]");
      let schedule = JSON.parse(localStorage.getItem("schedule") || "[]");
      let dismissedGoogleEvents = new Set(
        JSON.parse(localStorage.getItem("dismissedGoogleEvents") || "[]")
      );
  let activeScheduleId = null;
      let currentTask = null;
      let pomodoroInterval = null;
      let pomodoroTimeLeft = 25 * 60;
      let pomodoroPaused = false;
      let stats = JSON.parse(
        localStorage.getItem("stats") ||
          '{"completed": 0, "focusTime": 0, "streak": 0, "totalTasks": 0}'
      );

      // Google Calendar API configuration
      const GOOGLE_CLIENT_ID = "{{ google_client_id or '' }}";
      const GOOGLE_API_KEY = "{{ calendar_api_key or '' }}";
      const SCOPES = "{{ google_scopes or '' }}";

      let domReady = false;
      window.gapiLoaded = window.gapiLoaded || false;
      let calendarApiLoaded = false;
      let googleAccountAuthenticated = false;
      let currentWeekStart = getStartOfWeek(new Date());

      // Initialize the app
      function init() {
        setDefaultDeadline();
        const prevWeekBtn = document.getElementById("prevWeekBtn");
        const nextWeekBtn = document.getElementById("nextWeekBtn");
        if (prevWeekBtn && nextWeekBtn) {
          prevWeekBtn.addEventListener("click", () => changeWeek(-1));
          nextWeekBtn.addEventListener("click", () => changeWeek(1));
        }
        renderTasks();
        renderCalendar();
        updateStats();
        startNotificationChecker();
        generateAISuggestions();

        fetch("/check_auth")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("googleCalSection").style.display = "block";
            googleAccountAuthenticated = !!data.authenticated;
            if (data.authenticated) {
              document.getElementById("connectBtn").textContent = "Connected";
              document.getElementById("connectBtn").disabled = true;
              document.getElementById("authStatus").textContent =
                "Authenticated";
              loadGoogleAPI();
              setTimeout(authenticateGapiWithFlaskToken, 1000);
            }
          });
      }
      // function authenticateGapiWithFlaskToken() {
      //   if (!gapi.auth2 || !gapi.auth2.getAuthInstance()) {
      //     setTimeout(authenticateGapiWithFlaskToken, 500);
      //     return;
      //   }
      //   fetch("/get_gapi_token")
      //     .then((r) => r.json())
      //     .then((tokenData) => {
      //       const authInstance = gapi.auth2.getAuthInstance();
      //       const user = authInstance.currentUser.get();
      //       user.reloadAuthResponse().then(() => {
      //         user.setAuthResponse({
      //           access_token: tokenData.access_token,
      //           expires_in: tokenData.expires_in,
      //           scope: tokenData.scope,
      //         });
      //         updateSigninStatus(true);
      //       });
      //     });
      // }
      function getStartOfWeek(date) {
        const d = new Date(date);
        const day = d.getDay();
        d.setDate(d.getDate() - day);
        d.setHours(0, 0, 0, 0);
        return d;
      }

      // Set default deadline to tomorrow
      function setDefaultDeadline() {
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 7);
        document.getElementById("deadline").value = tomorrow
          .toISOString()
          .slice(0, 16);
      }

      // Add a new task
      function addTask() {
        const name = document.getElementById("taskName").value;
        const deadline = document.getElementById("deadline").value;
        const daysRequired = parseInt(
          document.getElementById("daysRequired").value
        );
        const dailyHours = parseFloat(
          document.getElementById("dailyHours").value
        );

        if (!name || !deadline) {
          alert("Please fill in task name and deadline");
          return;
        }

        const task = {
          id: Date.now(),
          name,
          deadline: new Date(deadline),
          daysRequired,
          dailyHours,
          totalHours: daysRequired * dailyHours,
          completedHours: 0,
          status: "pending",
          priority: calculatePriority(
            new Date(deadline),
            daysRequired * dailyHours
          ),
          createdAt: new Date(),
        };

        tasks.push(task);
        saveTasks();

        // AI Schedule Generation
        generateSchedule(task);

        // Clear form
        document.getElementById("taskName").value = "";
        document.getElementById("daysRequired").value = "1";
        document.getElementById("dailyHours").value = "2";
        setDefaultDeadline();

        renderTasks();
        renderCalendar();
        generateAISuggestions();

        stats.totalTasks++;
        updateStats();
      }

      // Calculate task priority based on deadline and time required
      function calculatePriority(deadline, totalHours) {
        const now = new Date();
        const hoursUntilDeadline = (deadline - now) / (1000 * 60 * 60);
        const urgency = totalHours / hoursUntilDeadline;
        return Math.min(10, Math.max(1, Math.round(urgency * 10)));
      }

      // AI-powered schedule generation
      function generateSchedule(task) {
        const now = new Date();
        const deadline = new Date(task.deadline);
        const sessions = Math.ceil(task.totalHours * 2); // 30-min sessions

        let currentDate = new Date(now);
        currentDate.setHours(currentDate.getHours() + 1);
        currentDate.setMinutes(0);

        const preferredTimes = [
          { start: 9, end: 11, productivity: 1.2 }, // Morning focus
          { start: 14, end: 16, productivity: 1.0 }, // Afternoon
          { start: 19, end: 21, productivity: 0.8 }, // Evening
        ];

        let sessionsScheduled = 0;

        while (sessionsScheduled < sessions && currentDate < deadline) {
          const hour = currentDate.getHours();
          const dayOfWeek = currentDate.getDay();

          // Skip weekends for work tasks (configurable)
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            currentDate.setDate(currentDate.getDate() + 1);
            currentDate.setHours(9, 0, 0, 0);
            continue;
          }

          // Find if current hour is in preferred time
          const timeSlot = preferredTimes.find(
            (t) => hour >= t.start && hour < t.end
          );

          if (timeSlot) {
            const scheduleItem = {
              id: Date.now() + sessionsScheduled,
              taskId: task.id,
              taskName: task.name,
              start: new Date(currentDate).toISOString(),
              end: new Date(currentDate.getTime() + 30 * 60000).toISOString(), // 30 minutes
              type: "pomodoro",
              status: "scheduled",
              productivity: timeSlot.productivity,
            };

            schedule.push(scheduleItem);
            sessionsScheduled++;

            // Move to next 30-min slot
            currentDate.setMinutes(currentDate.getMinutes() + 30);
          } else {
            // Move to next hour
            currentDate.setHours(currentDate.getHours() + 1);
          }

          // If end of day, move to next day
          if (hour >= 21) {
            currentDate.setDate(currentDate.getDate() + 1);
            currentDate.setHours(9, 0, 0, 0);
          }
        }

        // Add deadline marker to schedule
        schedule.push({
          id: Date.now() + 999999,
          taskId: task.id,
          taskName: task.name + " (DEADLINE)",
          start: deadline.toISOString(),
          end: deadline.toISOString(),
          type: "deadline",
          status: "deadline",
        });

        saveSchedule();
      }

      // Generate AI suggestions for optimal work times
      function generateAISuggestions() {
        const suggestions = [];
        const now = new Date();
        const hour = now.getHours();

        // Analyze user patterns (simulated)
        const productivityScore = {
          morning: 0.9,
          afternoon: 0.7,
          evening: 0.6,
        };

        // Get high-priority tasks
        const urgentTasks = tasks
          .filter((t) => t.status !== "completed")
          .sort((a, b) => b.priority - a.priority)
          .slice(0, 3);

        urgentTasks.forEach((task) => {
          let suggestedTime = "";
          if (hour < 12 && productivityScore.morning > 0.8) {
            suggestedTime = "Now (High energy morning slot)";
          } else if (hour < 17) {
            suggestedTime = "This afternoon (2-4 PM)";
          } else {
            suggestedTime = "Tomorrow morning (9-11 AM)";
          }

          suggestions.push({
            task: task.name,
            time: suggestedTime,
            reason: `Priority: ${task.priority}/10`,
            taskId: task.id,
          });
        });

        renderAISuggestions(suggestions);
      }

      // Render AI suggestions
      function renderAISuggestions(suggestions) {
        const container = document.getElementById("suggestionsList");

        if (suggestions.length === 0) {
          container.innerHTML =
            '<p style="color: #718096; font-size: 0.9em;">No urgent tasks. Great job!</p>';
          return;
        }

        container.innerHTML = suggestions
          .map(
            (s) => `
                <div class="suggestion-item" onclick="acceptSuggestion(${s.taskId})">
                    <strong>${s.task}</strong><br>
                    <small style="color: #718096;">${s.time} ‚Ä¢ ${s.reason}</small>
                </div>
            `
          )
          .join("");
      }

      // Accept AI suggestion and start task
      function acceptSuggestion(taskId) {
        const task = tasks.find((t) => t.id === taskId);
        if (task) {
          startPomodoro(task);
        }
      }

      // Start Pomodoro timer
      function startPomodoro(task) {
        currentTask = task;
        pomodoroTimeLeft = 25 * 60; // Reset to 25 minutes
        pomodoroPaused = false;

        document.getElementById("pomodoroTimer").style.display = "flex";
        document.getElementById(
          "timerLabel"
        ).textContent = `Working on: ${task.name}`;
        document.getElementById("pauseBtn").textContent = "‚è∏ Pause";
        document.getElementById("pauseBtn").className = "timer-btn pause";

        clearInterval(pomodoroInterval);
        pomodoroInterval = setInterval(() => {
          if (!pomodoroPaused) {
            pomodoroTimeLeft--;

            const minutes = Math.floor(pomodoroTimeLeft / 60);
            const seconds = pomodoroTimeLeft % 60;
            document.getElementById("timerDisplay").textContent = `${minutes
              .toString()
              .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

            if (pomodoroTimeLeft <= 0) {
              clearInterval(pomodoroInterval);
              handlePomodoroComplete();
            }

            // 20-minute check-in (5 minutes remaining)
            if (pomodoroTimeLeft === 5 * 60) {
              showNotification(
                "Check-in",
                "Are you still working on: " + task.name + "?"
              );
            }
          }
        }, 1000);

        showNotification("Task Started", `Working on: ${task.name}`);
      }

      // Toggle pause/resume
      function togglePauseResume() {
        pomodoroPaused = !pomodoroPaused;
        const btn = document.getElementById("pauseBtn");

        if (pomodoroPaused) {
          btn.textContent = "‚ñ∂ Resume";
          btn.className = "timer-btn resume";
          showNotification(
            "Timer Paused",
            "Take a break. Click Resume when ready."
          );
        } else {
          btn.textContent = "‚è∏ Pause";
          btn.className = "timer-btn pause";
          showNotification("Timer Resumed", "Back to work!");
        }
      }

      // Stop Pomodoro timer
      function stopPomodoro() {
        clearInterval(pomodoroInterval);
        document.getElementById("pomodoroTimer").style.display = "none";

        if (currentTask) {
          // Calculate partial progress
          const minutesWorked = (25 * 60 - pomodoroTimeLeft) / 60;
          const hoursWorked = minutesWorked / 60;
          currentTask.completedHours += hoursWorked;

          stats.focusTime += hoursWorked;
          saveTasks();
          updateStats();
          renderTasks();

          showNotification(
            "Session Stopped",
            `Logged ${minutesWorked.toFixed(0)} minutes of work`
          );
        }

        currentTask = null;
        pomodoroPaused = false;
      }

      // Handle Pomodoro completion
      function handlePomodoroComplete() {
        if (currentTask) {
          currentTask.completedHours += 0.5;

          // Check if task is complete
          if (currentTask.completedHours >= currentTask.totalHours) {
            currentTask.status = "completed";
            stats.completed++;
            showNotification(
              "Task Completed! üéâ",
              `Great job on: ${currentTask.name}`
            );
          } else {
            const remaining =
              currentTask.totalHours - currentTask.completedHours;
            showNotification(
              "Session Complete",
              `${remaining.toFixed(1)} hours remaining for: ${currentTask.name}`
            );
          }

          stats.focusTime += 0.5;
          saveTasks();
          updateStats();
          renderTasks();
          renderCalendar();
        }

        document.getElementById("pomodoroTimer").style.display = "none";
        currentTask = null;
        pomodoroPaused = false;
      }

      // Render tasks list
      function renderTasks() {
        const container = document.getElementById("taskList");
        const activeTasks = tasks.filter((t) => t.status !== "completed");

        if (activeTasks.length === 0) {
          container.innerHTML =
            '<p style="color: #718096;">No active tasks</p>';
          return;
        }

        container.innerHTML = activeTasks
          .map((task) => {
            const progress = (task.completedHours / task.totalHours) * 100;
            const daysLeft = Math.ceil(
              (task.deadline - new Date()) / (1000 * 60 * 60 * 24)
            );

            return `
                    <div class="task-item">
                        <div class="task-header">
                            <span class="task-name">${task.name}</span>
                            <span class="task-deadline" style="color: ${
                              daysLeft <= 1 ? "#e53e3e" : "#718096"
                            }">
                                ${daysLeft} days left
                            </span>
                        </div>
                        <div class="task-progress">
                            <div class="progress-bar">
                                <div class="progress-fill" style="width: ${progress}%"></div>
                            </div>
                            <span style="font-size: 12px; color: #718096;">${Math.round(
                              progress
                            )}%</span>
                        </div>
                        <div style="margin-top: 8px;">
                            <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;" 
                                    onclick='startPomodoro(${JSON.stringify(
                                      task
                                    ).replace(/'/g, "&apos;")})'>
                                Start Session
                            </button>
                        </div>
                    </div>
                `;
          })
          .join("");
      }

      const CALENDAR_DAY_START = 8;
      const CALENDAR_DAY_END = 20;
      const CALENDAR_SLOT_HEIGHT = 60;

      function formatCalendarTime(date) {
        return date.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });
      }

      function formatHourLabel(hour) {
        const temp = new Date();
        temp.setHours(hour, 0, 0, 0);
        return temp.toLocaleTimeString([], { hour: "numeric", hour12: true });
      }

      // Render calendar with deadlines
      function renderCalendar() {
        const container = document.getElementById("weekView");
        if (!container) {
          return;
        }
        const now = new Date();
        const startOfWeek = new Date(currentWeekStart);

        const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
        const hours = Array.from(
          { length: CALENDAR_DAY_END - CALENDAR_DAY_START + 1 },
          (_, i) => CALENDAR_DAY_START + i
        );

        let headerHtml = '<div class="week-view-header"><div></div>';
        days.forEach((day, index) => {
          const date = new Date(startOfWeek);
          date.setDate(startOfWeek.getDate() + index);
          const isToday = date.toDateString() === now.toDateString();
          headerHtml += `<div class="day-header" style="${
            isToday ? "background: #e6fffa; border-color: #0bc5ea;" : ""
          }">
              ${day}<br><small>${date.getDate()}</small>
            </div>`;
        });
        headerHtml += "</div>";

        let bodyHtml = '<div class="week-view-grid">';
        bodyHtml += '<div class="time-column">';
        hours.forEach((hour) => {
          bodyHtml += `<div class="time-slot-label">${formatHourLabel(
            hour
          )}</div>`;
        });
        bodyHtml += "</div>";

        days.forEach((_, dayIndex) => {
          const dayDate = new Date(startOfWeek);
          dayDate.setDate(startOfWeek.getDate() + dayIndex);
          const dayStart = new Date(dayDate);
          dayStart.setHours(CALENDAR_DAY_START, 0, 0, 0);
          const dayEnd = new Date(dayDate);
          dayEnd.setHours(CALENDAR_DAY_END + 1, 0, 0, 0);
          const totalMinutes = (dayEnd - dayStart) / 60000;

          let columnHtml = `<div class="day-column-body" style="height: ${
            hours.length * CALENDAR_SLOT_HEIGHT
          }px">`;

          hours.forEach((_, hourIndex) => {
            const top = hourIndex * CALENDAR_SLOT_HEIGHT;
            columnHtml += `<div class="hour-divider" style="top: ${top}px"></div>`;
          });

          const dayEvents = schedule
            .filter((item) => {
              if (!item || item.type === "deadline") {
                return false;
              }
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              return eventEnd > dayStart && eventStart < dayEnd;
            })
            .map((item) => {
              const eventStart = new Date(item.start);
              const eventEnd = new Date(item.end || item.start);
              const rawStart = (eventStart - dayStart) / 60000;
              const rawEnd = (eventEnd - dayStart) / 60000;
              const boundedStart = Math.max(0, rawStart);
              const boundedEnd = Math.min(totalMinutes, rawEnd);
              if (boundedEnd <= 0 || boundedStart >= totalMinutes) {
                return null;
              }
              const effectiveEnd = Math.max(
                boundedEnd,
                boundedStart + 30
              );
              return {
                item,
                eventStart,
                eventEnd,
                startMinutes: boundedStart,
                endMinutes: Math.min(totalMinutes, effectiveEnd),
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

          const clusters = [];
          let activeCluster = null;
          dayEvents.forEach((event) => {
            if (
              !activeCluster ||
              event.startMinutes >= activeCluster.maxEnd
            ) {
              activeCluster = {
                events: [],
                maxEnd: event.endMinutes,
              };
              clusters.push(activeCluster);
            } else {
              activeCluster.maxEnd = Math.max(
                activeCluster.maxEnd,
                event.endMinutes
              );
            }
            activeCluster.events.push(event);
          });

          clusters.forEach((cluster) => {
            const activeEvents = [];
            cluster.columnCount = 0;

            cluster.events.sort((a, b) => {
              if (a.startMinutes === b.startMinutes) {
                return a.endMinutes - b.endMinutes;
              }
              return a.startMinutes - b.startMinutes;
            });

            cluster.events.forEach((event) => {
              for (let i = activeEvents.length - 1; i >= 0; i--) {
                if (activeEvents[i].endMinutes <= event.startMinutes) {
                  activeEvents.splice(i, 1);
                }
              }

              const usedColumns = activeEvents.map((evt) => evt.column);
              let columnIndex = 0;
              while (usedColumns.includes(columnIndex)) {
                columnIndex++;
              }

              event.column = columnIndex;
              activeEvents.push(event);
              cluster.columnCount = Math.max(
                cluster.columnCount,
                columnIndex + 1
              );
            });

            cluster.events.forEach((event) => {
              const columnCount = cluster.columnCount || 1;
              const top =
                (event.startMinutes / 60) * CALENDAR_SLOT_HEIGHT;
              const height = Math.max(
                ((event.endMinutes - event.startMinutes) / 60) *
                  CALENDAR_SLOT_HEIGHT,
                32
              );

              const columnWidth = Math.round((100 / columnCount) * 1000) / 1000;
              const leftPercent = Math.round(columnWidth * event.column * 1000) / 1000;
              const widthStyle =
                columnCount > 1
                  ? `calc(${columnWidth}% - 6px)`
                  : `calc(${columnWidth}% - 2px)`;
              const leftStyle = `${leftPercent}%`;

              const statusClass =
                event.item.status === "completed"
                  ? "completed"
                  : event.item.status === "in-progress"
                  ? "in-progress"
                  : "";
              const isExternal =
                event.item.source === "google" ||
                event.item.type === "external";
              const timeRange = `${formatCalendarTime(
                event.eventStart
              )} - ${formatCalendarTime(event.eventEnd)}`;

              columnHtml += `<div class="scheduled-task ${statusClass}${
                isExternal ? " external-event" : ""
              }" style="top: ${top}px; height: ${height}px; width: ${widthStyle}; left: ${leftStyle};" onclick="openScheduleModal('${event.item.id}')">
                <span class="event-title">${
                  event.item.taskName || "Scheduled Block"
                }</span>
                <span class="event-time">${timeRange}</span>
              </div>`;
            });
          });

          const dayDeadlines = tasks.filter((task) => {
            const deadline = new Date(task.deadline);
            return (
              deadline >= dayStart &&
              deadline <= dayEnd &&
              task.status !== "completed"
            );
          });

          dayDeadlines.forEach((task) => {
            const deadlineDate = new Date(task.deadline);
            const minutesFromStart = (deadlineDate - dayStart) / 60000;
            const top = Math.max(
              0,
              (minutesFromStart / 60) * CALENDAR_SLOT_HEIGHT - 12
            );
            columnHtml += `<div class="deadline-flag" style="top: ${top}px;">
                <span>üìç</span>
                <span>${task.name}</span>
              </div>`;
          });

          columnHtml += "</div>";
          bodyHtml += columnHtml;
        });

        bodyHtml += "</div>";

        container.innerHTML = headerHtml + bodyHtml;

        const weekEnd = new Date(startOfWeek);
        weekEnd.setDate(startOfWeek.getDate() + 6);
        document.getElementById(
          "currentWeek"
        ).textContent = `${startOfWeek.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}`;
      }

      function changeWeek(offset) {
        currentWeekStart.setDate(currentWeekStart.getDate() + offset * 7);
        currentWeekStart = getStartOfWeek(currentWeekStart);
        renderCalendar();
        if (googleAccountAuthenticated) {
          const eventsContainer = document.getElementById("calendarEvents");
          if (eventsContainer) {
            eventsContainer.innerHTML = "<p>Loading events...</p>";
          }
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) =>
              console.error("Failed to refresh calendar events", error)
            );
        }
      }

      // Handle click on scheduled item
      function handleScheduleClick(scheduleId) {
        openScheduleModal(String(scheduleId));
      }

      function openScheduleModal(scheduleId) {
        const modal = document.getElementById("eventModal");
        if (!modal) {
          return;
        }

        const item = schedule.find(
          (entry) => String(entry.id) === String(scheduleId)
        );
        if (!item) {
          return;
        }

        activeScheduleId = item.id;

        const start = new Date(item.start);
        const end = item.end
          ? new Date(item.end)
          : new Date(start.getTime() + 30 * 60 * 1000);

        document.getElementById("modalTitle").textContent =
          item.taskName || "Scheduled Block";
        document.getElementById(
          "modalTime"
        ).textContent = `${start.toLocaleString()} - ${end.toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        })}`;

        document.getElementById("modalSource").textContent =
          item.source === "google" || item.type === "external"
            ? "Google Calendar"
            : "FocusFlow";
        document.getElementById("modalStatus").textContent =
          (item.status || "scheduled").replace(/-/g, " ");
        document.getElementById("modalDuration").textContent = formatDuration(
          end.getTime() - start.getTime()
        );

        const locationRow = document.getElementById("modalLocationRow");
        if (item.location) {
          locationRow.style.display = "flex";
          document.getElementById("modalLocation").textContent = item.location;
        } else {
          locationRow.style.display = "none";
        }

        if (item.source === "google" || item.type === "external") {
          document.getElementById("modalDescription").textContent =
            "Managed via Google Calendar. Hide it here or update it directly in Google.";
          document.getElementById("modalStartBtn").style.display = "none";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Hide This Event";
        } else {
          const relatedTask = tasks.find((t) => t.id === item.taskId);
          const priorityInfo =
            relatedTask && typeof relatedTask.priority === "number"
              ? ` Priority ${relatedTask.priority}/10.`
              : "";
          const description = relatedTask
            ? `Focus block for "${relatedTask.name}".${priorityInfo}`
            : "Focus block scheduled via AI.";
          document.getElementById("modalDescription").textContent = description;
          document.getElementById("modalStartBtn").style.display = "inline-flex";
          const deleteBtn = document.getElementById("modalDeleteBtn");
          deleteBtn.style.display = "inline-flex";
          deleteBtn.textContent = "Delete Block";
        }

        modal.classList.add("show");
      }

      function closeEventModal() {
        const modal = document.getElementById("eventModal");
        if (modal) {
          modal.classList.remove("show");
        }
        activeScheduleId = null;
      }

      function handleModalOverlayClick(event) {
        if (event.target && event.target.id === "eventModal") {
          closeEventModal();
        }
      }

      function startFocusFromModal() {
        if (activeScheduleId === null) {
          return;
        }
        const item = schedule.find(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (!item || !item.taskId) {
          return;
        }
        const task = tasks.find((t) => t.id === item.taskId);
        if (!task) {
          return;
        }

        startPomodoro(task);
        item.status = "in-progress";
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function deleteScheduleItem() {
        if (activeScheduleId === null) {
          return;
        }
        const index = schedule.findIndex(
          (entry) => String(entry.id) === String(activeScheduleId)
        );
        if (index === -1) {
          closeEventModal();
          return;
        }

        const [removed] = schedule.splice(index, 1);
        if (removed && removed.source === "google" && removed.externalId) {
          dismissedGoogleEvents.add(removed.externalId);
          saveDismissedGoogleEvents();
        }
        saveSchedule();
        renderCalendar();
        closeEventModal();
      }

      function formatDuration(milliseconds) {
        const totalMinutes = Math.max(1, Math.round(milliseconds / 60000));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0 && minutes > 0) {
          return `${hours}h ${minutes}m`;
        }
        if (hours > 0) {
          return `${hours}h`;
        }
        return `${minutes}m`;
      }

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeEventModal();
        }
      });

      // Google Calendar Integration
      function loadGoogleAPI() {
        if (typeof gapi === "undefined" || !gapi.load) {
          setTimeout(loadGoogleAPI, 100);
          return;
        }
        gapi.load("client:auth2", initGoogleClient);
      }

      function initGoogleClient() {
        gapi.load("client", () => {
          gapi.client
            .init({
              apiKey: GOOGLE_API_KEY,
              discoveryDocs: DISCOVERY_DOCS,
            })
            .then(() => authenticateGapiWithFlaskToken());
        });
      }

      function authenticateGapiWithFlaskToken() {
        if (!gapi.client || !gapi.client.setToken) {
          setTimeout(authenticateGapiWithFlaskToken, 500);
          return;
        }
        fetch("/get_gapi_token")
          .then((r) => r.json())
          .then((tokenData) => {
            gapi.client.setToken({ access_token: tokenData.access_token });
            ensureCalendarApiLoaded()
              .then(() => updateSigninStatus(true))
              .catch((error) => {
                console.error("Failed to load Google Calendar API", error);
              });
          });
      }

      function updateSigninStatus(isSignedIn) {
        if (isSignedIn && gapi.client.getToken()) {
          ensureCalendarApiLoaded()
            .then(() => loadCalendarEvents(currentWeekStart))
            .catch((error) => {
              console.error("Google Calendar API not ready", error);
            });
        }
      }

      function ensureCalendarApiLoaded() {
        if (calendarApiLoaded) {
          return Promise.resolve();
        }
        if (!gapi.client || !gapi.client.load) {
          return Promise.reject(new Error("gapi client not ready"));
        }
        return gapi.client.load("calendar", "v3").then(() => {
          calendarApiLoaded = true;
        });
      }

      //function initiateGoogleAuth() {
      //  gapi.auth2.getAuthInstance().signIn();
      //}

      function initiateGoogleAuth() {
        // Use Flask OAuth instead of gapi
        window.location.href = "/auth";
      }

      function loadCalendarEvents(weekStart = currentWeekStart) {
        const startWindow = new Date(weekStart);
        startWindow.setHours(0, 0, 0, 0);
        const endWindow = new Date(weekStart);
        endWindow.setDate(endWindow.getDate() + 7);
        endWindow.setHours(23, 59, 59, 999);
        gapi.client.calendar.events
          .list({
            calendarId: "primary",
            timeMin: startWindow.toISOString(),
            timeMax: endWindow.toISOString(),
            showDeleted: false,
            singleEvents: true,
            maxResults: 250,
            orderBy: "startTime",
          })
          .then((response) => {
            const events = response.result.items;
            displayGoogleEvents(events);
            extractDeadlinesFromEvents(events);
            mergeGoogleEventsIntoSchedule(events);
          });
      }

      function displayGoogleEvents(events) {
        const container = document.getElementById("calendarEvents");
        if (events.length > 0) {
          container.innerHTML = "<h4>Upcoming Google Calendar Events:</h4>";
          events.forEach((event) => {
            const when = event.start.dateTime || event.start.date;
            container.innerHTML += `
                        <div style="padding: 8px; background: #f7fafc; margin: 5px 0; border-radius: 6px;">
                            <strong>${event.summary}</strong><br>
                            <small>${new Date(when).toLocaleString()}</small>
                            ${
                              event.description &&
                              event.description.includes("deadline")
                                ? `<button onclick="importAsTask('${event.summary}', '${when}')" 
                                 style="margin-left: 10px; padding: 2px 8px; background: #667eea; 
                                 color: white; border: none; border-radius: 4px; cursor: pointer;">
                                 Import as Task
                                </button>`
                                : ""
                            }
                        </div>
                    `;
          });
        } else {
          container.innerHTML = "<p>No upcoming events found.</p>";
        }
      }

      function extractDeadlinesFromEvents(events) {
        events.forEach((event) => {
          // Check if event title or description contains deadline keywords
          const deadlineKeywords = [
            "deadline",
            "due",
            "submit",
            "delivery",
            "final",
          ];
          const hasDeadline = deadlineKeywords.some(
            (keyword) =>
              (event.summary &&
                event.summary.toLowerCase().includes(keyword)) ||
              (event.description &&
                event.description.toLowerCase().includes(keyword))
          );

          if (hasDeadline) {
            console.log("Found potential deadline:", event.summary);
            // Auto-suggest as task
            showNotification(
              "Deadline Detected",
              `Found deadline in calendar: "${event.summary}". Click to import.`
            );
          }
        });
      }

      function mergeGoogleEventsIntoSchedule(events) {
        if (!Array.isArray(events)) {
          return;
        }

        const normalizedEvents = events
          .filter((event) => event && event.id && event.start)
          .filter((event) => !dismissedGoogleEvents.has(event.id));
        const incomingIds = new Set(normalizedEvents.map((event) => event.id));

        schedule = schedule.filter((item) => {
          if (item && item.source === "google" && item.externalId) {
            return incomingIds.has(item.externalId);
          }
          return true;
        });

        normalizedEvents.forEach((event) => {
          const alreadySynced = schedule.some(
            (item) => item.source === "google" && item.externalId === event.id
          );
          if (alreadySynced) {
            return;
          }

          const startIso =
            event.start.dateTime ||
            (event.start.date ? `${event.start.date}T09:00:00` : null);
          if (!startIso) {
            return;
          }

          const endIso =
            event.end?.dateTime ||
            (event.end?.date ? `${event.end.date}T17:00:00` : null);

          const startDate = new Date(startIso);
          const endDate = endIso
            ? new Date(endIso)
            : new Date(startDate.getTime() + 60 * 60 * 1000);

          schedule.push({
            id: Date.now() + Math.floor(Math.random() * 1000),
            externalId: event.id,
            source: "google",
            taskId: null,
            taskName: `${event.summary || "Google Event"}`,
            start: startDate.toISOString(),
            end: endDate.toISOString(),
            type: "external",
            status: "scheduled",
            location: event.location || "",
          });
        });

        schedule.sort(
          (a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()
        );

        saveSchedule();
        renderCalendar();
      }

      function importAsTask(eventName, eventTime) {
        document.getElementById("taskName").value = eventName;
        document.getElementById("deadline").value = new Date(eventTime)
          .toISOString()
          .slice(0, 16);
        showNotification(
          "Task Imported",
          "Deadline imported from Google Calendar. Adjust hours and add task."
        );
      }

      // Show notification
      function showNotification(title, body) {
        const notification = document.getElementById("notification");
        document.getElementById("notificationHeader").textContent = title;
        document.getElementById("notificationBody").textContent = body;
        notification.classList.add("show");

        // Auto-hide after 5 seconds
        setTimeout(() => {
          notification.classList.remove("show");
        }, 5000);

        // Browser notification if permitted
        if (Notification.permission === "granted") {
          new Notification(title, { body, icon: "üéØ" });
        }
      }

      // Handle notification actions
      function handleNotification(action) {
        const notification = document.getElementById("notification");
        notification.classList.remove("show");

        if (action === "accept" && currentTask) {
          // Continue with current task
        } else if (action === "reschedule") {
          // Move to next available slot
          generateAISuggestions();
        } else if (action === "decline") {
          // Track reason (simplified for MVP)
          const reasons = [
            "Too tired",
            "Emergency came up",
            "Need a break",
            "Other priority",
          ];
          const reason = reasons[Math.floor(Math.random() * reasons.length)];
          console.log("Task declined:", reason);
        }
      }

      // Check for upcoming scheduled tasks
      function startNotificationChecker() {
        setInterval(() => {
          const now = new Date();
          const upcoming = schedule.filter((s) => {
            const startTime = new Date(s.start);
            const timeDiff = (startTime - now) / (1000 * 60); // minutes
            return timeDiff > 0 && timeDiff <= 5 && s.status === "scheduled";
          });

          if (upcoming.length > 0) {
            const next = upcoming[0];
            showNotification(
              "Upcoming Task",
              `"${next.taskName}" starts in 5 minutes. Get ready!`
            );
          }

          // Check for missed deadlines
          tasks.forEach((task) => {
            if (task.status !== "completed") {
              const hoursUntilDeadline =
                (task.deadline - now) / (1000 * 60 * 60);
              if (hoursUntilDeadline > 0 && hoursUntilDeadline <= 1) {
                showNotification(
                  "‚ö†Ô∏è Deadline Alert",
                  `"${task.name}" deadline in ${Math.round(
                    hoursUntilDeadline * 60
                  )} minutes!`
                );
              }
            }
          });
        }, 60000); // Check every minute
      }

      // Update statistics
      function updateStats() {
        document.getElementById("tasksCompleted").textContent = stats.completed;
        document.getElementById(
          "focusTime"
        ).textContent = `${stats.focusTime.toFixed(1)}h`;
        document.getElementById("streakDays").textContent = stats.streak;

        const completionRate =
          stats.totalTasks > 0
            ? Math.round((stats.completed / stats.totalTasks) * 100)
            : 0;
        document.getElementById(
          "completionRate"
        ).textContent = `${completionRate}%`;

        localStorage.setItem("stats", JSON.stringify(stats));
      }

      // Save functions
      function saveTasks() {
        localStorage.setItem("tasks", JSON.stringify(tasks));
      }

      function saveSchedule() {
        localStorage.setItem("schedule", JSON.stringify(schedule));
      }

      function saveDismissedGoogleEvents() {
        localStorage.setItem(
          "dismissedGoogleEvents",
          JSON.stringify(Array.from(dismissedGoogleEvents))
        );
      }

      // // Request notification permission
      // if ("Notification" in window && Notification.permission === "default") {
      //   // Notification.requestPermission();
      // }

      function requestNotificationPermission() {
        Notification.requestPermission().then((perm) => {
          if (perm === "granted") alert("Notifications enabled!");
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        domReady = true;
        window.domReady = true;
        if (window.gapiLoaded) {
          init();
        }
      });

      setTimeout(() => {
        if (!window.gapiLoaded && typeof gapi !== "undefined") {
          window.gapiLoaded = true;
          if (domReady) {
            init();
          }
        }
      }, 3000);
      console.log("page ready ‚Äì gapi loaded:", !!window.gapi);
    </script>
  </body>
</html>
